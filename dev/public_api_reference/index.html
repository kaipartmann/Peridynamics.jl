<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Public API · Peridynamics.jl</title><meta name="title" content="Public API · Peridynamics.jl"/><meta property="og:title" content="Public API · Peridynamics.jl"/><meta property="twitter:title" content="Public API · Peridynamics.jl"/><meta name="description" content="Documentation for Peridynamics.jl."/><meta property="og:description" content="Documentation for Peridynamics.jl."/><meta property="twitter:description" content="Documentation for Peridynamics.jl."/><meta property="og:url" content="https://kaipartmann.github.io/Peridynamics.jl/public_api_reference/"/><meta property="twitter:url" content="https://kaipartmann.github.io/Peridynamics.jl/public_api_reference/"/><link rel="canonical" href="https://kaipartmann.github.io/Peridynamics.jl/public_api_reference/"/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><link href="../assets/custom.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.png" alt="Peridynamics.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">Peridynamics.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><input class="collapse-toggle" id="menuitem-2" type="checkbox"/><label class="tocitem" for="menuitem-2"><span class="docs-label">Explanations</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../expl_general_pd/">Basics of peridynamics theory</a></li><li><a class="tocitem" href="../expl_bondbased/">Bond-based peridynamics</a></li><li><a class="tocitem" href="../expl_osbased/">Ordinary state-based peridynamics</a></li><li><a class="tocitem" href="../expl_nosbased/">Non-ordinary state-based peridynamics</a></li><li><a class="tocitem" href="../expl_continuumbased/">Continuum-kinematics-inspired peridynamics</a></li><li><a class="tocitem" href="../expl_damage/">Damage in peridynamics formulations</a></li><li><a class="tocitem" href="../expl_references/">References</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3" type="checkbox"/><label class="tocitem" for="menuitem-3"><span class="docs-label">How-to guides</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../howto_mpi/">Simulations with MPI</a></li><li><a class="tocitem" href="../howto_visualization/">Visualization with ParaView</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4" type="checkbox"/><label class="tocitem" for="menuitem-4"><span class="docs-label">Tutorials</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../generated/tutorial_tension_static/">Tensile test quasi-static</a></li><li><a class="tocitem" href="../generated/tutorial_tension_dynfrac/">Tensile test dynamic</a></li><li><a class="tocitem" href="../generated/tutorial_tension_precrack/">Tension with predefined crack</a></li><li><a class="tocitem" href="../generated/tutorial_wave_in_bar/">Wave propagation in a thin bar</a></li><li><a class="tocitem" href="../generated/tutorial_wave_interface/">Wave propagation across material interface</a></li><li><a class="tocitem" href="../generated/tutorial_kalthoff-winkler_dynfrac/">Kalthoff-Winkler experiment</a></li><li><a class="tocitem" href="../generated/tutorial_logo/">The old Peridynamics.jl logo</a></li><li><a class="tocitem" href="../generated/tutorial_cylinder/">Fragmenting Cylinder</a></li><li><a class="tocitem" href="../generated/tutorial_brazilian_test/">Brazilian Test</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-5" type="checkbox"/><label class="tocitem" for="menuitem-5"><span class="docs-label">Development</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../dev_systems/">Systems</a></li><li><a class="tocitem" href="../dev_materials/">Materials</a></li><li><a class="tocitem" href="../dev_solvers/">Time solvers</a></li><li><a class="tocitem" href="../dev_multithreading_mpi/">Multithreading &amp; MPI</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-6" type="checkbox" checked/><label class="tocitem" for="menuitem-6"><span class="docs-label">API Reference</span><i class="docs-chevron"></i></label><ul class="collapsed"><li class="is-active"><a class="tocitem" href>Public API</a><ul class="internal"><li><a class="tocitem" href="#Material-models"><span>Material models</span></a></li><li><a class="tocitem" href="#System-or-material-related-types"><span>System or material related types</span></a></li><li><a class="tocitem" href="#Discretization"><span>Discretization</span></a></li><li><a class="tocitem" href="#Preprocessing-and-simulation-setup"><span>Preprocessing &amp; simulation setup</span></a></li><li><a class="tocitem" href="#Solving"><span>Solving</span></a></li><li><a class="tocitem" href="#Postprocessing"><span>Postprocessing</span></a></li></ul></li><li><a class="tocitem" href="../private_api_reference/">Private API</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">API Reference</a></li><li class="is-active"><a href>Public API</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Public API</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/kaipartmann/Peridynamics.jl/blob/main/docs/src/public_api_reference.md#" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Public-API"><a class="docs-heading-anchor" href="#Public-API">Public API</a><a id="Public-API-1"></a><a class="docs-heading-anchor-permalink" href="#Public-API" title="Permalink"></a></h1><ul><li><a href="#Public-API">Public API</a></li><li class="no-marker"><ul><li><a href="#Material-models">Material models</a></li><li><a href="#System-or-material-related-types">System or material related types</a></li><li><a href="#Discretization">Discretization</a></li><li><a href="#Preprocessing-and-simulation-setup">Preprocessing &amp; simulation setup</a></li><li><a href="#Solving">Solving</a></li><li><a href="#Postprocessing">Postprocessing</a></li></ul></li></ul><h2 id="Material-models"><a class="docs-heading-anchor" href="#Material-models">Material models</a><a id="Material-models-1"></a><a class="docs-heading-anchor-permalink" href="#Material-models" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="Peridynamics.BBMaterial"><a class="docstring-binding" href="#Peridynamics.BBMaterial"><code>Peridynamics.BBMaterial</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">BBMaterial()
BBMaterial{Correction}()</code></pre><p>A material type used to assign the material of a <a href="#Peridynamics.Body"><code>Body</code></a> with the standard bond-based formulation of peridynamics.</p><p><strong>Keywords</strong></p><ul><li><code>dmgmodel::AbstractDamageModel</code>: Damage model defining the fracture behavior.   (default: <code>CriticalStretch()</code>)</li></ul><p>Possible correction methods are:</p><ul><li><a href="#Peridynamics.NoCorrection"><code>NoCorrection</code></a>: No correction is applied. (default)</li><li><a href="#Peridynamics.EnergySurfaceCorrection"><code>EnergySurfaceCorrection</code></a>: The energy based surface correction method of   Le and Bobaru (2018) is applied.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; mat = BBMaterial()
BBMaterial{NoCorrection}()

julia&gt; mat = BBMaterial{EnergySurfaceCorrection}()
BBMaterial{EnergySurfaceCorrection}()</code></pre><hr/><pre><code class="language-julia hljs">BBMaterial{Correction}</code></pre><p>Material type for the bond-based peridynamics formulation.</p><p><strong>Type Parameters</strong></p><ul><li><code>Correction</code>: A correction algorithm type. See the constructor docs for more informations.</li><li><code>DM</code>: A damage model type.</li></ul><p><strong>Allowed material parameters</strong></p><p>When using <a href="#Peridynamics.material!"><code>material!</code></a> on a <a href="#Peridynamics.Body"><code>Body</code></a> with <code>BBMaterial</code>, then the following parameters are allowed: Material parameters:</p><ul><li><code>horizon::Float64</code>: Radius of point interactions.</li><li><code>rho::Float64</code>: Density.</li></ul><p>Elastic parameters</p><ul><li><code>E::Float64</code>: Young&#39;s modulus.</li><li><code>G::Float64</code>: Shear modulus.</li><li><code>K::Float64</code>: Bulk modulus.</li><li><code>lambda::Float64</code>: 1st Lamé parameter.</li><li><code>mu::Float64</code>: 2nd Lamé parameter.</li></ul><p>Fracture parameters:</p><ul><li><code>Gc::Float64</code>: Critical energy release rate.</li><li><code>epsilon_c::Float64</code>: Critical strain.</li></ul><div class="admonition is-info" id="Poisson&#39;s-ratio-and-bond-based-peridynamics-d07ed8a075074326"><header class="admonition-header">Poisson&#39;s ratio and bond-based peridynamics<a class="admonition-anchor" href="#Poisson&#39;s-ratio-and-bond-based-peridynamics-d07ed8a075074326" title="Permalink"></a></header><div class="admonition-body"><p>In bond-based peridynamics, the Poisson&#39;s ratio is limited to 1/4 for 3D simulations. Therefore, only one additional elastic parameter is required. Optionally, the specification of a second keyword is allowed, if the parameter combination results in <code>nu = 1/4</code>.</p></div></div><p><strong>Allowed export fields</strong></p><p>When specifying the <code>fields</code> keyword of <a href="#Peridynamics.Job"><code>Job</code></a> for a <a href="#Peridynamics.Body"><code>Body</code></a> with <code>BBMaterial</code>, the following fields are allowed:</p><ul><li><code>position::Matrix{Float64}</code>: Position of each point.</li><li><code>displacement::Matrix{Float64}</code>: Displacement of each point.</li><li><code>velocity::Matrix{Float64}</code>: Velocity of each point.</li><li><code>velocity_half::Matrix{Float64}</code>: Velocity parameter for Verlet time solver.</li><li><code>acceleration::Matrix{Float64}</code>: Acceleration of each point.</li><li><code>b_int::Matrix{Float64}</code>: Internal force density of each point.</li><li><code>b_ext::Matrix{Float64}</code>: External force density of each point.</li><li><code>damage::Vector{Float64}</code>: Damage of each point.</li><li><code>n_active_bonds::Vector{Int}</code>: Number of intact bonds of each point.</li><li><code>strain_energy_density::Vector{Float64}</code>: Strain energy density of each point.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kaipartmann/Peridynamics.jl/blob/d67dbd041ce7c52845c592e60db0e50e326f82c0/src/physics/bond_based.jl#L1-L73">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Peridynamics.DHBBMaterial"><a class="docstring-binding" href="#Peridynamics.DHBBMaterial"><code>Peridynamics.DHBBMaterial</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">DHBBMaterial()
DHBBMaterial{Correction}()</code></pre><p>A material type used to assign the material of a <a href="#Peridynamics.Body"><code>Body</code></a> with the dual-horizon bond-based formulation of peridynamics.</p><p><strong>Keywords</strong></p><ul><li><code>dmgmodel::AbstractDamageModel</code>: Damage model defining the fracture behavior.   (default: <code>CriticalStretch()</code>)</li></ul><p>Possible correction methods are:</p><ul><li><a href="#Peridynamics.NoCorrection"><code>NoCorrection</code></a>: No correction is applied. (default)</li><li><a href="#Peridynamics.EnergySurfaceCorrection"><code>EnergySurfaceCorrection</code></a>: The energy based surface correction method of   Le and Bobaru (2018) is applied.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; mat = DHBBMaterial()
DHBBMaterial{NoCorrection}()

julia&gt; mat = DHBBMaterial{EnergySurfaceCorrection}()
DHBBMaterial{EnergySurfaceCorrection}()</code></pre><hr/><pre><code class="language-julia hljs">DHBBMaterial{Correction}</code></pre><p>Material type for the dual-horizon bond-based peridynamics formulation.</p><p><strong>Type Parameters</strong></p><ul><li><code>Correction</code>: A correction algorithm type. See the constructor docs for more informations.</li><li><code>DM</code>: A damage model type.</li></ul><p><strong>Allowed material parameters</strong></p><p>When using <a href="#Peridynamics.material!"><code>material!</code></a> on a <a href="#Peridynamics.Body"><code>Body</code></a> with <code>DHBBMaterial</code>, then the following parameters are allowed: Material parameters:</p><ul><li><code>horizon::Float64</code>: Radius of point interactions.</li><li><code>rho::Float64</code>: Density.</li></ul><p>Elastic parameters:</p><ul><li><code>E::Float64</code>: Young&#39;s modulus.</li><li><code>G::Float64</code>: Shear modulus.</li><li><code>K::Float64</code>: Bulk modulus.</li><li><code>lambda::Float64</code>: 1st Lamé parameter.</li><li><code>mu::Float64</code>: 2nd Lamé parameter.</li></ul><p>Fracture parameters:</p><ul><li><code>Gc::Float64</code>: Critical energy release rate.</li><li><code>epsilon_c::Float64</code>: Critical strain.</li></ul><div class="admonition is-info" id="Poisson&#39;s-ratio-and-bond-based-peridynamics-d07ed8a075074326"><header class="admonition-header">Poisson&#39;s ratio and bond-based peridynamics<a class="admonition-anchor" href="#Poisson&#39;s-ratio-and-bond-based-peridynamics-d07ed8a075074326" title="Permalink"></a></header><div class="admonition-body"><p>In bond-based peridynamics, the Poisson&#39;s ratio is limited to 1/4 for 3D simulations. Therefore, only one additional elastic parameter is required. Optionally, the specification of a second keyword is allowed, if the parameter combination results in <code>nu = 1/4</code>.</p></div></div><p><strong>Allowed export fields</strong></p><p>When specifying the <code>fields</code> keyword of <a href="#Peridynamics.Job"><code>Job</code></a> for a <a href="#Peridynamics.Body"><code>Body</code></a> with <code>DHBBMaterial</code>, the following fields are allowed:</p><ul><li><code>position::Matrix{Float64}</code>: Position of each point.</li><li><code>displacement::Matrix{Float64}</code>: Displacement of each point.</li><li><code>velocity::Matrix{Float64}</code>: Velocity of each point.</li><li><code>velocity_half::Matrix{Float64}</code>: Velocity parameter for Verlet time solver.</li><li><code>acceleration::Matrix{Float64}</code>: Acceleration of each point.</li><li><code>b_int::Matrix{Float64}</code>: Internal force density of each point.</li><li><code>b_ext::Matrix{Float64}</code>: External force density of each point.</li><li><code>damage::Vector{Float64}</code>: Damage of each point.</li><li><code>n_active_bonds::Vector{Int}</code>: Number of intact bonds of each point.</li><li><code>strain_energy_density::Vector{Float64}</code>: Strain energy density of each point.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kaipartmann/Peridynamics.jl/blob/d67dbd041ce7c52845c592e60db0e50e326f82c0/src/physics/dh_bond_based.jl#L1-L73">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Peridynamics.GBBMaterial"><a class="docstring-binding" href="#Peridynamics.GBBMaterial"><code>Peridynamics.GBBMaterial</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">GBBMaterial()
GBBMaterial{Correction}()</code></pre><p>A material type used to assign the material of a <a href="#Peridynamics.Body"><code>Body</code></a> with the generalized bond-based formulation of peridynamics.</p><p><strong>Keywords</strong></p><ul><li><code>dmgmodel::AbstractDamageModel</code>: Damage model defining the fracture behavior.   (default: <code>CriticalStretch()</code>)</li></ul><p>Possible correction methods are:</p><ul><li><a href="#Peridynamics.NoCorrection"><code>NoCorrection</code></a>: No correction is applied. (default)</li><li><a href="#Peridynamics.EnergySurfaceCorrection"><code>EnergySurfaceCorrection</code></a>: The energy based surface correction method of   Le and Bobaru (2018) is applied.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; mat = GBBMaterial()
GBBMaterial{NoCorrection}()

julia&gt; mat = GBBMaterial{EnergySurfaceCorrection}()
GBBMaterial{EnergySurfaceCorrection}()</code></pre><hr/><pre><code class="language-julia hljs">GBBMaterial{Correction}</code></pre><p>Material type for the dual-horizon bond-based peridynamics formulation.</p><p><strong>Type Parameters</strong></p><ul><li><code>Correction</code>: A correction algorithm type. See the constructor docs for more informations.</li><li><code>DM</code>: A damage model type.</li></ul><p><strong>Allowed material parameters</strong></p><p>When using <a href="#Peridynamics.material!"><code>material!</code></a> on a <a href="#Peridynamics.Body"><code>Body</code></a> with <code>GBBMaterial</code>, then the following parameters are allowed: Material parameters:</p><ul><li><code>horizon::Float64</code>: Radius of point interactions.</li><li><code>rho::Float64</code>: Density.</li></ul><p>Elastic parameters:</p><ul><li><code>E::Float64</code>: Young&#39;s modulus.</li><li><code>G::Float64</code>: Shear modulus.</li><li><code>K::Float64</code>: Bulk modulus.</li><li><code>lambda::Float64</code>: 1st Lamé parameter.</li><li><code>mu::Float64</code>: 2nd Lamé parameter.</li></ul><p>Fracture parameters:</p><ul><li><code>Gc::Float64</code>: Critical energy release rate.</li><li><code>epsilon_c::Float64</code>: Critical strain.</li></ul><div class="admonition is-info" id="Poisson&#39;s-ratio-and-bond-based-peridynamics-d07ed8a075074326"><header class="admonition-header">Poisson&#39;s ratio and bond-based peridynamics<a class="admonition-anchor" href="#Poisson&#39;s-ratio-and-bond-based-peridynamics-d07ed8a075074326" title="Permalink"></a></header><div class="admonition-body"><p>In bond-based peridynamics, the Poisson&#39;s ratio is limited to 1/4 for 3D simulations. Therefore, only one additional elastic parameter is required. Optionally, the specification of a second keyword is allowed, if the parameter combination results in <code>nu = 1/4</code>.</p></div></div><p><strong>Allowed export fields</strong></p><p>When specifying the <code>fields</code> keyword of <a href="#Peridynamics.Job"><code>Job</code></a> for a <a href="#Peridynamics.Body"><code>Body</code></a> with <code>GBBMaterial</code>, the following fields are allowed:</p><ul><li><code>position::Matrix{Float64}</code>: Position of each point.</li><li><code>displacement::Matrix{Float64}</code>: Displacement of each point.</li><li><code>velocity::Matrix{Float64}</code>: Velocity of each point.</li><li><code>velocity_half::Matrix{Float64}</code>: Velocity parameter for Verlet time solver.</li><li><code>acceleration::Matrix{Float64}</code>: Acceleration of each point.</li><li><code>b_int::Matrix{Float64}</code>: Internal force density of each point.</li><li><code>b_ext::Matrix{Float64}</code>: External force density of each point.</li><li><code>damage::Vector{Float64}</code>: Damage of each point.</li><li><code>n_active_bonds::Vector{Int}</code>: Number of intact bonds of each point.</li><li><code>strain_energy_density::Vector{Float64}</code>: Strain energy density of each point.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kaipartmann/Peridynamics.jl/blob/d67dbd041ce7c52845c592e60db0e50e326f82c0/src/physics/generalized_bond_based.jl#L1-L73">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Peridynamics.OSBMaterial"><a class="docstring-binding" href="#Peridynamics.OSBMaterial"><code>Peridynamics.OSBMaterial</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">OSBMaterial(; kernel, dmgmodel)
OSBMaterial{Correction}(; kernel, dmgmodel)</code></pre><p>A material type used to assign the material of a <a href="#Peridynamics.Body"><code>Body</code></a> with the ordinary state-based formulation of peridynamics.</p><p>Possible correction methods are:</p><ul><li><a href="#Peridynamics.NoCorrection"><code>NoCorrection</code></a>: No correction is applied. (default)</li><li><a href="#Peridynamics.EnergySurfaceCorrection"><code>EnergySurfaceCorrection</code></a>: The energy based surface correction method of   Le and Bobaru (2018) is applied.</li></ul><p><strong>Keywords</strong></p><ul><li><code>kernel::Function</code>: Kernel function used for weighting the interactions between points. <br/>  (default: <code>linear_kernel</code>)</li><li><code>dmgmodel::AbstractDamageModel</code>: Damage model defining the damage behavior. <br/>  (default: <code>CriticalStretch()</code>)</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; mat = OSBMaterial()
OSBMaterial{NoCorrection}(dmgmodel=CriticalStretch())

julia&gt; mat = OSBMaterial{EnergySurfaceCorrection}()
OSBMaterial{EnergySurfaceCorrection}(dmgmodel=CriticalStretch())</code></pre><hr/><pre><code class="language-julia hljs">OSBMaterial{Correction,K,DM}</code></pre><p>Material type for the ordinary state-based peridynamics formulation.</p><p><strong>Type Parameters</strong></p><ul><li><code>Correction</code>: A correction algorithm type. See the constructor docs for more informations.</li><li><code>K</code>: A kernel function type. See the constructor docs for more informations.</li><li><code>DM</code>: A damage model type. See the constructor docs for more informations.</li></ul><p><strong>Fields</strong></p><ul><li><code>kernel::Function</code>: Kernel function used for weighting the interactions between points.</li><li><code>dmgmodel::AbstractDamageModel</code>: Damage model defining the damage behavior. See the   constructor docs for more informations.</li></ul><p><strong>Allowed material parameters</strong></p><p>When using <a href="#Peridynamics.material!"><code>material!</code></a> on a <a href="#Peridynamics.Body"><code>Body</code></a> with <code>OSBMaterial</code>, then the following parameters are allowed: Material parameters:</p><ul><li><code>horizon::Float64</code>: Radius of point interactions.</li><li><code>rho::Float64</code>: Density.</li></ul><p>Elastic parameters:</p><ul><li><code>E::Float64</code>: Young&#39;s modulus.</li><li><code>nu::Float64</code>: Poisson&#39;s ratio.</li><li><code>G::Float64</code>: Shear modulus.</li><li><code>K::Float64</code>: Bulk modulus.</li><li><code>lambda::Float64</code>: 1st Lamé parameter.</li><li><code>mu::Float64</code>: 2nd Lamé parameter.</li></ul><p>Fracture parameters:</p><ul><li><code>Gc::Float64</code>: Critical energy release rate.</li><li><code>epsilon_c::Float64</code>: Critical strain.</li></ul><div class="admonition is-info" id="Elastic-parameters-a9a0573a2a6bb2f7"><header class="admonition-header">Elastic parameters<a class="admonition-anchor" href="#Elastic-parameters-a9a0573a2a6bb2f7" title="Permalink"></a></header><div class="admonition-body"><p>Note that exactly two elastic parameters are required to specify a material. Please choose two out of the six allowed elastic parameters.</p></div></div><p><strong>Allowed export fields</strong></p><p>When specifying the <code>fields</code> keyword of <a href="#Peridynamics.Job"><code>Job</code></a> for a <a href="#Peridynamics.Body"><code>Body</code></a> with <code>OSBMaterial</code>, the following fields are allowed:</p><ul><li><code>position::Matrix{Float64}</code>: Position of each point.</li><li><code>displacement::Matrix{Float64}</code>: Displacement of each point.</li><li><code>velocity::Matrix{Float64}</code>: Velocity of each point.</li><li><code>velocity_half::Matrix{Float64}</code>: Velocity parameter for Verlet time solver.</li><li><code>acceleration::Matrix{Float64}</code>: Acceleration of each point.</li><li><code>b_int::Matrix{Float64}</code>: Internal force density of each point.</li><li><code>b_ext::Matrix{Float64}</code>: External force density of each point.</li><li><code>damage::Vector{Float64}</code>: Damage of each point.</li><li><code>n_active_bonds::Vector{Int}</code>: Number of intact bonds of each point.</li><li><code>strain_energy_density::Vector{Float64}</code>: Strain energy density of each point.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kaipartmann/Peridynamics.jl/blob/d67dbd041ce7c52845c592e60db0e50e326f82c0/src/physics/ordinary_state_based.jl#L1-L81">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Peridynamics.CMaterial"><a class="docstring-binding" href="#Peridynamics.CMaterial"><code>Peridynamics.CMaterial</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">CMaterial(; kernel, model, zem, dmgmodel, maxdmg)</code></pre><p>A material type used to assign the material of a <a href="#Peridynamics.Body"><code>Body</code></a> with the local continuum consistent (correspondence) formulation of non-ordinary state-based peridynamics.</p><p><strong>Keywords</strong></p><ul><li><code>kernel::Function</code>: Kernel function used for weighting the interactions between points. <br/>  (default: <code>linear_kernel</code>) <br/>  The following kernels can be used:<ul><li><a href="#Peridynamics.const_one_kernel"><code>const_one_kernel</code></a></li><li><a href="#Peridynamics.linear_kernel"><code>linear_kernel</code></a></li><li><a href="#Peridynamics.cubic_b_spline_kernel"><code>cubic_b_spline_kernel</code></a></li></ul></li><li><code>model::AbstractConstitutiveModel</code>: Constitutive model defining the material behavior. <br/>  (default: <code>SaintVenantKirchhoff()</code>) <br/>  The following models can be used:<ul><li><a href="#Peridynamics.SaintVenantKirchhoff"><code>SaintVenantKirchhoff</code></a></li><li><a href="#Peridynamics.LinearElastic"><code>LinearElastic</code></a></li><li><a href="#Peridynamics.NeoHooke"><code>NeoHooke</code></a></li><li><a href="#Peridynamics.NeoHookePenalty"><code>NeoHookePenalty</code></a></li></ul></li><li><code>zem::AbstractZEMStabilization</code>: Algorithm of zero-energy mode stabilization. <br/>  (default: <a href="#Peridynamics.ZEMSilling"><code>ZEMSilling</code></a>) <br/>  The following algorithms can be used:<ul><li><a href="#Peridynamics.ZEMSilling"><code>ZEMSilling</code></a></li><li><a href="#Peridynamics.ZEMWan"><code>ZEMWan</code></a></li></ul></li><li><code>dmgmodel::AbstractDamageModel</code>: Damage model defining the damage behavior. <br/>  (default: <a href="#Peridynamics.CriticalStretch"><code>CriticalStretch</code></a>)</li><li><code>maxdmg::Float64</code>: Maximum value of damage a point is allowed to obtain. If this value is   exceeded, all bonds of that point are broken because the deformation gradient would then   possibly contain <code>NaN</code> values. <br/>  (default: <code>0.85</code>)</li></ul><div class="admonition is-info" id="Stability-of-fracture-simulations-566fa4f1729fda9d"><header class="admonition-header">Stability of fracture simulations<a class="admonition-anchor" href="#Stability-of-fracture-simulations-566fa4f1729fda9d" title="Permalink"></a></header><div class="admonition-body"><p>This formulation is known to be not suitable for fracture simulations without stabilization of the zero-energy modes. Therefore be careful when doing fracture simulations and try out different parameters for <code>maxdmg</code> and <code>zem</code>.</p></div></div><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; mat = CMaterial()
CMaterial{SaintVenantKirchhoff, ZEMSilling, typeof(linear_kernel), CriticalStretch}(maxdmg=0.85)</code></pre><hr/><pre><code class="language-julia hljs">CMaterial{CM,ZEM,K,DM}</code></pre><p>Material type for the local continuum consistent (correspondence) formulation of non-ordinary state-based peridynamics.</p><p><strong>Type Parameters</strong></p><ul><li><code>CM</code>: A constitutive model type. See the constructor docs for more informations.</li><li><code>ZEM</code>: A zero-energy mode stabilization type. See the constructor docs for more        informations.</li><li><code>K</code>: A kernel function type. See the constructor docs for more informations.</li><li><code>DM</code>: A damage model type. See the constructor docs for more informations.</li></ul><p><strong>Fields</strong></p><ul><li><code>kernel::Function</code>: Kernel function used for weighting the interactions between points.   See the constructor docs for more informations.</li><li><code>model::AbstractConstitutiveModel</code>: Constitutive model defining the material behavior. See   the constructor docs for more informations.</li><li><code>zem::AbstractZEMStabilization</code>: Zero-energy mode stabilization. See the constructor docs   for more informations.</li><li><code>dmgmodel::AbstractDamageModel</code>: Damage model defining the damage behavior. See the   constructor docs for more informations.</li><li><code>maxdmg::Float64</code>: Maximum value of damage a point is allowed to obtain. See the   constructor docs for more informations.</li></ul><p><strong>Allowed material parameters</strong></p><p>When using <a href="#Peridynamics.material!"><code>material!</code></a> on a <a href="#Peridynamics.Body"><code>Body</code></a> with <code>CMaterial</code>, then the following parameters are allowed: Material parameters:</p><ul><li><code>horizon::Float64</code>: Radius of point interactions.</li><li><code>rho::Float64</code>: Density.</li></ul><p>Elastic parameters:</p><ul><li><code>E::Float64</code>: Young&#39;s modulus.</li><li><code>nu::Float64</code>: Poisson&#39;s ratio.</li><li><code>G::Float64</code>: Shear modulus.</li><li><code>K::Float64</code>: Bulk modulus.</li><li><code>lambda::Float64</code>: 1st Lamé parameter.</li><li><code>mu::Float64</code>: 2nd Lamé parameter.</li></ul><p>Fracture parameters:</p><ul><li><code>Gc::Float64</code>: Critical energy release rate.</li><li><code>epsilon_c::Float64</code>: Critical strain.</li></ul><div class="admonition is-info" id="Elastic-parameters-a9a0573a2a6bb2f7"><header class="admonition-header">Elastic parameters<a class="admonition-anchor" href="#Elastic-parameters-a9a0573a2a6bb2f7" title="Permalink"></a></header><div class="admonition-body"><p>Note that exactly two elastic parameters are required to specify a material. Please choose two out of the six allowed elastic parameters.</p></div></div><p><strong>Allowed export fields</strong></p><p>When specifying the <code>fields</code> keyword of <a href="#Peridynamics.Job"><code>Job</code></a> for a <a href="#Peridynamics.Body"><code>Body</code></a> with <code>CMaterial</code>, the following fields are allowed:</p><ul><li><code>position::Matrix{Float64}</code>: Position of each point.</li><li><code>displacement::Matrix{Float64}</code>: Displacement of each point.</li><li><code>velocity::Matrix{Float64}</code>: Velocity of each point.</li><li><code>velocity_half::Matrix{Float64}</code>: Velocity parameter for Verlet time solver.</li><li><code>acceleration::Matrix{Float64}</code>: Acceleration of each point.</li><li><code>b_int::Matrix{Float64}</code>: Internal force density of each point.</li><li><code>b_ext::Matrix{Float64}</code>: External force density of each point.</li><li><code>damage::Vector{Float64}</code>: Damage of each point.</li><li><code>n_active_bonds::Vector{Int}</code>: Number of intact bonds of each point.</li><li><code>cauchy_stress::Matrix{Float64}</code>: Cauchy stress tensor of each point.</li><li><code>von_mises_stress::Vector{Float64}</code>: Von Mises stress of each point.</li><li><code>hydrostatic_stress::Vector{Float64}</code>: Hydrostatic stress of each point.</li><li><code>strain_energy_density::Vector{Float64}</code>: Strain energy density of each point.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kaipartmann/Peridynamics.jl/blob/d67dbd041ce7c52845c592e60db0e50e326f82c0/src/physics/correspondence.jl#L1-L110">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Peridynamics.CRMaterial"><a class="docstring-binding" href="#Peridynamics.CRMaterial"><code>Peridynamics.CRMaterial</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">CRMaterial(; kernel, model, zem, dmgmodel, maxdmg)</code></pre><p>The same as the <a href="#Peridynamics.CMaterial"><code>CMaterial</code></a> but with rotation of the stress tensor for large deformation simulations, therefore not all models are supported.</p><p>Supported models:</p><ul><li><code>SaintVenantKirchhoff</code></li><li><code>LinearElastic</code></li></ul><p>Please take a look at the <a href="#Peridynamics.CMaterial"><code>CMaterial</code></a> docs for more information about the material!</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kaipartmann/Peridynamics.jl/blob/d67dbd041ce7c52845c592e60db0e50e326f82c0/src/physics/correspondence_rotated.jl#L1-L13">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Peridynamics.BACMaterial"><a class="docstring-binding" href="#Peridynamics.BACMaterial"><code>Peridynamics.BACMaterial</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">BACMaterial(; kernel, model, dmgmodel, maxdmg)</code></pre><p>A material type used to assign the material of a <a href="#Peridynamics.Body"><code>Body</code></a> with the bond-associated correspondence formulation of Chen and Spencer (2019).</p><p><strong>Keywords</strong></p><ul><li><code>kernel::Function</code>: Kernel function used for weighting the interactions between points.   (default: <code>linear_kernel</code>)</li><li><code>model::AbstractConstitutiveModel</code>: Constitutive model defining the material behavior.   (default: <code>SaintVenantKirchhoff()</code>)</li><li><code>dmgmodel::AbstractDamageModel</code>: Damage model defining the fracture behavior.   (default: <code>CriticalStretch()</code>)</li><li><code>maxdmg::Float64</code>: Maximum value of damage a point is allowed to obtain. If this value is   exceeded, all bonds of that point are broken because the deformation gradient would then   possibly contain <code>NaN</code> values.   (default: <code>0.85</code>)</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; mat = BACMaterial()
BACMaterial{SaintVenantKirchhoff, typeof(linear_kernel), CriticalStretch}()</code></pre><hr/><pre><code class="language-julia hljs">BACMaterial{CM,K,DM}</code></pre><p>Material type for the bond-associated correspondence formulation of Chen and Spencer (2019).</p><p><strong>Type Parameters</strong></p><ul><li><code>CM</code>: A constitutive model type. See the constructor docs for more informations.</li><li><code>K</code>: A kernel function type. See the constructor docs for more informations.</li><li><code>DM</code>: A damage model type.</li></ul><p><strong>Fields</strong></p><ul><li><code>kernel::Function</code>: Kernel function used for weighting the interactions between points.</li><li><code>model::AbstractConstitutiveModel</code>: Constitutive model defining the material behavior.</li><li><code>dmgmodel::AbstractDamageModel</code>: Damage model defining the fracture behavior.</li><li><code>maxdmg::Float64</code>: Maximum value of damage a point is allowed to obtain. See the   constructor docs for more informations.</li></ul><p><strong>Allowed material parameters</strong></p><p>When using <a href="#Peridynamics.material!"><code>material!</code></a> on a <a href="#Peridynamics.Body"><code>Body</code></a> with <code>BACMaterial</code>, then the following parameters are allowed:</p><ul><li><code>horizon::Float64</code>: Radius of point interactions.</li><li><code>rho::Float64</code>: Density.</li><li><code>E::Float64</code>: Young&#39;s modulus.</li><li><code>nu::Float64</code>: Poisson&#39;s ratio.</li><li><code>Gc::Float64</code>: Critical energy release rate.</li><li><code>epsilon_c::Float64</code>: Critical strain.</li></ul><p><strong>Allowed export fields</strong></p><p>When specifying the <code>fields</code> keyword of <a href="#Peridynamics.Job"><code>Job</code></a> for a <a href="#Peridynamics.Body"><code>Body</code></a> with <code>BACMaterial</code>, the following fields are allowed:</p><ul><li><code>position::Matrix{Float64}</code>: Position of each point.</li><li><code>displacement::Matrix{Float64}</code>: Displacement of each point.</li><li><code>velocity::Matrix{Float64}</code>: Velocity of each point.</li><li><code>velocity_half::Matrix{Float64}</code>: Velocity parameter for Verlet time solver.</li><li><code>acceleration::Matrix{Float64}</code>: Acceleration of each point.</li><li><code>b_int::Matrix{Float64}</code>: Internal force density of each point.</li><li><code>b_ext::Matrix{Float64}</code>: External force density of each point.</li><li><code>damage::Vector{Float64}</code>: Damage of each point.</li><li><code>n_active_bonds::Vector{Int}</code>: Number of intact bonds of each point.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kaipartmann/Peridynamics.jl/blob/d67dbd041ce7c52845c592e60db0e50e326f82c0/src/physics/ba_correspondence.jl#L1-L67">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Peridynamics.CKIMaterial"><a class="docstring-binding" href="#Peridynamics.CKIMaterial"><code>Peridynamics.CKIMaterial</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">CKIMaterial(; dmgmodel)</code></pre><p>A material type used to assign the material of a <a href="#Peridynamics.Body"><code>Body</code></a> with the continuum-kinematics-inspired peridynamics formulation.</p><p><strong>Keywords</strong></p><ul><li><code>dmgmodel::AbstractDamageModel</code>: Damage model defining the damage behavior. <br/>  (default: <code>CriticalStretch()</code>)</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; mat = CKIMaterial()
CKIMaterial(dmgmodel=CriticalStretch())</code></pre><hr/><pre><code class="language-julia hljs">CKIMaterial{DM}</code></pre><p>Material type for the continuum-kinematics-inspired peridynamics framework.</p><p><strong>Type Parameters</strong></p><ul><li><code>DM</code>: A damage model type. See the constructor docs for more informations.</li></ul><p><strong>Fields</strong></p><ul><li><code>dmgmodel::AbstractDamageModel</code>: Damage model defining the damage behavior. See the   constructor docs for more informations.</li></ul><p><strong>Allowed material parameters</strong></p><p>When using <a href="#Peridynamics.material!"><code>material!</code></a> on a <a href="#Peridynamics.Body"><code>Body</code></a> with <code>CKIMaterial</code>, then the following parameters are allowed: Material parameters:</p><ul><li><code>horizon::Float64</code>: Radius of point interactions.</li><li><code>rho::Float64</code>: Density.</li></ul><p>Elastic parameters:</p><ul><li><code>E::Float64</code>: Young&#39;s modulus.</li><li><code>nu::Float64</code>: Poisson&#39;s ratio.</li><li><code>G::Float64</code>: Shear modulus.</li><li><code>K::Float64</code>: Bulk modulus.</li><li><code>lambda::Float64</code>: 1st Lamé parameter.</li><li><code>mu::Float64</code>: 2nd Lamé parameter.</li></ul><p>Fracture parameters:</p><ul><li><code>Gc::Float64</code>: Critical energy release rate.</li><li><code>epsilon_c::Float64</code>: Critical strain.</li></ul><p>Interaction parameters:</p><ul><li><code>C1::Float64</code>: One-neighbor interaction parameter. (default: <code>0.0</code>)</li><li><code>C2::Float64</code>: Two-neighbor interaction parameter. (default: <code>0.0</code>)</li><li><code>C3::Float64</code>: Two-neighbor interaction parameter. (default: <code>0.0</code>)</li></ul><div class="admonition is-warning" id="Specification-of-interaction-parameters-86f0dab3c5bd1024"><header class="admonition-header">Specification of interaction parameters<a class="admonition-anchor" href="#Specification-of-interaction-parameters-86f0dab3c5bd1024" title="Permalink"></a></header><div class="admonition-body"><p>If any of the interaction parameters is used with <a href="#Peridynamics.material!"><code>material!</code></a>, the Young&#39;s modulus and Poisson&#39;s ratio are ignored and only the specified interaction parameters will influence the force density calculated from that interaction.</p><p>If no interaction parameter is specified, then the Young&#39;s modulus and Poisson&#39;s ratio are used to calculate these parameters accordingly to Ekiz, Steinmann, and Javili (2022).</p></div></div><div class="admonition is-info" id="Elastic-parameters-a9a0573a2a6bb2f7"><header class="admonition-header">Elastic parameters<a class="admonition-anchor" href="#Elastic-parameters-a9a0573a2a6bb2f7" title="Permalink"></a></header><div class="admonition-body"><p>Note that exactly two elastic parameters are required to specify a material. Please choose two out of the six allowed elastic parameters.</p></div></div><p><strong>Allowed export fields</strong></p><p>When specifying the <code>fields</code> keyword of <a href="#Peridynamics.Job"><code>Job</code></a> for a <a href="#Peridynamics.Body"><code>Body</code></a> with <code>CKIMaterial</code>, the following fields are allowed:</p><ul><li><code>position::Matrix{Float64}</code>: Position of each point.</li><li><code>displacement::Matrix{Float64}</code>: Displacement of each point.</li><li><code>velocity::Matrix{Float64}</code>: Velocity of each point.</li><li><code>velocity_half::Matrix{Float64}</code>: Velocity parameter for Verlet time solver.</li><li><code>acceleration::Matrix{Float64}</code>: Acceleration of each point.</li><li><code>b_int::Matrix{Float64}</code>: Internal force density of each point.</li><li><code>b_ext::Matrix{Float64}</code>: External force density of each point.</li><li><code>damage::Vector{Float64}</code>: Damage of each point.</li><li><code>n_active_one_nis::Vector{Int}</code>: Number of intact one-neighbor interactions of each point.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kaipartmann/Peridynamics.jl/blob/d67dbd041ce7c52845c592e60db0e50e326f82c0/src/physics/continuum_kinematics_inspired.jl#L1-L79">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Peridynamics.RKCMaterial"><a class="docstring-binding" href="#Peridynamics.RKCMaterial"><code>Peridynamics.RKCMaterial</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">RKCMaterial(; kernel, model, dmgmodel, monomial, lambda, beta)</code></pre><p>A material type used to assign the material of a <a href="#Peridynamics.Body"><code>Body</code></a> with a reproducing kernel peridynamics (correspondence) formulation with bond-associated quadrature integration at the center of the bonds.</p><p><strong>Keywords</strong></p><ul><li><code>kernel::Function</code>: Kernel function used for weighting the interactions between points. <br/>  (default: <code>const_one_kernel</code>) <br/>  The following kernels can be used:<ul><li><a href="#Peridynamics.const_one_kernel"><code>const_one_kernel</code></a></li><li><a href="#Peridynamics.linear_kernel"><code>linear_kernel</code></a></li><li><a href="#Peridynamics.cubic_b_spline_kernel_norm"><code>cubic_b_spline_kernel_norm</code></a></li><li><a href="#Peridynamics.cubic_b_spline_kernel"><code>cubic_b_spline_kernel</code></a></li></ul></li><li><code>model::AbstractConstitutiveModel</code>: Constitutive model defining the material behavior. <br/>  (default: <code>SaintVenantKirchhoff()</code>) <br/>  The following models can be used:<ul><li><a href="#Peridynamics.SaintVenantKirchhoff"><code>SaintVenantKirchhoff</code></a></li><li><a href="#Peridynamics.LinearElastic"><code>LinearElastic</code></a></li><li><a href="#Peridynamics.NeoHooke"><code>NeoHooke</code></a></li><li><a href="#Peridynamics.NeoHookePenalty"><code>NeoHookePenalty</code></a></li></ul></li><li><code>dmgmodel::AbstractDamageModel</code>: Damage model defining the damage behavior. <br/>  (default: <a href="#Peridynamics.CriticalStretch"><code>CriticalStretch</code></a>)</li><li><code>monomial::Symbol</code>: The monomial vector used for the reproducing kernel approximation   of the moment matrix. This kernel is used to calculate the moment matrix and the   gradient weights, which are used to approximate the deformation gradient. <br/>  (default: <code>:C1</code>) <br/>  The following kernels can be used:<ul><li><code>:C1</code>: Linear monomial basis vector [x, y, z] with first-order accuracy, equivalent to   the standard correspondence formulation. This is the default kernel.</li><li><code>:RK1</code>: First-order monomial basis vector [1, x, y, z] with constant term   for enhanced stability in uniform deformation fields.</li><li><code>:RK2</code>: Second-order monomial basis vector [1, x, y, z, x², y², z²] with   diagonal quadratic terms for improved accuracy in curved deformation fields.</li><li><code>:PD2</code>: Second-order monomial basis vector [x, y, z, x², xy, xz, y², yz, z²] with   full quadratic terms but without constant term.</li></ul></li><li><code>lambda::Real</code>: Relative Tikhonov regularization parameter (dimensionless, non-negative).   Internally scaled by the largest singular value of the moment matrix during inversion   with <a href="../private_api_reference/#Peridynamics.invreg"><code>invreg</code></a>. For well-conditioned problems, the default value of <code>0</code> (no   Tikhonov regularization) is recommended. See <a href="../private_api_reference/#Peridynamics.invreg"><code>invreg</code></a> for details.<br/>  (default: <code>0</code>)</li><li><code>beta::Real</code>: Relative SVD truncation parameter (dimensionless, non-negative). Internally   scaled by the largest singular value of the moment matrix during inversion with   <a href="../private_api_reference/#Peridynamics.invreg"><code>invreg</code></a>. Primary regularization mechanism for singular moment matrices. See   <a href="../private_api_reference/#Peridynamics.invreg"><code>invreg</code></a> for parameter selection guidelines.<br/>  (default: <code>sqrt(eps())</code>)</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; mat = RKCMaterial()
RKCMaterial{SaintVenantKirchhoff, typeof(linear_kernel), CriticalStretch}()</code></pre><hr/><pre><code class="language-julia hljs">RKCMaterial{CM,K,DM}</code></pre><p>Material type for a reproducing kernel peridynamics (correspondence) formulation with bond-associated quadrature integration at the center of the bonds.</p><p><strong>Type Parameters</strong></p><ul><li><code>CM</code>: A constitutive model type. See the constructor docs for more informations.</li><li><code>K</code>: A kernel function type. See the constructor docs for more informations.</li><li><code>DM</code>: A damage model type. See the constructor docs for more informations.</li></ul><p><strong>Fields</strong></p><ul><li><code>kernel::Function</code>: Kernel function used for weighting the interactions between points.   See the constructor docs for more informations.</li><li><code>model::AbstractConstitutiveModel</code>: Constitutive model defining the material behavior. See   the constructor docs for more informations.</li><li><code>dmgmodel::AbstractDamageModel</code>: Damage model defining the damage behavior. See the   constructor docs for more informations.</li><li><code>monomial::Symbol</code>: The monomial vector used for the reproducing kernel approximation. See   the constructor docs for more informations.</li><li><code>lambda::Float64</code>: Tikhonov regularization parameter. See the constructor docs for more   informations.</li><li><code>beta::Float64</code>: SVD truncation parameter. See the constructor docs for more   informations.</li></ul><p><strong>Allowed material parameters</strong></p><p>When using <a href="#Peridynamics.material!"><code>material!</code></a> on a <a href="#Peridynamics.Body"><code>Body</code></a> with <code>RKCMaterial</code>, then the following parameters are allowed: Material parameters:</p><ul><li><code>horizon::Float64</code>: Radius of point interactions</li><li><code>rho::Float64</code>: Density</li></ul><p>Elastic parameters:</p><ul><li><code>E::Float64</code>: Young&#39;s modulus</li><li><code>nu::Float64</code>: Poisson&#39;s ratio</li><li><code>G::Float64</code>: Shear modulus</li><li><code>K::Float64</code>: Bulk modulus</li><li><code>lambda::Float64</code>: 1st Lamé parameter</li><li><code>mu::Float64</code>: 2nd Lamé parameter</li></ul><p>Fracture parameters:</p><ul><li><code>Gc::Float64</code>: Critical energy release rate</li><li><code>epsilon_c::Float64</code>: Critical strain</li></ul><div class="admonition is-info" id="Elastic-parameters-a9a0573a2a6bb2f7"><header class="admonition-header">Elastic parameters<a class="admonition-anchor" href="#Elastic-parameters-a9a0573a2a6bb2f7" title="Permalink"></a></header><div class="admonition-body"><p>Note that exactly two elastic parameters are required to specify a material. Please choose two out of the six allowed elastic parameters.</p></div></div><p><strong>Allowed export fields</strong></p><p>When specifying the <code>fields</code> keyword of <a href="#Peridynamics.Job"><code>Job</code></a> for a <a href="#Peridynamics.Body"><code>Body</code></a> with <code>RKCMaterial</code>, the following fields are allowed:</p><ul><li><code>position::Matrix{Float64}</code>: Position of each point</li><li><code>displacement::Matrix{Float64}</code>: Displacement of each point</li><li><code>velocity::Matrix{Float64}</code>: Velocity of each point</li><li><code>velocity_half::Matrix{Float64}</code>: Velocity parameter for Verlet time solver</li><li><code>acceleration::Matrix{Float64}</code>: Acceleration of each point</li><li><code>b_int::Matrix{Float64}</code>: Internal force density of each point</li><li><code>b_ext::Matrix{Float64}</code>: External force density of each point</li><li><code>damage::Vector{Float64}</code>: Damage of each point</li><li><code>n_active_bonds::Vector{Int}</code>: Number of intact bonds of each point</li><li><code>cauchy_stress::Matrix{Float64}</code>: Cauchy stress tensor of each point</li><li><code>von_mises_stress::Vector{Float64}</code>: Von Mises stress of each point</li><li><code>hydrostatic_stress::Vector{Float64}</code>: Hydrostatic stress of each point.</li><li><code>strain_energy_density::Vector{Float64}</code>: Strain energy density of each point.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kaipartmann/Peridynamics.jl/blob/d67dbd041ce7c52845c592e60db0e50e326f82c0/src/physics/rk_correspondence.jl#L1-L121">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Peridynamics.RKCRMaterial"><a class="docstring-binding" href="#Peridynamics.RKCRMaterial"><code>Peridynamics.RKCRMaterial</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">RKCRMaterial(; kernel, model, dmgmodel, monomial, lambda, beta)</code></pre><p>The same as the <a href="#Peridynamics.RKCMaterial"><code>RKCMaterial</code></a> but with rotation of the stress tensor for large deformation simulations, therefore not all models are supported.</p><p>Supported models:</p><ul><li><code>SaintVenantKirchhoff</code></li><li><code>LinearElastic</code></li></ul><p>Please take a look at the <a href="#Peridynamics.RKCMaterial"><code>RKCMaterial</code></a> docs for more information about the material, including details about the <code>monomial</code>, <code>lambda</code>, and <code>beta</code> parameters!</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kaipartmann/Peridynamics.jl/blob/d67dbd041ce7c52845c592e60db0e50e326f82c0/src/physics/rk_correspondence_rotated.jl#L1-L13">source</a></section></details></article><h2 id="System-or-material-related-types"><a class="docs-heading-anchor" href="#System-or-material-related-types">System or material related types</a><a id="System-or-material-related-types-1"></a><a class="docs-heading-anchor-permalink" href="#System-or-material-related-types" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="Peridynamics.CriticalStretch"><a class="docstring-binding" href="#Peridynamics.CriticalStretch"><code>Peridynamics.CriticalStretch</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">CriticalStretch</code></pre><p>A damage model based on the stretch of the bond. The bond is considered to be broken if the stretch exceeds a critical value. The critical value can be defined via the fracture energy <code>Gc</code> or the critical stretch <code>εc</code> using the <a href="#Peridynamics.material!"><code>material!</code></a> function. The damage model is defined globally for the whole body as part of the material.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kaipartmann/Peridynamics.jl/blob/d67dbd041ce7c52845c592e60db0e50e326f82c0/src/physics/fracture.jl#L1-L9">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Peridynamics.NoCorrection"><a class="docstring-binding" href="#Peridynamics.NoCorrection"><code>Peridynamics.NoCorrection</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">NoCorrection</code></pre><p>A correction handler for materials that use the bond system. If <code>NoCorrection</code> is used, then no correction will be applied.</p><p>See also <a href="#Peridynamics.BBMaterial"><code>BBMaterial</code></a>, <a href="#Peridynamics.OSBMaterial"><code>OSBMaterial</code></a> for further information on how to use the correction type.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kaipartmann/Peridynamics.jl/blob/d67dbd041ce7c52845c592e60db0e50e326f82c0/src/discretization/bond_system_corrections.jl#L2-L10">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Peridynamics.EnergySurfaceCorrection"><a class="docstring-binding" href="#Peridynamics.EnergySurfaceCorrection"><code>Peridynamics.EnergySurfaceCorrection</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">EnergySurfaceCorrection</code></pre><p>A correction handler for materials that use the bond system. If <code>EnergySurfaceCorrection</code> is used, then the energy based surface correction method of Le and Bobaru (2018) is used.</p><p>See also <a href="#Peridynamics.BBMaterial"><code>BBMaterial</code></a>, <a href="#Peridynamics.OSBMaterial"><code>OSBMaterial</code></a> for further information on how to use the correction type.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kaipartmann/Peridynamics.jl/blob/d67dbd041ce7c52845c592e60db0e50e326f82c0/src/discretization/bond_system_corrections.jl#L29-L37">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Peridynamics.ZEMSilling"><a class="docstring-binding" href="#Peridynamics.ZEMSilling"><code>Peridynamics.ZEMSilling</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">ZEMSilling(; Cs)</code></pre><p>Zero-energy mode stabilization algorithm of Silling (2017). This is necessary for the correspondence formulation to stabilize the zero-energy modes. See also <a href="#Peridynamics.CMaterial"><code>CMaterial</code></a> on how to use this stabilization algorithm.</p><p><strong>Keywords</strong></p><ul><li><code>Cs::Real</code>: Stabilization factor. (default: <code>0.5</code>)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kaipartmann/Peridynamics.jl/blob/d67dbd041ce7c52845c592e60db0e50e326f82c0/src/discretization/zem_stabilization.jl#L6-L15">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Peridynamics.ZEMWan"><a class="docstring-binding" href="#Peridynamics.ZEMWan"><code>Peridynamics.ZEMWan</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">ZEMWan()</code></pre><p>Zero-energy mode stabilization algorithm of Wan et al. (2019), which is an improvement to Silling&#39;s algorithm that does not require a stabilization parameter. See also <a href="#Peridynamics.CMaterial"><code>CMaterial</code></a> on how to use this stabilization algorithm.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kaipartmann/Peridynamics.jl/blob/d67dbd041ce7c52845c592e60db0e50e326f82c0/src/discretization/zem_stabilization.jl#L23-L29">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Peridynamics.LinearElastic"><a class="docstring-binding" href="#Peridynamics.LinearElastic"><code>Peridynamics.LinearElastic</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">LinearElastic</code></pre><p>Linear elastic constitutive model that can be specified when using a <a href="#Peridynamics.CMaterial"><code>CMaterial</code></a> and <a href="#Peridynamics.BACMaterial"><code>BACMaterial</code></a>.</p><p>The strain energy density <span>$\Psi$</span> is given by</p><p class="math-container">\[\Psi = \frac{1}{2} \lambda \, \mathrm{tr}(\boldsymbol{E})^2 + \mu \, \mathrm{tr}(\boldsymbol{E} \cdot \boldsymbol{E}) \; ,\]</p><p>with the first and second Lamé parameters <span>$\lambda$</span> and <span>$\mu$</span>, and the Green-Lagrange strain tensor <span>$\boldsymbol{E}$</span></p><p class="math-container">\[\boldsymbol{E} = \frac{1}{2} \left( \boldsymbol{F}^{\top} \boldsymbol{F} - \boldsymbol{I}
                             \right) \; .\]</p><p>The first Piola-Kirchhoff stress <span>$\boldsymbol{P}$</span> is given by</p><p class="math-container">\[\begin{aligned}
\boldsymbol{S} &amp;= \mathbb{C} : \boldsymbol{E} \; , \\
\boldsymbol{P} &amp;= \boldsymbol{F} \, \boldsymbol{S} \; ,
\end{aligned}\]</p><p>with the deformation gradient <span>$\boldsymbol{F}$</span>, the elastic stiffness tensor <span>$\mathbb{C}$</span>, and the second Piola-Kirchhoff stress <span>$\boldsymbol{S}$</span>.</p><div class="admonition is-info" id="Note-1d5581e8e794fc31"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-1d5581e8e794fc31" title="Permalink"></a></header><div class="admonition-body"><p>This model is equivalent to the Saint-Venant-Kirchhoff model, but uses a different implementation based on the elastic stiffness tensor.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kaipartmann/Peridynamics.jl/blob/d67dbd041ce7c52845c592e60db0e50e326f82c0/src/physics/constitutive_models.jl#L50-L80">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Peridynamics.NeoHooke"><a class="docstring-binding" href="#Peridynamics.NeoHooke"><code>Peridynamics.NeoHooke</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">NeoHooke</code></pre><p>Compressible Neo-Hookean hyperelastic constitutive model that can be specified when using a <a href="#Peridynamics.CMaterial"><code>CMaterial</code></a> and <a href="#Peridynamics.BACMaterial"><code>BACMaterial</code></a>.</p><p>The strain energy density <span>$\Psi$</span> is given by</p><p class="math-container">\[\Psi = \frac{1}{2} \mu \left( I_1 - 3 \right) - \mu \log(J) + \frac{1}{2} \lambda \log(J)^2 \; ,\]</p><p>with the first invariant <span>$I_1 = \mathrm{tr}(\boldsymbol{C})$</span> of the right Cauchy-Green deformation tensor <span>$\boldsymbol{C} = \boldsymbol{F}^{\top} \boldsymbol{F}$</span>, the Jacobian <span>$J = \mathrm{det}(\boldsymbol{F})$</span>, and the first and second Lamé parameters <span>$\lambda$</span> and <span>$\mu$</span>.</p><p>The first Piola-Kirchhoff stress <span>$\boldsymbol{P}$</span> is given by</p><p class="math-container">\[\begin{aligned}
\boldsymbol{C} &amp;= \boldsymbol{F}^{\top} \boldsymbol{F} \; , \\
\boldsymbol{S} &amp;= \mu \left( \boldsymbol{I} - \boldsymbol{C}^{-1} \right)
    + \lambda \log(J) \boldsymbol{C}^{-1} \; , \\
\boldsymbol{P} &amp;= \boldsymbol{F} \, \boldsymbol{S} \; ,
\end{aligned}\]</p><p>with the deformation gradient <span>$\boldsymbol{F}$</span> and the second Piola-Kirchhoff stress <span>$\boldsymbol{S}$</span>.</p><p><strong>Reference</strong></p><p>Treloar, L. R. G. (1943). &quot;The elasticity of a network of long-chain molecules—II.&quot; <em>Transactions of the Faraday Society</em>, 39, 241–246. DOI: <a href="https://doi.org/10.1039/TF9433900241">10.1039/TF9433900241</a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kaipartmann/Peridynamics.jl/blob/d67dbd041ce7c52845c592e60db0e50e326f82c0/src/physics/constitutive_models.jl#L135-L166">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Peridynamics.NeoHookePenalty"><a class="docstring-binding" href="#Peridynamics.NeoHookePenalty"><code>Peridynamics.NeoHookePenalty</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">NeoHookePenalty</code></pre><p>Compressible Neo-Hookean hyperelastic model with a penalty-type volumetric formulation, suitable for modeling rubber-like and biological materials. Can be specified when using a <a href="#Peridynamics.CMaterial"><code>CMaterial</code></a> and <a href="#Peridynamics.BACMaterial"><code>BACMaterial</code></a>.</p><p>The strain energy density <span>$\Psi$</span> is given by</p><p class="math-container">\[\Psi = \frac{1}{2} G \left( \bar{I}_1 - 3 \right) + \frac{K}{8} \left( J^2 + J^{-2} - 2 \right) \; ,\]</p><p>with the modified first invariant <span>$\bar{I}_1 = I_1 J^{-2/3}$</span> where <span>$I_1 = \mathrm{tr}(\boldsymbol{C})$</span> is the first invariant of the right Cauchy-Green deformation tensor <span>$\boldsymbol{C} = \boldsymbol{F}^{\top} \boldsymbol{F}$</span>, the Jacobian <span>$J = \mathrm{det}(\boldsymbol{F})$</span>, the shear modulus <span>$G$</span>, and the bulk modulus <span>$K$</span>.</p><p>The first Piola-Kirchhoff stress <span>$\boldsymbol{P}$</span> is given by</p><p class="math-container">\[\begin{aligned}
\boldsymbol{C} &amp;= \boldsymbol{F}^{\top} \boldsymbol{F} \; , \\
\boldsymbol{S} &amp;= G \left( \boldsymbol{I} - \frac{1}{3} \mathrm{tr}(\boldsymbol{C})
                           \boldsymbol{C}^{-1} \right) J^{-\frac{2}{3}}
                + \frac{K}{4} \left( J^2 - J^{-2} \right) \boldsymbol{C}^{-1} \; , \\
\boldsymbol{P} &amp;= \boldsymbol{F} \, \boldsymbol{S} \; ,
\end{aligned}\]</p><p>with the deformation gradient <span>$\boldsymbol{F}$</span> and the second Piola-Kirchhoff stress <span>$\boldsymbol{S}$</span>.</p><div class="admonition is-info" id="Penalty-type-volumetric-formulation-b57a65b0ae125101"><header class="admonition-header">Penalty-type volumetric formulation<a class="admonition-anchor" href="#Penalty-type-volumetric-formulation-b57a65b0ae125101" title="Permalink"></a></header><div class="admonition-body"><p>This model uses a penalty-type volumetric term <span>$\Psi_{\mathrm{vol}} = \frac{K}{8}(J^2 + J^{-2} - 2)$</span>, which is computationally efficient and widely used in commercial finite element codes for nearly-incompressible materials. The term penalizes volume changes from the reference configuration (<span>$J = 1$</span>).</p><p>This differs from other volumetric formulations such as:</p><ul><li>Standard Neo-Hookean (logarithmic): <span>$\Psi_{\mathrm{vol}} = -\mu \ln J + \frac{\lambda}{2}\ln^2 J$</span></li><li>Simo-Miehe (polyconvex): <span>$\Psi_{\mathrm{vol}} = \frac{K}{4}(J^2 - 1 - 2\ln J)$</span></li></ul></div></div><p><strong>Error handling</strong></p><p>If the Jacobian <span>$J$</span> is smaller than the machine precision <code>eps()</code> or a <code>NaN</code>, the strain energy density and first Piola-Kirchhoff stress tensor are defined as zero: <span>$\Psi = 0$</span> and <span>$\boldsymbol{P} = \boldsymbol{0}$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kaipartmann/Peridynamics.jl/blob/d67dbd041ce7c52845c592e60db0e50e326f82c0/src/physics/constitutive_models.jl#L187-L230">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Peridynamics.SaintVenantKirchhoff"><a class="docstring-binding" href="#Peridynamics.SaintVenantKirchhoff"><code>Peridynamics.SaintVenantKirchhoff</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">SaintVenantKirchhoff</code></pre><p>Saint-Venant-Kirchhoff constitutive model that can be specified when using a <a href="#Peridynamics.CMaterial"><code>CMaterial</code></a> and <a href="#Peridynamics.BACMaterial"><code>BACMaterial</code></a>.</p><p>The strain energy density <span>$\Psi$</span> is given by</p><p class="math-container">\[\Psi = \frac{1}{2} \lambda \, \mathrm{tr}(\boldsymbol{E})^2 + \mu \, \mathrm{tr}(\boldsymbol{E} \cdot \boldsymbol{E}) \; ,\]</p><p>with the first and second Lamé parameters <span>$\lambda$</span> and <span>$\mu$</span>, and the Green-Lagrange strain tensor</p><p class="math-container">\[\boldsymbol{E} = \frac{1}{2} \left( \boldsymbol{F}^{\top} \boldsymbol{F} - \boldsymbol{I}
                              \right) \; .\]</p><p>The first Piola-Kirchhoff stress <span>$\boldsymbol{P}$</span> is given by</p><p class="math-container">\[\begin{aligned}
\boldsymbol{S} &amp;= \lambda \, \mathrm{tr}(\boldsymbol{E}) \, \boldsymbol{I}
                + 2 \mu \boldsymbol{E} \; , \\
\boldsymbol{P} &amp;= \boldsymbol{F} \, \boldsymbol{S} \; ,
\end{aligned}\]</p><p>with the deformation gradient <span>$\boldsymbol{F}$</span> and the second Piola-Kirchhoff stress <span>$\boldsymbol{S}$</span>.</p><div class="admonition is-info" id="Note-352ee9c18727252d"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-352ee9c18727252d" title="Permalink"></a></header><div class="admonition-body"><p>This model is equivalent to the <a href="#Peridynamics.LinearElastic"><code>LinearElastic</code></a> model, both using the same strain energy density function.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kaipartmann/Peridynamics.jl/blob/d67dbd041ce7c52845c592e60db0e50e326f82c0/src/physics/constitutive_models.jl#L1-L32">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Peridynamics.const_one_kernel"><a class="docstring-binding" href="#Peridynamics.const_one_kernel"><code>Peridynamics.const_one_kernel</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">const_one_kernel(δ, L)</code></pre><p>A kernel function <span>$\omega$</span> (also called influence function) used for weighting the bonds in a family. The kernel function is simply defined as a constant value 1:</p><p class="math-container">\[\omega = 1\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kaipartmann/Peridynamics.jl/blob/d67dbd041ce7c52845c592e60db0e50e326f82c0/src/discretization/kernels.jl#L1-L9">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Peridynamics.linear_kernel"><a class="docstring-binding" href="#Peridynamics.linear_kernel"><code>Peridynamics.linear_kernel</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">linear_kernel(δ, L)</code></pre><p>A linear kernel function <span>$\omega$</span> (also called influence function) used for weighting the bonds in a family. The kernel function is defined as</p><p class="math-container">\[\omega = \frac{\delta}{L} \; ,\]</p><p>with the horizon <span>$\delta$</span> and the initial bond length <span>$L$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kaipartmann/Peridynamics.jl/blob/d67dbd041ce7c52845c592e60db0e50e326f82c0/src/discretization/kernels.jl#L12-L21">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Peridynamics.cubic_b_spline_kernel"><a class="docstring-binding" href="#Peridynamics.cubic_b_spline_kernel"><code>Peridynamics.cubic_b_spline_kernel</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">cubic_b_spline_kernel(δ, L)</code></pre><p>A cubic B-spline kernel function <span>$\omega$</span> used for weighting the bonds in a family. The kernel function is defined as</p><p class="math-container">\[\begin{aligned}
\xi &amp;= \frac{L}{\delta} \; , \\
\omega &amp;= \left\{
    \begin{array}{ll}
        \frac{2}{3} - 4 \xi^2 + 4 \xi^3 &amp; \quad \text{if} \; 0 &lt; \xi \leq 0.5 \; , \\[3pt]
        \frac{4}{3} - 4 \xi + 4 \xi^2 - \frac{4}{3} \xi^3 &amp; \quad \text{if} \; 0.5 &lt; \xi \leq 1 \; , \\[3pt]
        0 &amp; \quad \text{else} \; ,
    \end{array}
    \right.
\end{aligned}\]</p><p>with the horizon <span>$\delta$</span> and the initial bond length <span>$L$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kaipartmann/Peridynamics.jl/blob/d67dbd041ce7c52845c592e60db0e50e326f82c0/src/discretization/kernels.jl#L24-L42">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Peridynamics.cubic_b_spline_kernel_norm"><a class="docstring-binding" href="#Peridynamics.cubic_b_spline_kernel_norm"><code>Peridynamics.cubic_b_spline_kernel_norm</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">cubic_b_spline_kernel_norm(δ, L)</code></pre><p>A cubic B-spline kernel function <span>$\omega$</span> used for weighting the bonds in a family. The kernel function is defined as</p><p class="math-container">\[\begin{aligned}
\xi &amp;= \frac{L}{\delta} \; , \\
\omega &amp;= \frac{8}{\pi \, \delta^3} \cdot \left\{
    \begin{array}{ll}
        1 - 6 \xi^2 + 6 \xi^3 &amp; \quad \text{if} \; 0 &lt; \xi \leq 0.5 \; , \\[3pt]
        2 (1 - \xi)^3 &amp; \quad \text{if} \; 0.5 &lt; \xi \leq 1 \; , \\[3pt]
        0 &amp; \quad \text{else} \; ,
    \end{array}
    \right.
\end{aligned}\]</p><p>with the horizon <span>$\delta$</span> and the initial bond length <span>$L$</span>. This kernel is properly normalized to satisfy the condition <span>$\int_{\mathcal{H}(X)} \omega(\Delta X) dV&#39; = 1$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kaipartmann/Peridynamics.jl/blob/d67dbd041ce7c52845c592e60db0e50e326f82c0/src/discretization/kernels.jl#L54-L73">source</a></section></details></article><h2 id="Discretization"><a class="docs-heading-anchor" href="#Discretization">Discretization</a><a id="Discretization-1"></a><a class="docs-heading-anchor-permalink" href="#Discretization" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="Peridynamics.Body"><a class="docstring-binding" href="#Peridynamics.Body"><code>Peridynamics.Body</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">Body(material, position, volume)
Body(material, inp_file)</code></pre><p>Construct a <code>Body</code> for a peridynamics simulation.</p><p><strong>Arguments</strong></p><ul><li><code>material::AbstractMaterial</code>: The material which is defined for the whole body.   Available material models:<ul><li><a href="#Peridynamics.BBMaterial"><code>BBMaterial</code></a>: Bond-based peridynamics.</li><li><a href="#Peridynamics.DHBBMaterial"><code>DHBBMaterial</code></a>: Dual-horizon bond-based peridynamics.</li><li><a href="#Peridynamics.GBBMaterial"><code>GBBMaterial</code></a>: Generalized bond-based peridynamics.</li><li><a href="#Peridynamics.OSBMaterial"><code>OSBMaterial</code></a>: Ordinary state-based peridynamics, also called linear   peridynamic solid (LPS).</li><li><a href="#Peridynamics.CMaterial"><code>CMaterial</code></a>: Correspondence formulation.</li><li><a href="#Peridynamics.CRMaterial"><code>CRMaterial</code></a>: Correspondence formulation with stress rotation for objectivity   enforcement.</li><li><a href="#Peridynamics.RKCMaterial"><code>RKCMaterial</code></a>: Reproducing kernel peridynamics with bond-associated   higher-order integration.</li><li><a href="#Peridynamics.RKCRMaterial"><code>RKCRMaterial</code></a>: Reproducing kernel peridynamics with bond-associated   higher-order integration with stress rotation for objectivity enforcement.</li><li><a href="#Peridynamics.BACMaterial"><code>BACMaterial</code></a>: Bond-associated correspondence formulation of Chen and Spencer.</li><li><a href="#Peridynamics.CKIMaterial"><code>CKIMaterial</code></a>: Continuum-kinematics-inspired peridynamics.</li></ul></li><li><code>position::AbstractMatrix</code>: A <code>3×n</code> matrix with the point position of the <code>n</code> points.</li><li><code>volume::AbstractVector</code>: A vector with the volume of each point.</li><li><code>inp_file::AbstractString</code>: An Abaqus input file containing meshes, imported with   <a href="#Peridynamics.AbaqusMeshConverter.read_inp"><code>read_inp</code></a>.</li></ul><p><strong>Throws</strong></p><ul><li>Error if the number of points is not larger than zero.</li><li>Error if <code>position</code> is not a <code>3×n</code> matrix and has the same length as <code>volume</code>.</li><li>Error if <code>position</code> or <code>volume</code> contain <code>NaN</code> values.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; Body(BBMaterial(), rand(3, 10), rand(10))
10-point Body{BBMaterial{NoCorrection}}:
  1 point set(s):
    10-point set `all_points`</code></pre><hr/><div class="admonition is-warning" id="Internal-use-only-be42c4aba2103582"><header class="admonition-header">Internal use only<a class="admonition-anchor" href="#Internal-use-only-be42c4aba2103582" title="Permalink"></a></header><div class="admonition-body"><p>Please note that the fields are intended for internal use only. They are <em>not</em> part of the public API of Peridynamics.jl, and thus can be altered (or removed) at any time without it being considered a breaking change.</p></div></div><pre><code class="language-julia hljs">Body{Material,PointParameters}</code></pre><p><strong>Type Parameters</strong></p><ul><li><code>Material &lt;: AbstractMaterial</code>: Type of the specified material model.</li><li><code>PointParameters &lt;: AbstractPointParameters</code>: Type of the point parameters.</li></ul><p><strong>Fields</strong></p><ul><li><code>mat::Material</code>: The material formulation.</li><li><code>n_points::Int</code>: The number of points that in the body.</li><li><code>position::Matrix{Float64}</code>: A <code>3×n_points</code> matrix with the position of the points.</li><li><code>volume::Vector{Float64}</code>: A vector with the volume of each point.</li><li><code>fail_permit::Vector{Bool}</code>: A vector that describes if failure is allowed for each point.</li><li><code>point_sets::Dict{Symbol,Vector{Int}}</code>: A dictionary containing point sets.</li><li><code>point_params::Vector{PointParameters}</code>: A vector containing all different point parameter   instances of the body. Each point can have its own <code>PointParameters</code> instance.</li><li><code>params_map::Vector{Int}</code>: A vector that maps each point index to a parameter instance in   <code>point_params</code>.</li><li><code>single_dim_bcs::Vector{SingleDimBC}</code>: A vector with boundary conditions on a single   dimension.</li><li><code>posdep_single_dim_bcs::Vector{PosDepSingleDimBC}</code>: A vector with position dependent   boundary conditions on a single dimension.</li><li><code>single_dim_ics::Vector{SingleDimIC}</code>: A vector with initial conditions on a single   dimension.</li><li><code>posdep_single_dim_ics::Vector{PosDepSingleDimIC}</code>: A vector with position dependent   initial conditions on a single dimension.</li><li><code>data_bcs::Vector{DataBC}</code>: A vector with data boundary conditions.</li><li><code>point_sets_precracks::Vector{PointSetsPreCrack}</code>: A vector with predefined point set   cracks.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kaipartmann/Peridynamics.jl/blob/d67dbd041ce7c52845c592e60db0e50e326f82c0/src/discretization/body.jl#L1-L82">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Peridynamics.MultibodySetup"><a class="docstring-binding" href="#Peridynamics.MultibodySetup"><code>Peridynamics.MultibodySetup</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">MultibodySetup(body_pairs...)</code></pre><p>Setup for a peridynamic simulation with multiple bodies.</p><p><strong>Arguments</strong></p><ul><li><code>body_pairs::Pair{Symbol,&lt;:AbstractBody}</code>: Pairs of <code>:body_name =&gt; body_object</code>.   The name of the body has to be specified as a Symbol.</li></ul><p><strong>Throws</strong></p><ul><li>Error if less than 2 bodies are defined.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; sphere = Body(BBMaterial(), pos_sphere, vol_sphere)
280-point Body{BBMaterial{NoCorrection}}:
  1 point set(s):
    280-point set `all_points`

julia&gt; plate = Body(BBMaterial(), pos_plate, vol_plate)
25600-point Body{BBMaterial{NoCorrection}}:
  1 point set(s):
    25600-point set `all_points`

julia&gt; ms = MultibodySetup(:sphere =&gt; sphere, :plate =&gt; plate)
25880-point MultibodySetup:
  280-point Body{BBMaterial{NoCorrection}} with name `sphere`
  25600-point Body{BBMaterial{NoCorrection}} with name `plate`</code></pre><hr/><div class="admonition is-warning" id="Internal-use-only-be42c4aba2103582"><header class="admonition-header">Internal use only<a class="admonition-anchor" href="#Internal-use-only-be42c4aba2103582" title="Permalink"></a></header><div class="admonition-body"><p>Please note that the fields are intended for internal use only. They are <em>not</em> part of the public API of Peridynamics.jl, and thus can be altered (or removed) at any time without it being considered a breaking change.</p></div></div><pre><code class="language-julia hljs">MultibodySetup{Bodies}</code></pre><p><strong>Type Parameters</strong></p><ul><li><code>Bodies &lt;: Tuple</code>: All types of the different bodies in the multibody setup.</li></ul><p><strong>Fields</strong></p><ul><li><code>bodies::Bodies</code>: A Tuple containing all the bodies.</li><li><code>body_names::Vector{Symbol}</code>: All body names.</li><li><code>body_idxs::Dict{Symbol,Int}</code>: A Dict to get the body index with the body name.</li><li><code>srf_contacts::Vector{ShortRangeForceContact}</code>: All short range force contacts.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kaipartmann/Peridynamics.jl/blob/d67dbd041ce7c52845c592e60db0e50e326f82c0/src/discretization/multibody_setup.jl#L1-L55">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Peridynamics.point_set!"><a class="docstring-binding" href="#Peridynamics.point_set!"><code>Peridynamics.point_set!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">point_set!(body, set_name, points)
point_set!(fun, body, set_name)</code></pre><p>Add a point set to a <a href="#Peridynamics.Body"><code>Body</code></a>. The points of the set can be either specified directly with the <code>points::AbstractVector</code> argument, or as the result of the filter function <code>fun</code>. By default, a body already contains a point set with the name <code>:all_points</code>, containg a set with all points.</p><p><strong>Arguments</strong></p><ul><li><code>body::AbstractBody</code>: <a href="#Peridynamics.Body"><code>Body</code></a> where the set will be added.</li><li><code>set_name::Symbol</code>: Name of the point set.</li><li><code>points::AbstractVector</code>: Some vector containing the point indices of the set.   The indices have to be in bounds with the <code>position</code> and <code>volume</code> of <code>body</code>.</li><li><code>fun::Function</code>: Function for filtering points. This function accepts only one positional   argument and will be used in a <code>findall</code> call. Depending on the argument name,   a different input will be processed:<ul><li><code>x</code>: The function will receive the x-coordinate of each point in <code>position</code> of <code>body</code>:<pre><code class="language-julia hljs">points = findall(fun, @view(position[1, :]))</code></pre></li><li><code>y</code>: The function will receive the y-coordinate of each point in <code>position</code> of <code>body</code>:<pre><code class="language-julia hljs">points = findall(fun, @view(position[2, :]))</code></pre></li><li><code>z</code>: The function will receive the z-coordinate of each point in <code>position</code> of <code>body</code>:<pre><code class="language-julia hljs">points = findall(fun, @view(position[3, :]))</code></pre></li><li><code>p</code>: The function will receive the a vector containing each dimension of each point in <code>position</code> of <code>body</code>:<pre><code class="language-julia hljs">points = findall(fun, eachcol(position))</code></pre></li></ul></li></ul><p><strong>Throws</strong></p><ul><li>Error if a point set with the same <code>set_name</code> already exists.</li><li>Error if <code>points</code> are not in bounds with <code>position</code> and <code>volume</code> of the <code>body</code>.</li></ul><p><strong>Examples</strong></p><p>Add a point set to <code>body</code> with all points that have a x-corrdinate larger than zero:</p><pre><code class="language-julia-repl hljs">julia&gt; point_set!(x -&gt; x &gt; 0, body, :larger_than_zero)

julia&gt; point_sets(body)
Dict{Symbol, Vector{Int64}} with 2 entries:
  :larger_than_zero =&gt; [6, 7, 8, 9, 10, 16, 17, 18, 19, 20  …  9…
  :all_points       =&gt; [1, 2, 3, 4, 5, 6, 7, 8, 9, 10  …  991, 9…</code></pre><p>Add a point set to <code>body</code> with all points that are positioned inside a sphere with radius <code>r</code> around the center. Note that the <code>do</code>-syntax can be used, as <code>fun</code> is the first argument of <code>point_set!</code>:</p><pre><code class="language-julia-repl hljs">julia&gt; point_set!(body, :inside_sphere) do p
           sqrt(p[1]^2 + p[2]^2 + p[3]^2) ≤ r
       end

julia&gt; point_sets(body)
Dict{Symbol, Vector{Int64}} with 2 entries:
  :larger_than_zero =&gt; [6, 7, 8, 9, 10, 16, 17, 18, 19, 20  …  9…
  :inside_sphere    =&gt; [1, 2, 3, 4, 5, 6, 7, 8, 9, 10  …  991, 9…</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kaipartmann/Peridynamics.jl/blob/d67dbd041ce7c52845c592e60db0e50e326f82c0/src/discretization/point_sets.jl#L4-L70">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Peridynamics.point_sets"><a class="docstring-binding" href="#Peridynamics.point_sets"><code>Peridynamics.point_sets</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">point_sets(body)</code></pre><p>Return all point sets of <code>body</code>.</p><p><strong>Arguments</strong></p><ul><li><code>body::AbstractBody</code>: <a href="#Peridynamics.Body"><code>Body</code></a>.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; body = Body(BBMaterial(), rand(3,100), rand(100))
100-point Body{BBMaterial{NoCorrection}}:
  100-point set `all_points`

julia&gt; point_set!(body, :set_a, 1:10) # first ten points

julia&gt; Peridynamics.point_sets(body)
Dict{Symbol, Vector{Int64}} with 2 entries:
  :all_points =&gt; [1, 2, 3, 4, 5, 6, 7, 8, 9, 10  …  91, 92, 93, 94, 95, 96, 97, 98, 9…
  :set_a      =&gt; [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kaipartmann/Peridynamics.jl/blob/d67dbd041ce7c52845c592e60db0e50e326f82c0/src/discretization/point_sets.jl#L144-L167">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Peridynamics.no_failure!"><a class="docstring-binding" href="#Peridynamics.no_failure!"><code>Peridynamics.no_failure!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">no_failure!(body::AbstractBody, set_name::Symbol)
no_failure!(body::AbstractBody)</code></pre><p>Disallow failure for all points of the point set <code>set_name</code> of the <code>body</code>. If no <code>set_name</code> is specified, failure is prohibited for the whole <code>body</code>.</p><p><strong>Arguments</strong></p><ul><li><code>body::AbstractBody</code>: <a href="#Peridynamics.Body"><code>Body</code></a> for which failure is prohibited.</li><li><code>set_name::Symbol</code>: The name of a point set of this body.</li></ul><div class="admonition is-danger" id="Overwriting-failure-permission-with-material!-and-no_failure!-9efd092839689772"><header class="admonition-header">Overwriting failure permission with `material!` and `no_failure!`<a class="admonition-anchor" href="#Overwriting-failure-permission-with-material!-and-no_failure!-9efd092839689772" title="Permalink"></a></header><div class="admonition-body"><p>The function <code>material!</code> sets failure permissions due to the provided input parameters, so if it is used afterwards, previously set failure prohibitions might be overwritten!</p></div></div><p><strong>Throws</strong></p><ul><li>Error if the body does not contain a set with <code>set_name</code>.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; no_failure!(body)

julia&gt; body
1000-point Body{BBMaterial{NoCorrection}}:
  1 point set(s):
    1000-point set `all_points`
  1000 points with failure prohibited</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kaipartmann/Peridynamics.jl/blob/d67dbd041ce7c52845c592e60db0e50e326f82c0/src/physics/fracture.jl#L44-L75">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Peridynamics.material!"><a class="docstring-binding" href="#Peridynamics.material!"><code>Peridynamics.material!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">material!(body, set_name; kwargs...)
material!(body; kwargs...)</code></pre><p>Assign material point parameters to points of <code>body</code>. If no <code>set_name</code> is specified, then the parameters will be set for all points of the body.</p><p><strong>Arguments</strong></p><ul><li><code>body::AbstractBody</code>: <a href="#Peridynamics.Body"><code>Body</code></a>.</li><li><code>set_name::Symbol</code>: The name of a point set of this body.</li></ul><p><strong>Keywords</strong></p><p>Allowed keywords depend on the selected material model. Please look at the documentation of the material you specified when creating the body. The default material keywords are:</p><p>Material parameters:</p><ul><li><code>horizon::Float64</code>: Radius of point interactions.</li><li><code>rho::Float64</code>: Density.</li></ul><p>Elastic parameters:</p><ul><li><code>E::Float64</code>: Young&#39;s modulus.</li><li><code>nu::Float64</code>: Poisson&#39;s ratio.</li><li><code>G::Float64</code>: Shear modulus.</li><li><code>K::Float64</code>: Bulk modulus.</li><li><code>lambda::Float64</code>: 1st Lamé parameter.</li><li><code>mu::Float64</code>: 2nd Lamé parameter.</li></ul><p>Fracture parameters:</p><ul><li><code>Gc::Float64</code>: Critical energy release rate.</li><li><code>epsilon_c::Float64</code>: Critical strain.</li></ul><div class="admonition is-info" id="Elastic-parameters-79ed0ebc426f33d0"><header class="admonition-header">Elastic parameters<a class="admonition-anchor" href="#Elastic-parameters-79ed0ebc426f33d0" title="Permalink"></a></header><div class="admonition-body"><p>Note that exactly two elastic parameters are required to specify a material.</p></div></div><div class="admonition is-info" id="Fracture-parameters-710eef4625cc9c56"><header class="admonition-header">Fracture parameters<a class="admonition-anchor" href="#Fracture-parameters-710eef4625cc9c56" title="Permalink"></a></header><div class="admonition-body"><p>To enable fracture in a simulation, define one of the allowed fracture parameters. If none are defined, fracture is disabled.</p></div></div><p><strong>Throws</strong></p><ul><li>Error if a kwarg is not eligible for specification with the body material.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; material!(body; horizon=3.0, E=2.1e5, rho=8e-6, Gc=2.7)

julia&gt; body
1000-point Body{BBMaterial{NoCorrection}}:
  1 point set(s):
    1000-point set `all_points`
  1 point parameter(s):
    Parameters BBMaterial: δ=3.0, E=210000.0, nu=0.25, rho=8.0e-6, Gc=2.7</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kaipartmann/Peridynamics.jl/blob/d67dbd041ce7c52845c592e60db0e50e326f82c0/src/physics/material_parameters.jl#L6-L61">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Peridynamics.velocity_bc!"><a class="docstring-binding" href="#Peridynamics.velocity_bc!"><code>Peridynamics.velocity_bc!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">velocity_bc!(fun, body, set_name, dim)</code></pre><p>Specify velocity boundary condition for points of the set <code>set_name</code> in <code>body</code>. The value of the boundary condition is calculated with the function <code>fun</code> at every time step.</p><p><strong>Arguments</strong></p><ul><li><code>fun::Function</code>: Condition function for the calculation of a value, should return a   <code>Float64</code>. If the condition function returns a <code>NaN</code>, then this value is ignored, which   can be used to turn conditions off after a specified period of time. This function   accepts one ore two positional arguments and is aware of the argument names.   Possible arguments and names:<ul><li><code>fun(t)</code>: The function will receive the current time <code>t</code> at every time step.   This makes it possible to specify conditions that change over time.</li><li><code>fun(p, t)</code>: This function will be processed for every point of <code>set_name</code> and   receives the reference position of a point as <code>SVector{3}</code> and the current time <code>t</code>   at every time step. This makes it possible to specify conditions that   also depend on the position of a point.</li></ul></li><li><code>body::AbstractBody</code>: <a href="#Peridynamics.Body"><code>Body</code></a> the condition is specified on.</li><li><code>set_name::Symbol</code>: The name of a point set of this body.</li><li><code>dim::Union{Integer,Symbol}</code>: Direction of the condition, either specified as Symbol or   integer.<ul><li>x-direction: <code>:x</code> or <code>1</code></li><li>y-direction: <code>:y</code> or <code>2</code></li><li>z-direction: <code>:z</code> or <code>3</code></li></ul></li></ul><p><strong>Throws</strong></p><ul><li>Error if the body does not contain a set with <code>set_name</code>.</li><li>Error if the direction is not correctly specified.</li><li>Error if function is not suitable as condition function and has the wrong arguments.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; velocity_bc!(t -&gt; 2.0, body, :all_points, 1)

julia&gt; velocity_bc!((p,t) -&gt; p[1] * t, body, :all_points, :y)

julia&gt; velocity_bc!(t -&gt; t &gt; 0.00001 ? 1.0 : NaN, body, :all_points, :z)

julia&gt; body
1000-point Body{BBMaterial{NoCorrection}}:
  1 point set(s):
    1000-point set `all_points`
  3 boundary condition(s):
    BC on velocity: point_set=all_points, dim=1
    BC on velocity: point_set=all_points, dim=3
    Pos.-dep. BC on velocity: point_set=all_points, dim=2</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kaipartmann/Peridynamics.jl/blob/d67dbd041ce7c52845c592e60db0e50e326f82c0/src/physics/boundary_conditions.jl#L369-L421">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Peridynamics.velocity_ic!"><a class="docstring-binding" href="#Peridynamics.velocity_ic!"><code>Peridynamics.velocity_ic!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">velocity_ic!(body, set_name, dim, value)
velocity_ic!(fun, body, set_name, dim)</code></pre><p>Specify velocity initial condition for points of the set <code>set_name</code> in <code>body</code>. The <code>value</code> of the initial condition is specified before time integration. If a function <code>fun</code> is specified, then the value is with that function.</p><p><strong>Arguments</strong></p><ul><li><code>body::AbstractBody</code>: <a href="#Peridynamics.Body"><code>Body</code></a> the condition is specified on.</li><li><code>set_name::Symbol</code>: The name of a point set of this body.</li><li><code>dim::Union{Integer,Symbol}</code>: Direction of the condition, either specified as Symbol or   integer.<ul><li>x-direction: <code>:x</code> or <code>1</code></li><li>y-direction: <code>:y</code> or <code>2</code></li><li>z-direction: <code>:z</code> or <code>3</code></li></ul></li><li><code>value::Real</code>: Value that is specified before time integration.</li><li><code>fun::Function</code>: Condition function for the calculation of a value, should return a   <code>Float64</code>. If the condition function returns a <code>NaN</code>, then this value is ignored, which   can be used to turn off the condition for a specified position. This function   accepts one ore two positional arguments and is aware of the argument names.   Possible arguments and names:<ul><li><code>fun(p)</code>: The function will receive the reference position <code>p</code> of a point as   <code>SVector{3}</code>.</li></ul></li></ul><p><strong>Throws</strong></p><ul><li>Error if the body does not contain a set with <code>set_name</code>.</li><li>Error if the direction is not correctly specified.</li><li>Error if function is not suitable as condition function and has the wrong arguments.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; velocity_ic!(body, :all_points, :x, -100.0)

julia&gt; body
1000-point Body{BBMaterial{NoCorrection}}:
  1 point set(s):
    1000-point set `all_points`
  1 initial condition(s):
    IC on velocity: point_set=all_points, dim=1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kaipartmann/Peridynamics.jl/blob/d67dbd041ce7c52845c592e60db0e50e326f82c0/src/physics/initial_conditions.jl#L133-L177">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Peridynamics.forcedensity_bc!"><a class="docstring-binding" href="#Peridynamics.forcedensity_bc!"><code>Peridynamics.forcedensity_bc!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">forcedensity_bc!(fun, body, set, dim)</code></pre><p>Specify force density boundary condition for points of the set <code>set_name</code> in <code>body</code>. The value of the boundary condition is calculated with the function <code>fun</code> at every time step.</p><p><strong>Arguments</strong></p><ul><li><code>fun::Function</code>: Condition function for the calculation of a value, should return a   <code>Float64</code>. If the condition function returns a <code>NaN</code>, then this value is ignored, which   can be used to turn conditions off after a specified period of time. This function   accepts one ore two positional arguments and is aware of the argument names.   Possible arguments and names:<ul><li><code>fun(t)</code>: The function will receive the current time <code>t</code> at every time step.   This makes it possible to specify conditions that change over time.</li><li><code>fun(p, t)</code>: This function will be processed for every point of <code>set_name</code> and   receives the reference position of a point as <code>SVector{3}</code> and the current time <code>t</code>   at every time step. This makes it possible to specify conditions that   also depend on the position of a point.</li></ul></li><li><code>body::AbstractBody</code>: <a href="#Peridynamics.Body"><code>Body</code></a> the condition is specified on.</li><li><code>set_name::Symbol</code>: The name of a point set of this body.</li><li><code>dim::Union{Integer,Symbol}</code>: Direction of the condition, either specified as Symbol or   integer.<ul><li>x-direction: <code>:x</code> or <code>1</code></li><li>y-direction: <code>:y</code> or <code>2</code></li><li>z-direction: <code>:z</code> or <code>3</code></li></ul></li></ul><p><strong>Throws</strong></p><ul><li>Error if the body does not contain a set with <code>set_name</code>.</li><li>Error if the direction is not correctly specified.</li><li>Error if function is not suitable as condition function and has the wrong arguments.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; forcedensity_bc!(t -&gt; 8000.0, body, :all_points, :x)

julia&gt; forcedensity_bc!((p,t) -&gt; p[1] * t, body, :all_points, :y)

julia&gt; forcedensity_bc!(t -&gt; t &gt; 0.00001 ? 8000.0 : NaN, body, :all_points, :z)

julia&gt; body
1000-point Body{BBMaterial{NoCorrection}}:
  1 point set(s):
    1000-point set `all_points`
  3 boundary condition(s):
    BC on force density: point_set=all_points, dim=1
    BC on force density: point_set=all_points, dim=3
    Pos.-dep. BC on force density: point_set=all_points, dim=2</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kaipartmann/Peridynamics.jl/blob/d67dbd041ce7c52845c592e60db0e50e326f82c0/src/physics/boundary_conditions.jl#L506-L558">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Peridynamics.precrack!"><a class="docstring-binding" href="#Peridynamics.precrack!"><code>Peridynamics.precrack!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">precrack!(body, set_a, set_b; update_dmg=true)</code></pre><p>Create a crack between two point sets by prohibiting interaction between points of different point sets. The points in <code>set_a</code> are not allowed to interact with points in <code>set_b</code>.</p><p><strong>Arguments</strong></p><ul><li><code>body::AbstractBody</code>: <a href="#Peridynamics.Body"><code>Body</code></a>.</li><li><code>set_a::Symbol</code>: The name of a point set of this body.</li><li><code>set_b::Symbol</code>: The name of a point set of this body.</li></ul><p><strong>Keywords</strong></p><ul><li><code>update_dmg::Bool</code>: If <code>true</code>, the material points involved in the predefined crack are   initially damaged. If <code>false</code>, the bonds involved are deleted and the material points   involved with the predefined crack are not damaged in the reference results.   (default: <code>true</code>)</li></ul><p><strong>Throws</strong></p><ul><li>Error if the body does not contain sets with name <code>set_a</code> and <code>set_b</code>.</li><li>Error if the point sets intersect and a point is included in both sets.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; point_set!(body, :a, 1:2)

julia&gt; point_set!(body, :b, 3:4)

julia&gt; precrack!(body, :a, :b)

julia&gt; body
1000-point Body{BBMaterial{NoCorrection}}:
  3 point set(s):
    1000-point set `all_points`
    2-point set `a`
    2-point set `b`
  1 predefined crack(s)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kaipartmann/Peridynamics.jl/blob/d67dbd041ce7c52845c592e60db0e50e326f82c0/src/discretization/predefined_cracks.jl#L63-L105">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Peridynamics.contact!"><a class="docstring-binding" href="#Peridynamics.contact!"><code>Peridynamics.contact!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">contact!(multibody_setup, name_body_a, name_body_b; kwargs...)</code></pre><p>Define a short range force contact between body <code>name_body_a</code> and <code>name_body_b</code> in the <a href="#Peridynamics.MultibodySetup"><code>MultibodySetup</code></a> <code>multibody_setup</code>.</p><p><strong>Arguments</strong></p><ul><li><code>multibody_setup::MultibodySetup</code>: <a href="#Peridynamics.MultibodySetup"><code>MultibodySetup</code></a>.</li><li><code>name_body_a::Symbol</code>: The name of a body in this multibody setup.</li><li><code>name_body_b::Symbol</code>: The name of a body in this multibody setup.</li></ul><p><strong>Keywords</strong></p><ul><li><code>radius::Float64</code>: Contact search radius. If a the distance of a point in body   <code>name_body_a</code> and a point in body <code>name_body_b</code> is lower than this radius, a contact   force is calculated. This radius should be in the order of the point spacing of a   point cloud.</li><li><code>penalty_factor::Float64</code>: Penalty factor for the short range force contact algorithm.   (default: <code>1e12</code>)</li></ul><p><strong>Throws</strong></p><ul><li>Error if <code>multibody_setup</code> does not contain bodies with name <code>name_body_a</code> and   <code>name_body_b</code>.</li><li>Error if the keyword <code>radius</code> is not specified or <code>radius ≤ 0</code>.</li><li>Error if <code>penalty_factor ≤ 0</code>.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; ms = MultibodySetup(:a =&gt; body_a, :b =&gt; body_b)
2000-point MultibodySetup:
  1000-point Body{BBMaterial{NoCorrection}} with name `b`
  1000-point Body{BBMaterial{NoCorrection}} with name `b`

julia&gt; contact!(ms, :a, :b; radius=0.001)

julia&gt; ms
2000-point MultibodySetup:
  1000-point Body{BBMaterial{NoCorrection}} with name `b`
  1000-point Body{BBMaterial{NoCorrection}} with name `b`
  2 short range force contact(s)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kaipartmann/Peridynamics.jl/blob/d67dbd041ce7c52845c592e60db0e50e326f82c0/src/physics/short_range_force_contact.jl#L52-L94">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Peridynamics.uniform_box"><a class="docstring-binding" href="#Peridynamics.uniform_box"><code>Peridynamics.uniform_box</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">uniform_box(lx, ly, lz, ΔX0; kwargs...)</code></pre><p>Create a grid of uniformly distributed points in a cuboid with lengths <code>lx</code>, <code>ly</code> and <code>lz</code> and point spacing <code>ΔX0</code>.</p><p><strong>Arguments</strong></p><ul><li><code>lx::Real</code>: Length in x-dimension.</li><li><code>ly::Real</code>: Length in y-dimension.</li><li><code>lz::Real</code>: Length in z-dimension.</li><li><code>ΔX0::Real</code>: Spacing of the points.</li></ul><p><strong>Keywords</strong></p><ul><li><code>center</code>: The coordinates of the center of the cuboid. Default: <code>(0, 0, 0)</code></li></ul><p><strong>Returns</strong></p><ul><li><code>position::Matrix{Float64}</code>: A <code>3×n_points</code> matrix with the position of the points.</li><li><code>volume::Vector{Float64}</code>: A vector with the volume of each point.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; position, volume = uniform_box(10, 10, 10, 2);

julia&gt; position
3×125 Matrix{Float64}:
 -4.0  -2.0   0.0   2.0   4.0  -4.0  -2.0  …  0.0  2.0  4.0  -4.0  -2.0  0.0  2.0  4.0
 -4.0  -4.0  -4.0  -4.0  -4.0  -2.0  -2.0     2.0  2.0  2.0   4.0   4.0  4.0  4.0  4.0
 -4.0  -4.0  -4.0  -4.0  -4.0  -4.0  -4.0     4.0  4.0  4.0   4.0   4.0  4.0  4.0  4.0

julia&gt; volume
125-element Vector{Int64}:
 8
 8
 8
 8
 ⋮
 8
 8
 8
 8</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kaipartmann/Peridynamics.jl/blob/d67dbd041ce7c52845c592e60db0e50e326f82c0/src/discretization/point_generators.jl#L1-L43">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Peridynamics.uniform_sphere"><a class="docstring-binding" href="#Peridynamics.uniform_sphere"><code>Peridynamics.uniform_sphere</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">uniform_sphere(diameter, ΔX0; kwargs...)</code></pre><p>Create a grid of uniformly distributed points in a sphere with a specific <code>diameter</code> and the point spacing <code>ΔX0</code>. Due to the uniform point spacings, edges on the surface of the sphere can occur.</p><p><strong>Arguments</strong></p><ul><li><code>diameter::Real</code>: Diameter of the sphere.</li><li><code>ΔX0::Real</code>: Spacing of the points.</li></ul><p><strong>Keywords</strong></p><ul><li><code>center</code>: The coordinates of the center of the sphere. Default: <code>(0, 0, 0)</code></li></ul><p><strong>Returns</strong></p><ul><li><code>position::Matrix{Float64}</code>: A <code>3×n_points</code> matrix with the position of the points.</li><li><code>volume::Vector{Float64}</code>: A vector with the volume of each point.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; position, volume = uniform_sphere(10, 2);

julia&gt; position
3×81 Matrix{Float64}:
 -2.0   0.0   2.0  -2.0   0.0   2.0  -2.0  …   0.0   2.0  -2.0  0.0  2.0  -2.0  0.0  2.0
 -2.0  -2.0  -2.0   0.0   0.0   0.0   2.0     -2.0  -2.0   0.0  0.0  0.0   2.0  2.0  2.0
 -4.0  -4.0  -4.0  -4.0  -4.0  -4.0  -4.0      4.0   4.0   4.0  4.0  4.0   4.0  4.0  4.0

julia&gt; volume
81-element Vector{Int64}:
 8
 8
 8
 8
 8
 ⋮
 8
 8
 8
 8
 8</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kaipartmann/Peridynamics.jl/blob/d67dbd041ce7c52845c592e60db0e50e326f82c0/src/discretization/point_generators.jl#L61-L104">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Peridynamics.uniform_cylinder"><a class="docstring-binding" href="#Peridynamics.uniform_cylinder"><code>Peridynamics.uniform_cylinder</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">uniform_cylinder(diameter::Real, height::Real, ΔX0::Real; kwargs...)</code></pre><p>Create a grid of uniformly distributed points in a cylindrical shape with a specific <code>height</code> in z-dimension, a <code>diameter</code> and the point spacing <code>ΔX0</code>. Due to the uniform point spacings, edges on the surface of the cylinder can occur.</p><p><strong>Arguments</strong></p><ul><li><code>diameter::Real</code>: Diameter of the cylinder.</li><li><code>height::Real</code>: Height of the cylinder.</li><li><code>ΔX0::Real</code>: Spacing of the points.</li></ul><p><strong>Keywords</strong></p><ul><li><code>center</code>: The coordinates of the center of the cylinder. Default: <code>(0, 0, 0)</code></li></ul><p><strong>Returns</strong></p><ul><li><code>position::Matrix{Float64}</code>: A <code>3×n_points</code> matrix with the position of the points.</li><li><code>volume::Vector{Float64}</code>: A vector with the volume of each point.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; position, volume = uniform_cylinder(5, 10, 2);

julia&gt; position
3×20 Matrix{Float64}:
 -1.0   1.0  -1.0   1.0  -1.0   1.0  -1.0  …   1.0  -1.0  1.0  -1.0   1.0  -1.0  1.0
 -1.0  -1.0   1.0   1.0  -1.0  -1.0   1.0     -1.0   1.0  1.0  -1.0  -1.0   1.0  1.0
 -4.0  -4.0  -4.0  -4.0  -2.0  -2.0  -2.0      2.0   2.0  2.0   4.0   4.0   4.0  4.0

julia&gt; volume
20-element Vector{Int64}:
 8
 8
 8
 8
 8
 ⋮
 8
 8
 8
 8
 8</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kaipartmann/Peridynamics.jl/blob/d67dbd041ce7c52845c592e60db0e50e326f82c0/src/discretization/point_generators.jl#L121-L165">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Peridynamics.round_sphere"><a class="docstring-binding" href="#Peridynamics.round_sphere"><code>Peridynamics.round_sphere</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">round_sphere(diameter, ΔX0; kwargs...)</code></pre><p>Create a grid of points distributed in a smooth sphere without edges on the surface with a specific <code>diameter</code> and the point spacing <code>ΔX0</code>. Internally, some parts of <code>TrixiParticles.jl</code> were copied and adapted for this function.</p><p><strong>Arguments</strong></p><ul><li><code>diameter::Real</code>: Diameter of the sphere.</li><li><code>ΔX0::Real</code>: Spacing of the points.</li></ul><p><strong>Keywords</strong></p><ul><li><code>center</code>: The coordinates of the center of the sphere. Default: <code>(0, 0, 0)</code></li></ul><p><strong>Returns</strong></p><ul><li><code>position::Matrix{Float64}</code>: A <code>3×n_points</code> matrix with the position of the points.</li><li><code>volume::Vector{Float64}</code>: A vector with the volume of each point.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; position, volume = round_sphere(10, 2);

julia&gt; position
3×63 Matrix{Float64}:
 0.0  1.74586  0.539501  -1.41243  -1.41243  …  -1.95518   -0.48289   1.35303   0.0
 0.0  0.0      1.66041    1.02619  -1.02619     -0.941566  -2.11568  -1.69664   0.0
 2.0  0.97569  0.97569    0.97569   0.97569     -3.36017   -3.36017  -3.36017  -4.0

julia&gt; volume
63-element Vector{Float64}:
 8.311091676163475
 8.311091676163475
 8.311091676163475
 8.311091676163475
 8.311091676163475
 ⋮
 8.311091676163475
 8.311091676163475
 8.311091676163475
 8.311091676163475</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kaipartmann/Peridynamics.jl/blob/d67dbd041ce7c52845c592e60db0e50e326f82c0/src/discretization/point_generators.jl#L187-L229">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Peridynamics.round_cylinder"><a class="docstring-binding" href="#Peridynamics.round_cylinder"><code>Peridynamics.round_cylinder</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">round_cylinder(diameter::Real, height::Real, ΔX0::Real; kwargs...)</code></pre><p>Create a grid of  points distributed in a cylindrical shape with a specific <code>height</code> in z-dimension, a <code>diameter</code> and the point spacing <code>ΔX0</code>. Due to a concentric point distribution in the x-y-plane, there are no sharp edges that appear on the surface of the cylinder.</p><p><strong>Arguments</strong></p><ul><li><code>diameter::Real</code>: Diameter of the cylinder.</li><li><code>height::Real</code>: Height of the cylinder.</li><li><code>ΔX0::Real</code>: Spacing of the points.</li></ul><p><strong>Keywords</strong></p><ul><li><code>center</code>: The coordinates of the center of the cylinder. Default: <code>(0, 0, 0)</code></li></ul><p><strong>Returns</strong></p><ul><li><code>position::Matrix{Float64}</code>: A <code>3×n_points</code> matrix with the position of the points.</li><li><code>volume::Vector{Float64}</code>: A vector with the volume of each point.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; position, volume = round_cylinder(5, 10, 2);

julia&gt; position
3×30 Matrix{Float64}:
  1.5   0.463525  -1.21353   -1.21353   …  -1.21353   -1.21353    0.463525
  0.0   1.42658    0.881678  -0.881678      0.881678  -0.881678  -1.42658
 -5.0  -5.0       -5.0       -5.0           5.0        5.0        5.0

julia&gt; volume
30-element Vector{Int64}:
 13.089969389957473
 13.089969389957473
 13.089969389957473
 13.089969389957473
 13.089969389957473
  ⋮
 13.089969389957473
 13.089969389957473
 13.089969389957473
 13.089969389957473</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kaipartmann/Peridynamics.jl/blob/d67dbd041ce7c52845c592e60db0e50e326f82c0/src/discretization/point_generators.jl#L241-L285">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Peridynamics.n_points"><a class="docstring-binding" href="#Peridynamics.n_points"><code>Peridynamics.n_points</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">n_points(body)</code></pre><p>Return the total number of points in a body.</p><p><strong>Arguments</strong></p><ul><li><code>body::Body</code>: <a href="#Peridynamics.Body"><code>Body</code></a>.</li></ul><p><strong>Returns</strong></p><ul><li><code>n_points::Int</code>: The number of points in the body.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; body = Body(BBMaterial(), pos, vol)
1000-point Body{BBMaterial{NoCorrection}}:
  1 point set(s):
    1000-point set `all_points`

julia&gt; n_points(body)
1000</code></pre><hr/><pre><code class="language-julia hljs">n_points(multibody_setup)</code></pre><p>Return the total number of points in a multibody setup.</p><p><strong>Arguments</strong></p><ul><li><code>multibody_setup::MultibodySetup</code>: <a href="#Peridynamics.MultibodySetup"><code>MultibodySetup</code></a>.</li></ul><p><strong>Returns</strong></p><ul><li><code>n_points::Int</code>: The sum of all points from all bodies in the multibody setup.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; ms = MultibodySetup(:a =&gt; body_a, :b =&gt; body_b)
2000-point MultibodySetup:
  1000-point Body{BBMaterial{NoCorrection}} with name `a`
  1000-point Body{BBMaterial{NoCorrection}} with name `b`

julia&gt; n_points(ms)
2000</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kaipartmann/Peridynamics.jl/blob/d67dbd041ce7c52845c592e60db0e50e326f82c0/src/discretization/body.jl#L405-L450">source</a></section></details></article><h2 id="Preprocessing-and-simulation-setup"><a class="docs-heading-anchor" href="#Preprocessing-and-simulation-setup">Preprocessing &amp; simulation setup</a><a id="Preprocessing-and-simulation-setup-1"></a><a class="docs-heading-anchor-permalink" href="#Preprocessing-and-simulation-setup" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="Peridynamics.AbaqusMeshConverter.read_inp"><a class="docstring-binding" href="#Peridynamics.AbaqusMeshConverter.read_inp"><code>Peridynamics.AbaqusMeshConverter.read_inp</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">read_inp(file::String)</code></pre><p>Read Abaqus .inp-file and convert meshes to a point cloud with the help of the <a href="https://github.com/JuliaFEM/AbaqusReader.jl"><code>AbaqusReader.jl</code></a> package. Every element is converted to a point. The center of the element becomes the position of the point and the element volume becomes the point volume. Element sets defined in Abaqus are converted to corresponding point sets.</p><p>Currently supported mesh elements: [:Tet4, :Hex8]</p><p><strong>Arguments</strong></p><ul><li><code>file::String</code>: Path to Abaqus .inp-file.</li></ul><p><strong>Returns</strong></p><ul><li><code>position::Matrix{Float64}</code>: Point position (midpoint of every element).</li><li><code>volume::Vector{Float64}</code>: Point volume (volume of every element).</li><li><code>point_sets</code>: Element sets defined in the .inp-file.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kaipartmann/Peridynamics.jl/blob/d67dbd041ce7c52845c592e60db0e50e326f82c0/src/AbaqusMeshConverter/AbaqusMeshConverter.jl#L63-L81">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Peridynamics.mpi_isroot"><a class="docstring-binding" href="#Peridynamics.mpi_isroot"><code>Peridynamics.mpi_isroot</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">mpi_isroot()</code></pre><p>Helper function that returns a bool indicating if a process is the MPI root process. It can be safely used even for multithreading simulations, as it is always <code>true</code> if the package is started in a normal Julia environment which is not started by MPI.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kaipartmann/Peridynamics.jl/blob/d67dbd041ce7c52845c592e60db0e50e326f82c0/src/auxiliary/mpi.jl#L14-L20">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Peridynamics.mpi_barrier"><a class="docstring-binding" href="#Peridynamics.mpi_barrier"><code>Peridynamics.mpi_barrier</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">mpi_barrier()</code></pre><p>Synchronize all MPI ranks at a barrier point. This is a no-op when not running with MPI. Use this to ensure all ranks reach the same point before continuing execution.</p><p>When running with MPI, this function causes all ranks to wait until every rank has called it, providing a synchronization point in the program. This is useful when you need to ensure that all ranks have completed a certain phase before proceeding to the next.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs"># Wait here before all ranks continue
mpi_barrier()</code></pre><p>See also: <a href="#Peridynamics.mpi_isroot"><code>mpi_isroot</code></a>, <a href="#Peridynamics.@mpiroot"><code>@mpiroot</code></a>, <a href="#Peridynamics.process_each_export"><code>process_each_export</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kaipartmann/Peridynamics.jl/blob/d67dbd041ce7c52845c592e60db0e50e326f82c0/src/auxiliary/mpi.jl#L23-L40">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Peridynamics.force_mpi_run!"><a class="docstring-binding" href="#Peridynamics.force_mpi_run!"><code>Peridynamics.force_mpi_run!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">force_mpi_run!()</code></pre><p>Helper function to force the usage of the MPI backend. After this function is called, all following simulations will use MPI.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kaipartmann/Peridynamics.jl/blob/d67dbd041ce7c52845c592e60db0e50e326f82c0/src/auxiliary/mpi.jl#L49-L54">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Peridynamics.force_threads_run!"><a class="docstring-binding" href="#Peridynamics.force_threads_run!"><code>Peridynamics.force_threads_run!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">force_threads_run!()</code></pre><p>Helper function to force the usage of the multithreading backend. After this function is called, all following simulations will use multithreading.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kaipartmann/Peridynamics.jl/blob/d67dbd041ce7c52845c592e60db0e50e326f82c0/src/auxiliary/mpi.jl#L61-L66">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Peridynamics.enable_mpi_timers!"><a class="docstring-binding" href="#Peridynamics.enable_mpi_timers!"><code>Peridynamics.enable_mpi_timers!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">enable_mpi_timers!()</code></pre><p>Helper function to enable timers defined with the <code>TimerOutputs</code> for simulations with the MPI backend. The results of the timers then will be exported into the specified path of a <a href="#Peridynamics.Job"><code>Job</code></a>. By default, not timers will be used with MPI simulations. It can be safely used with multithreading.</p><p>See also <a href="#Peridynamics.disable_mpi_timers!"><code>disable_mpi_timers!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kaipartmann/Peridynamics.jl/blob/d67dbd041ce7c52845c592e60db0e50e326f82c0/src/auxiliary/mpi.jl#L113-L122">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Peridynamics.disable_mpi_timers!"><a class="docstring-binding" href="#Peridynamics.disable_mpi_timers!"><code>Peridynamics.disable_mpi_timers!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">disable_mpi_timers!()</code></pre><p>Helper function to disable timers defined with the <code>TimerOutputs</code> for simulations with the MPI backend. It is mainly used to reset the behaviour after a call of <a href="#Peridynamics.enable_mpi_timers!"><code>enable_mpi_timers!</code></a>. It can be safely used with multithreading.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kaipartmann/Peridynamics.jl/blob/d67dbd041ce7c52845c592e60db0e50e326f82c0/src/auxiliary/mpi.jl#L128-L134">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Peridynamics.enable_mpi_progress_bars!"><a class="docstring-binding" href="#Peridynamics.enable_mpi_progress_bars!"><code>Peridynamics.enable_mpi_progress_bars!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">enable_mpi_progress_bars!()</code></pre><p>Helper function to enable progress bars with MPI simulations on a personal computer. After this function is called, progress bars are beeing shown with MPI simulations like with multithreading simulations. This behavior can be reset to default with <a href="#Peridynamics.reset_mpi_progress_bars!"><code>reset_mpi_progress_bars!</code></a>.</p><div class="admonition is-warning" id="Progress-bars-and-output-files-a63140288ac6080b"><header class="admonition-header">Progress bars and output files<a class="admonition-anchor" href="#Progress-bars-and-output-files-a63140288ac6080b" title="Permalink"></a></header><div class="admonition-body"><p>Progress bars are by default disabled with MPI simulations, because they can really mess up with the output files produced by a HPC system. Therefore, a warning is shown as a reminder to reset this behaviour before submitting a job to a cluster!</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kaipartmann/Peridynamics.jl/blob/d67dbd041ce7c52845c592e60db0e50e326f82c0/src/auxiliary/mpi.jl#L140-L153">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Peridynamics.reset_mpi_progress_bars!"><a class="docstring-binding" href="#Peridynamics.reset_mpi_progress_bars!"><code>Peridynamics.reset_mpi_progress_bars!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">reset_mpi_progress_bars!()</code></pre><p>After this function is called, progress bars are again disabled on MPI simulations (standard setting). This will reset the behavior after a call of <a href="#Peridynamics.enable_mpi_progress_bars!"><code>enable_mpi_progress_bars!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kaipartmann/Peridynamics.jl/blob/d67dbd041ce7c52845c592e60db0e50e326f82c0/src/auxiliary/mpi.jl#L160-L166">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Peridynamics.@mpitime"><a class="docstring-binding" href="#Peridynamics.@mpitime"><code>Peridynamics.@mpitime</code></a> — <span class="docstring-category">Macro</span></summary><section><div><pre><code class="language-julia hljs">@mpitime expression</code></pre><p>Time the <code>expression</code> if the mpi rank is zero. Lowers to:</p><pre><code class="language-julia hljs">if mpi_isroot()
    @time expression
else
    expression
end</code></pre><p>See also: <a href="#Peridynamics.mpi_isroot"><code>mpi_isroot</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kaipartmann/Peridynamics.jl/blob/d67dbd041ce7c52845c592e60db0e50e326f82c0/src/auxiliary/mpi.jl#L173-L186">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Peridynamics.@mpiroot"><a class="docstring-binding" href="#Peridynamics.@mpiroot"><code>Peridynamics.@mpiroot</code></a> — <span class="docstring-category">Macro</span></summary><section><div><pre><code class="language-julia hljs">@mpiroot [option] expression</code></pre><p>Run the code if the mpi rank is zero. Lowers to something similar as:</p><pre><code class="language-julia hljs">if mpi_isroot()
    expression
end</code></pre><p><strong>Options</strong></p><ul><li><code>:wait</code>: All MPI ranks will wait until the root rank finishes evaluating <code>expression</code>.</li></ul><p>See also: <a href="#Peridynamics.mpi_isroot"><code>mpi_isroot</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kaipartmann/Peridynamics.jl/blob/d67dbd041ce7c52845c592e60db0e50e326f82c0/src/auxiliary/mpi.jl#L197-L211">source</a></section></details></article><h2 id="Solving"><a class="docs-heading-anchor" href="#Solving">Solving</a><a id="Solving-1"></a><a class="docs-heading-anchor-permalink" href="#Solving" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="Peridynamics.VelocityVerlet"><a class="docstring-binding" href="#Peridynamics.VelocityVerlet"><code>Peridynamics.VelocityVerlet</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">VelocityVerlet(; kwargs...)</code></pre><p>Time integration solver for the Velocity Verlet algorithm. Specify either the number of steps or the time the simulation should cover.</p><p><strong>Keywords</strong></p><ul><li><code>time::Real</code>: The total time the simulation will cover. If this keyword is specified, the   keyword <code>steps</code> is no longer allowed. (optional)</li><li><code>steps::Int</code>: Number of calculated time steps. If this keyword is specified, the keyword   <code>time</code> is no longer allowed. (optional)</li><li><code>stepsize::Real</code>: Manually specify the size of the time step. (optional)</li><li><code>safety_factor::Real</code>: Safety factor for step size to ensure stability. (default: <code>0.7</code>)</li></ul><div class="admonition is-warning" id="Specification-of-the-time-step-9f7fead5884b1cd2"><header class="admonition-header">Specification of the time step<a class="admonition-anchor" href="#Specification-of-the-time-step-9f7fead5884b1cd2" title="Permalink"></a></header><div class="admonition-body"><p>Keep in mind that manually specifying the critical time step is dangerous! If the specified time step is too high and the CFL condition no longer holds, the simulation will give wrong results and maybe crash!</p></div></div><p><strong>Throws</strong></p><ul><li>Error if both <code>time</code> and <code>steps</code> are specified as keywords.</li><li>Error if neither <code>time</code> nor <code>steps</code> are specified as keywords.</li><li>Error if <code>safety_factor &lt; 0</code> or <code>safety_factor &gt; 1</code>.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; VelocityVerlet(steps=2000)
VelocityVerlet:
  n_steps        2000
  safety_factor  0.7

julia&gt; VelocityVerlet(time=0.001)
VelocityVerlet:
  end_time       0.001
  safety_factor  0.7

julia&gt; VelocityVerlet(steps=2000, stepsize=0.0001)
┌ Warning: stepsize specified! Please be sure that the CFD-condition holds!
└ @ Peridynamics ~/Code/Peridynamics.jl/src/time_solvers/velocity_verlet.jl:66
VelocityVerlet:
  n_steps        2000
  Δt             0.0001
  safety_factor  0.7</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kaipartmann/Peridynamics.jl/blob/d67dbd041ce7c52845c592e60db0e50e326f82c0/src/time_solvers/velocity_verlet.jl#L1-L46">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Peridynamics.DynamicRelaxation"><a class="docstring-binding" href="#Peridynamics.DynamicRelaxation"><code>Peridynamics.DynamicRelaxation</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">DynamicRelaxation(; kwargs...)</code></pre><p>Time integration solver for the adaptive dynamic relaxation algorithm used for quasi-static simulations.</p><p><strong>Keywords</strong></p><ul><li><code>steps::Int</code>: Number of calculated time steps. If this keyword is specified, the keyword   <code>time</code> is no longer allowed.</li><li><code>stepsize::Real</code>: Manually specify the size of the time step. (default: <code>1.0</code>)</li><li><code>damping_factor::Real</code>: Damping factor to increase the value in the mass matrix.   (default: <code>1.0</code>)</li></ul><p><strong>Throws</strong></p><ul><li>Error if <code>steps &lt; 0</code>.</li><li>Error if <code>stepsize &lt; 0</code>.</li><li>Error if <code>damping_factor &lt; 0</code>.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; DynamicRelaxation(steps=1000)
DynamicRelaxation:
  n_steps  1000
  Δt       1
  Λ        1

julia&gt; DynamicRelaxation(steps=1000, damping_factor=2)
DynamicRelaxation:
  n_steps  1000
  Δt       1
  Λ        2</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kaipartmann/Peridynamics.jl/blob/d67dbd041ce7c52845c592e60db0e50e326f82c0/src/time_solvers/dynamic_relaxation.jl#L1-L34">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Peridynamics.Job"><a class="docstring-binding" href="#Peridynamics.Job"><code>Peridynamics.Job</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">Job(spatial_setup, time_solver; kwargs...)</code></pre><p>A type that contains all the information necessary for a peridynamic simulation. You can <a href="#Peridynamics.submit"><code>submit</code></a> a <code>Job</code> to start the simulation.</p><p><strong>Arguments</strong></p><ul><li><code>spatial_setup</code>: A <a href="#Peridynamics.Body"><code>Body</code></a> or <a href="#Peridynamics.MultibodySetup"><code>MultibodySetup</code></a>.</li><li><code>time_solver</code>: <a href="../dev_solvers/#VelocityVerlet"><code>VelocityVerlet</code></a> or <a href="../dev_solvers/#DynamicRelaxation"><code>DynamicRelaxation</code></a>.</li></ul><p><strong>Keywords</strong></p><ul><li><p><code>path::String</code>: Path to store results. If it does not exist yet it will be created during   the simulation. (optional)</p></li><li><p><code>freq::Int</code>: Output frequency of result files. A output file will be written every   <code>freq</code>-th time step. (default: <code>10</code>)</p></li><li><p><code>fields</code>: Fields that should be exported to output files. Allowed keywords depend on the   selected material model. Please look at the documentation of the material you specified   when creating the body. (default: <code>(:displacement, :damage)</code>)</p><p>If <code>spatial_setup</code> is a <strong><code>Body</code></strong>, the <code>fields</code> keyword can be of the form:</p><ul><li><code>fields::Symbol</code>: A symbol specifying a single output field.</li><li><code>fields::NTuple{N,Symbol} where N</code>: A Tuple specifying multiple output fields.</li><li><code>fields::Vector{Symbol}</code>: A Vector specifying multiple output fields.</li></ul><p>If <code>spatial_setup</code> is a <strong><code>MultibodySetup</code></strong>, the <code>fields</code> keyword can also be specified   for every body separately:</p><ul><li><code>fields::Dict{Symbol,T}</code>: A Dictionary containing the fields separately for every   body. <code>T</code> is here every possible type of the <code>fields</code> keyword that can be used for a   single body.</li></ul></li></ul><div class="admonition is-info" id="No-file-export-1ff4063b59b3ac02"><header class="admonition-header">No file export<a class="admonition-anchor" href="#No-file-export-1ff4063b59b3ac02" title="Permalink"></a></header><div class="admonition-body"><p>If no keyword is specified when creating a <code>Job</code>, then no files will be exported.</p></div></div><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; job = Job(multibody_setup, verlet_solver; path=&quot;my_results/sim1&quot;)
Job:
  spatial_setup  25880-point MultibodySetup
  time_solver    VelocityVerlet(n_steps=2000, safety_factor=0.7)
  options        export_allowed=true, freq=10</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kaipartmann/Peridynamics.jl/blob/d67dbd041ce7c52845c592e60db0e50e326f82c0/src/core/job.jl#L3-L44">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Peridynamics.Study"><a class="docstring-binding" href="#Peridynamics.Study"><code>Peridynamics.Study</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">Study(jobcreator::Function, setups::Vector{&lt;:NamedTuple}; kwargs...)</code></pre><p>A structure for managing parameter studies with multiple peridynamic simulations. The <code>Study</code> type coordinates the execution of multiple simulation jobs with different parameter configurations, tracks their status, and logs all results to a central logfile.</p><p>If a logfile already exists at the study root (from a previous interrupted run), the constructor automatically reads it and initializes the <code>sim_success</code> field based on the recorded completion status. This enables seamless resumption of interrupted studies.</p><p><strong>Arguments</strong></p><ul><li><code>jobcreator::Function</code>: A function with signature   <code>jobcreator(setup::NamedTuple, root::String)</code>   that creates and returns a <a href="#Peridynamics.Job"><code>Job</code></a> object. The function receives:<ul><li><code>setup</code>: A <code>NamedTuple</code> containing the parameters for one simulation</li><li><code>root</code>: The root directory path for the study (to construct individual job paths)</li></ul></li><li><code>setups::Vector{&lt;:NamedTuple}</code>: A vector of parameter configurations. Each element must be   a <code>NamedTuple</code> with the same field names.</li></ul><p><strong>Keywords</strong></p><ul><li><code>root::String</code>: Root directory path where all simulation results and the study logfile   will be stored. This directory and all job subdirectories will be created during   <a href="#Peridynamics.submit!"><code>submit!</code></a>.</li><li><code>logfile_name::String</code>: Name of the study logfile. The file will be created in the <code>root</code>   directory.<br/>  (default: <code>&quot;study_log.log&quot;</code>)</li></ul><p><strong>Fields</strong></p><ul><li><code>jobcreator::Function</code>: The job creation function</li><li><code>setups</code>: Vector of parameter configurations</li><li><code>jobs</code>: Vector of created <a href="#Peridynamics.Job"><code>Job</code></a> objects</li><li><code>jobpaths::Vector{String}</code>: Paths to individual job directories (must be unique)</li><li><code>root::String</code>: Root directory for the study</li><li><code>logfile::String</code>: Path to the central study logfile</li><li><code>sim_success::Vector{Bool}</code>: Status flags indicating successful completion of each job</li></ul><p><strong>Throws</strong></p><ul><li><code>ArgumentError</code>: If <code>setups</code> is empty</li><li><code>ArgumentError</code>: If setups don&#39;t have consistent field names</li><li><code>ArgumentError</code>: If job paths are not unique</li><li><code>ArgumentError</code>: If <code>jobcreator</code> fails to create a valid job</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs"># some function that creates a Job from a parameter setup
function create_job(setup::NamedTuple, root::String)
    body = Body(BBMaterial(), uniform_box(1.0, 1.0, 1.0, 0.1))
    material!(body, horizon=0.3, E=setup.E, rho=1000, Gc=100)
    velocity_ic!(body, :all_points, :x, setup.velocity)
    solver = VelocityVerlet(steps=1000)
    # create a unique path for this job based on parameters
    path = joinpath(root, &quot;sim_E$(setup.E)_v$(setup.velocity)&quot;)
    return Job(body, solver; path=path, freq=10)
end

setups = [
    (; E=1e9, velocity=1.0),
    (; E=2e9, velocity=1.0),
    (; E=1e9, velocity=2.0),
]

study = Study(create_job, setups; root=&quot;my_parameter_study&quot;)</code></pre><p>See also: <a href="#Peridynamics.submit!"><code>submit!</code></a>, <a href="#Peridynamics.Job"><code>Job</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kaipartmann/Peridynamics.jl/blob/d67dbd041ce7c52845c592e60db0e50e326f82c0/src/core/study.jl#L1-L67">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Peridynamics.submit"><a class="docstring-binding" href="#Peridynamics.submit"><code>Peridynamics.submit</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">submit(job::Job; quiet=false)</code></pre><p>Run the simulation by submitting the job.</p><p><strong>Arguments</strong></p><ul><li><code>job::Job</code>: Job that contains all defined parameters and conditions.</li></ul><p><strong>Keywords</strong></p><ul><li><code>quiet::Bool</code>: If <code>true</code>, no outputs are printed in the terminal. (default: <code>false</code>)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kaipartmann/Peridynamics.jl/blob/d67dbd041ce7c52845c592e60db0e50e326f82c0/src/core/submit.jl#L3-L13">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Peridynamics.submit!"><a class="docstring-binding" href="#Peridynamics.submit!"><code>Peridynamics.submit!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">submit!(study::Study; kwargs...)</code></pre><p>Submit and execute all simulation jobs in a parameter study. Jobs are run sequentially, and each job can utilize MPI or multithreading as configured. If a job fails, the error is logged and execution continues with the remaining jobs.</p><p>This function creates the study root directory and logfile, then submits each job using <a href="#Peridynamics.submit"><code>submit</code></a>. All simulation results and individual job logs are stored in their respective job directories, while a central study logfile tracks the overall progress and status of all simulations.</p><p><strong>Resuming Interrupted Runs</strong></p><p>If the study logfile already exists (from a previous run), <code>submit!</code> will:</p><ul><li>Read the logfile and refresh <code>study.sim_success</code> to detect previously completed jobs</li><li>Skip jobs that already completed successfully (marked with &quot;skipped&quot; in the logfile)</li><li>Only execute jobs that failed or were not yet started</li><li>Append a &quot;RESUMED&quot; marker with timestamp to the logfile</li></ul><p>This allows you to safely resume a study after an interruption (crash, timeout, manual stop) without re-running successful simulations. Simply call <code>submit!(study)</code> again with the same study configuration.</p><p><strong>Arguments</strong></p><ul><li><code>study::Study</code>: The study containing all jobs to execute</li></ul><p><strong>Keywords</strong></p><ul><li><code>quiet::Bool</code>: If <code>true</code>, suppress terminal output for individual jobs (default: <code>false</code>)</li><li>Additional keywords are passed to <a href="#Peridynamics.submit"><code>submit</code></a> for each job</li></ul><p><strong>Behavior</strong></p><ul><li>Jobs execute sequentially (one after another)</li><li>Each job inherits MPI/threading configuration from the Julia session</li><li>Failed jobs don&#39;t stop execution of remaining jobs</li><li><code>study.sim_success</code> is updated with the status of each job</li><li>A study logfile is created at <code>study.logfile</code> with:<ul><li>Study header with timestamp</li><li>Parameters and status for each simulation</li><li>Execution time for successful jobs</li></ul></li><li>Individual job logs are written to their respective directories</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">study = Study(create_job, setups; root=&quot;my_study&quot;)
submit!(study; quiet=true)

# If the process was interrupted, simply call submit! again to resume:
# It will skip completed jobs and only run remaining ones
study = Study(create_job, setups; root=&quot;my_study&quot;)  # Reads existing logfile
submit!(study; quiet=true)  # Resumes from where it left off

# Check which simulations succeeded
successful_indices = findall(study.sim_success)
println(&quot;Successful simulations: &quot;, successful_indices)

# Read the study logfile
logcontent = read(study.logfile, String)</code></pre><p>See also: <a href="#Peridynamics.Study"><code>Study</code></a>, <a href="#Peridynamics.submit"><code>submit</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kaipartmann/Peridynamics.jl/blob/d67dbd041ce7c52845c592e60db0e50e326f82c0/src/core/study.jl#L131-L192">source</a></section></details></article><h2 id="Postprocessing"><a class="docs-heading-anchor" href="#Postprocessing">Postprocessing</a><a id="Postprocessing-1"></a><a class="docs-heading-anchor-permalink" href="#Postprocessing" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="Peridynamics.VtkReader.read_vtk"><a class="docstring-binding" href="#Peridynamics.VtkReader.read_vtk"><code>Peridynamics.VtkReader.read_vtk</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">read_vtk(file::AbstractString)</code></pre><p>Read vtu or pvtu file containing simulation results of a time step.</p><p><strong>Arguments</strong></p><ul><li><code>file::String</code>: Path to VTK file in vtu or pvtu format.</li></ul><p><strong>Returns</strong></p><ul><li><code>Dict{String, VecOrMat{Float64}}</code>: Simulation results as a dictionary.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; read_vtk(&quot;results/fragmenting_cylinder/vtk/timestep_000520.pvtu&quot;)
Dict{Symbol, VecOrMat{Float64}} with 4 entries:
  :position     =&gt; [0.0263309 0.027315 … 0.0293543 0.030339; 0.000292969 0.000294475…
  :displacement =&gt; [0.00583334 0.00581883 … 0.00585909 0.00584271; -0.000162852 -0.0…
  :damage       =&gt; [0.616071, 0.569343, 0.528571, 0.463415, 0.438776, 0.553571, 0.56…
  :time         =&gt; [9.69363e-5]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kaipartmann/Peridynamics.jl/blob/d67dbd041ce7c52845c592e60db0e50e326f82c0/src/VtkReader/VtkReader.jl#L289-L310">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Peridynamics.process_each_export"><a class="docstring-binding" href="#Peridynamics.process_each_export"><code>Peridynamics.process_each_export</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">process_each_export(f, vtk_path, default_value=nothing; kwargs...)
process_each_export(f, job, default_value=nothing; kwargs...)</code></pre><p>A function for postprocessing every exported file. This function works with multithreading and MPI and determines the backend exactly like the <a href="#Peridynamics.submit"><code>submit</code></a> function.</p><p><strong>Arguments</strong></p><ul><li><code>f::Function</code>: The processing function with signature <code>f(r0, r, id)</code> that returns a result   to be collected (when <code>default_value !== nothing</code>) or returns <code>nothing</code> (legacy mode).<ul><li><code>r0</code>: The results of <a href="#Peridynamics.VtkReader.read_vtk"><code>read_vtk</code></a> for the exported file of the reference   results.</li><li><code>r</code>: The results of <a href="#Peridynamics.VtkReader.read_vtk"><code>read_vtk</code></a> for a time step.</li><li><code>id::Int</code>: An ID indicating the number of the exported file (counted from 1, starting   with the reference file).</li></ul></li><li><code>vtk_path::AbstractString</code>: A path that should contain the export results of a simulation.</li><li><code>job::Job</code>: A job object. The path of the VTK files will then be processed from the   job options.</li><li><code>default_value</code>: Optional default value for result collection. When provided (not <code>nothing</code>),   the function returns a vector of results from processing each export file. The type of   <code>default_value</code> determines the element type of the returned vector. For MPI compatibility,   the returned result type must satisfy <code>isbitstype(result) == true</code>.   When <code>default_value === nothing</code> (default), the function returns <code>nothing</code> and behaves   like the original version without result collection.</li></ul><p><strong>Keywords</strong></p><ul><li><code>serial::Bool</code>: If <code>true</code>, all results will be processed in the correct order of the time   steps and on a single thread, cf. the MPI root rank. (default: <code>false</code>)</li><li><code>barrier::Bool</code>: If <code>true</code> and <code>serial=true</code>, adds an MPI barrier after processing   completes, ensuring all ranks wait for the root rank to finish. This is ignored when   <code>serial=false</code> (parallel processing has automatic coordination) or when <code>only_root=true</code>.   Use this when you need all ranks to synchronize after root-only file processing.   (default: <code>false</code>)</li><li><code>only_root::Bool</code>: If <code>true</code>, processing runs only on the root rank and results are NOT   broadcast to other ranks. This prevents MPI deadlocks when calling <code>process_each_export</code>   inside <code>process_each_job</code> with <code>only_root=true</code>. Non-root ranks return <code>nothing</code>.   When <code>false</code>, results are broadcast to all ranks (if result collection is enabled).   (default: <code>false</code>)</li></ul><p><strong>Returns</strong></p><ul><li><code>nothing</code> when <code>default_value === nothing</code> (legacy mode)</li><li><code>Vector{T}</code> where <code>T = typeof(default_value)</code> when result collection is enabled. Each   element corresponds to the result from processing one export file. With MPI, all ranks   receive the complete vector with results from all files.</li></ul><p><strong>MPI Behavior</strong></p><p>When running with MPI:</p><ul><li><code>serial=true, barrier=false, only_root=false</code>: Processing runs only on root rank. Results   are broadcast to all ranks. Non-root ranks wait for broadcast but don&#39;t process files.</li><li><code>serial=true, barrier=true, only_root=false</code>: Processing runs on root rank, results are   broadcast to all ranks, then all ranks wait at a barrier.</li><li><code>only_root=true</code>: Processing runs only on root rank. Results are NOT broadcast - non-root   ranks return <code>nothing</code> immediately. Use this to avoid MPI deadlocks when calling   <code>process_each_export</code> inside <code>process_each_job(...; only_root=true)</code>. The <code>barrier</code>   parameter is ignored.</li><li><code>serial=false</code>: Processing is distributed across all MPI ranks with automatic coordination.   Each rank processes a subset of files. The <code>barrier</code> and <code>only_root</code> parameters are   ignored.</li><li>With result collection enabled and <code>only_root=false</code>, results are gathered/broadcast so   all ranks receive the complete results vector. With <code>only_root=true</code>, only the root rank   gets results.</li></ul><div class="admonition is-warning" id="MPI-result-type-requirements-6eb0152d4054aaf9"><header class="admonition-header">MPI result type requirements<a class="admonition-anchor" href="#MPI-result-type-requirements-6eb0152d4054aaf9" title="Permalink"></a></header><div class="admonition-body"><p>When using result collection with MPI (<code>default_value !== nothing</code>), the returned result type must be a bits type (<code>isbitstype(result) == true</code>). This typically means primitive types or <code>NamedTuple</code>s of primitive types. Non-bits types like strings or arrays will cause an error.</p></div></div><p><strong>Examples</strong></p><pre><code class="language-julia hljs"># Legacy mode - no result collection
process_each_export(job; serial=true, barrier=true) do r0, r, id
    # File operations on root
    open(&quot;result_$id.txt&quot;, &quot;w&quot;) do io
        write(io, string(maximum(r[:displacement])))
    end
end

# Result collection mode
default_value = (; max_disp=NaN, avg_ux=NaN)
results = process_each_export(job, default_value) do r0, r, id
    max_disp = maximum(r[:displacement])
    ux = @view r[:displacement][1, :]
    avg_ux = sum(ux) / length(ux)
    return (; max_disp, avg_ux)
end
# results is a Vector{NamedTuple{(:max_disp, :avg_ux), Tuple{Float64, Float64}}}

# With MPI, all ranks get the complete results
@mpiroot println(&quot;Results from all files: &quot;, results)

# Using inside process_each_job to avoid deadlocks
process_each_job(jobs; only_root=true) do job, job_id
    submit(job)
    # Use only_root=true here to prevent MPI deadlock
    results = process_each_export(job, default_value; only_root=true) do r0, r, id
        # Process export files...
        return (; max_disp=maximum(r[:displacement]))
    end
    # Only root rank has results here, non-root ranks get nothing
    return results
end</code></pre><p>See also: <a href="#Peridynamics.process_each_job"><code>process_each_job</code></a>, <a href="#Peridynamics.mpi_isroot"><code>mpi_isroot</code></a>, <a href="#Peridynamics.mpi_barrier"><code>mpi_barrier</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kaipartmann/Peridynamics.jl/blob/d67dbd041ce7c52845c592e60db0e50e326f82c0/src/auxiliary/process_each_export.jl#L1-L106">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Peridynamics.process_each_job"><a class="docstring-binding" href="#Peridynamics.process_each_job"><code>Peridynamics.process_each_job</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">process_each_job(f::Function, study::Study, default_result::NamedTuple)</code></pre><p>Apply a processing function to each successfully completed job in a parameter study. This function iterates through all jobs in the study and applies the user-defined processing function <code>f</code> to jobs that completed successfully. Failed jobs or jobs where the processing function errors will use the <code>default_result</code> instead.</p><p>Before processing, this function automatically refreshes <code>study.sim_success</code> from the logfile if it exists. This ensures that jobs completed in a previous interrupted run are properly detected and processed, even if the current Julia session doesn&#39;t reflect their completion status yet.</p><p><strong>Arguments</strong></p><ul><li><code>f::Function</code>: A processing function with signature <code>f(job::Job, setup::NamedTuple)</code>   that returns a <code>NamedTuple</code> containing the processed results. The function receives:<ul><li><code>job</code>: The <a href="#Peridynamics.Job"><code>Job</code></a> object for the simulation</li><li><code>setup</code>: The parameter configuration <code>NamedTuple</code> for this job</li></ul></li><li><code>study::Study</code>: The study containing the jobs to process</li><li><code>default_result::NamedTuple</code>: The default result to use when a job failed or when   the processing function throws an error</li></ul><p><strong>Keywords</strong></p><ul><li><code>only_root::Bool</code>: If <code>true</code>, the processing function <code>f</code> runs only on the MPI root rank.   Non-root ranks will use <code>default_result</code> for all jobs. This is useful when processing   involves file I/O or expensive computations that should not be duplicated across ranks.   Note that the returned results vector will contain meaningful data only on the root rank   unless you manually broadcast results afterward. (default: <code>false</code>)</li></ul><p><strong>Returns</strong></p><ul><li><code>Vector{&lt;:NamedTuple}</code>: A vector of results with the same length as the number of   jobs in the study. Each element is either the result from applying <code>f</code> or the   <code>default_result</code> for failed/errored cases.</li></ul><p><strong>Behavior</strong></p><ul><li>Refreshes job completion status from logfile (if exists) before processing</li><li>Only processes jobs where <code>study.sim_success[i] == true</code></li><li>Failed jobs automatically receive <code>default_result</code> (warning logged)</li><li>If processing function <code>f</code> throws an error, that job receives <code>default_result</code> (error   logged with MPI barrier synchronization)</li><li>Processing is sequential (one job at a time)</li><li>All jobs in the study will have a corresponding entry in the results vector</li></ul><p><strong>MPI Behavior</strong></p><ul><li>By default (<code>only_root=false</code>), the processing function <code>f</code> is called on <strong>all MPI ranks</strong></li><li>With <code>only_root=true</code>, <code>f</code> runs only on root rank; non-root ranks use <code>default_result</code></li><li>Error handling includes automatic MPI barrier synchronization across all ranks</li></ul><div class="admonition is-danger" id="Using-process_each_job-inside-@mpiroot-calls-435b267a56ee3eee"><header class="admonition-header">Using `process_each_job` inside `@mpiroot` calls<a class="admonition-anchor" href="#Using-process_each_job-inside-@mpiroot-calls-435b267a56ee3eee" title="Permalink"></a></header><div class="admonition-body"><p>When calling <code>process_each_job</code> inside an <code>@mpiroot</code> block or any context where only the root process executes the code, you <strong>must</strong> use <code>only_root=true</code>. Otherwise, if an error occurs during processing, a deadlock will happen because the error handling attempts an MPI barrier, but non-root ranks are not participating in the <code>process_each_job</code> call at all.</p><pre><code class="language-julia hljs"># Correct: Use only_root=true when inside @mpiroot
@mpiroot :wait begin
    results = process_each_job(study, default; only_root=true) do job, setup
        # ... processing code
    end
end

# Incorrect: This will deadlock on errors
@mpiroot :wait begin
    results = process_each_job(study, default) do job, setup  # Missing only_root=true
        # ... processing code
    end
end</code></pre></div></div><div class="admonition is-danger" id="Using-only_roottrue-with-nested-process_each_export-calls-2a520f2dc2846959"><header class="admonition-header">Using `only_root=true` with nested `process_each_export` calls<a class="admonition-anchor" href="#Using-only_roottrue-with-nested-process_each_export-calls-2a520f2dc2846959" title="Permalink"></a></header><div class="admonition-body"><p>When using <code>only_root=true</code> in <code>process_each_job</code>, you have two safe options for nested <a href="#Peridynamics.process_each_export"><code>process_each_export</code></a> calls:</p><p><strong>Option 1 (Recommended):</strong> Always use <code>only_root=true</code> in nested <code>process_each_export</code> calls. This is the safest and most straightforward approach.</p><pre><code class="language-julia hljs">results = process_each_job(study, default; only_root=true) do job, setup
    # Safe: use only_root=true in nested calls
    res = process_each_export(job, default_value; only_root=true) do r0, r, id
        # ... process files and return results
    end
end</code></pre><p><strong>Option 2 (Advanced):</strong> Use <code>process_each_export</code> without result collection (<code>default_value=nothing</code>, the default) AND without <code>barrier=true</code>. This works because non-root ranks skip immediately without waiting for broadcasts or barriers.</p><pre><code class="language-julia hljs">results = process_each_job(study, default; only_root=true) do job, setup
    # Safe: no result collection, no barrier
    process_each_export(job) do r0, r, id  # returns nothing
        # ... do file I/O only
    end
end</code></pre><p><strong>What causes deadlocks:</strong></p><ul><li>Using result collection in <code>process_each_export</code> without <code>only_root=true</code> → non-root ranks wait for broadcasts that never happen</li><li>Using <code>barrier=true</code> → root rank waits at a barrier that non-root ranks never reach</li></ul><p>Additionally, ensure that the processing function <code>f</code> does not contain any other MPI calls or operations that require synchronization across ranks, as only the root process will execute it.</p></div></div><p><strong>Examples</strong></p><pre><code class="language-julia hljs"># After running a parameter study (possibly interrupted and resumed)
study = Study(create_job, setups; root=&quot;my_study&quot;)
# Status is automatically refreshed from logfile in constructor

# Define a function to extract maximum displacement from results
default = (; E=0.0, velocity=0.0, max_displacement=NaN)

# IMPORTANT: Must use only_root=true in both process_each_job AND process_each_export!
results = process_each_job(study, default; only_root=true) do job, setup
    # CRITICAL: only_root=true is required here to avoid MPI deadlock
    max_disps = process_each_export(job, 0.0; only_root=true) do r0, r, id
        return maximum(r[:displacement])
    end
    max_u = maximum(max_disps)
    return (; E=setup.E, velocity=setup.velocity, max_displacement=max_u)
end

# Filter successful results (only root rank will have meaningful data)
if mpi_isroot()
    successful_results = [r for r in results if !isnan(r.max_displacement)]
end</code></pre><p>See also: <a href="#Peridynamics.Study"><code>Study</code></a>, <a href="#Peridynamics.submit!"><code>submit!</code></a>, <a href="#Peridynamics.process_each_export"><code>process_each_export</code></a>, <a href="#Peridynamics.mpi_isroot"><code>mpi_isroot</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/kaipartmann/Peridynamics.jl/blob/d67dbd041ce7c52845c592e60db0e50e326f82c0/src/core/study.jl#L336-L470">source</a></section></details></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../dev_multithreading_mpi/">« Multithreading &amp; MPI</a><a class="docs-footer-nextpage" href="../private_api_reference/">Private API »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.16.1 on <span class="colophon-date" title="Wednesday 3 December 2025 12:43">Wednesday 3 December 2025</span>. Using Julia version 1.12.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
