var documenterSearchIndex = {"docs":
[{"location":"private_api_reference/#Private-API","page":"Private API","title":"Private API","text":"","category":"section"},{"location":"private_api_reference/","page":"Private API","title":"Private API","text":"Pages = [\"private_api_reference.md\"]","category":"page"},{"location":"private_api_reference/#Peridynamics.failure_permit!","page":"Private API","title":"Peridynamics.failure_permit!","text":"failure_permit!(body, set_name, fail_permit)\n\nSet the failure permission for points of the set set_name of a body.\n\nArguments\n\nbody::AbstractBody: Body where the failure permission will be set.\nset_name::Symbol: The name of a point set of this body.\nfail_permit::Bool: If true, failure is allowed, and if false then no bonds of this   point are allowed to break during the simulation.\n\ndanger: Overwriting failure permission with `material!` and `failure_permit!`\nThe function material! calls failure_permit!, so if it is used afterwards, previously set failure permissions might be overwritten!\n\nThrows\n\nError if the body does not contain a set with set_name.\n\n\n\n\n\n","category":"function"},{"location":"private_api_reference/#Peridynamics.get_frac_params","page":"Private API","title":"Peridynamics.get_frac_params","text":"get_frac_params(::AbstractDamageModel, p::Dict{Symbol,Any}, δ::Float64, K::Float64)\n\nRead or calculate the necessary fracture parameters for the specified damage model from the dictionary created with material!. This function has to be defined when creating a new damage model. Otherwise, a default method returns a empty named tuple (; ).\n\n\n\n\n\n","category":"function"},{"location":"private_api_reference/#Peridynamics.set_failure_permissions!","page":"Private API","title":"Peridynamics.set_failure_permissions!","text":"set_failure_permissions!(body, set_name, params)\n\nGrant or prohibit failure permission depending on the submitted fracture parameters by calling failure_permit!.\n\nIf fracture parameters are found, failure is allowed. If no fracture parameters are found, failure is not allowed.\n\n\n\n\n\n","category":"function"},{"location":"private_api_reference/#Peridynamics.has_fracture","page":"Private API","title":"Peridynamics.has_fracture","text":"has_fracture(mat, params)\n\nReturn true if at least one fracture parameter is set !=0 in params and the system therefore is supposed to have failure allowed or return false if not.\n\n\n\n\n\n","category":"function"},{"location":"private_api_reference/#Peridynamics.check_pos_and_vol","page":"Private API","title":"Peridynamics.check_pos_and_vol","text":"check_pos_and_vol(n_points, position, volume)\n\nCheck if the positions and volumes for the points are correctly specified in the fields of a Body.\n\n\n\n\n\n","category":"function"},{"location":"private_api_reference/#Peridynamics.pre_submission_check","page":"Private API","title":"Peridynamics.pre_submission_check","text":"pre_submission_check(body::Body; body_in_multibody_setup::Bool=false)\npre_submission_check(ms::AbstractMultibodySetup)\n\nCheck if necessary material parameters and conditions are defined when defining a Job.\n\n\n\n\n\n","category":"function"},{"location":"private_api_reference/#Peridynamics.get_paramsetup","page":"Private API","title":"Peridynamics.get_paramsetup","text":"get_paramsetup(body::AbstractBody, ::AbstractChunkHandler, ::SingleParamChunk)\nget_paramsetup(body::AbstractBody, ch::AbstractChunkHandler, ::MultiParamChunk)\n\nReturn the parameters of a BodyChunk if only one parameter set is defined for the corresponding Body or the parameter handler if multiple parameter sets are defined.\n\n\n\n\n\n","category":"function"},{"location":"private_api_reference/#Peridynamics.get_params","page":"Private API","title":"Peridynamics.get_params","text":"get_params(paramhandler::ParameterHandler, point_id::Int)\nget_params(params::AbstractPointParameters, ::Int)\nget_params(chunk::BodyChunk, point_id::Int)\n\nReturn parameters of a specific point with index point_id of a Body with parameters params or parameter handler paramhandler or of the body chunk.\n\n\n\n\n\n","category":"function"},{"location":"private_api_reference/#Peridynamics.check_if_sets_intersect","page":"Private API","title":"Peridynamics.check_if_sets_intersect","text":"check_if_sets_intersect(point_sets, key_a, key_b)\n\nThrow error if two sets chosen for precrack! have common points.\n\n\n\n\n\n","category":"function"},{"location":"private_api_reference/#Peridynamics.check_if_set_is_defined","page":"Private API","title":"Peridynamics.check_if_set_is_defined","text":"check_if_set_is_defined(point_sets, set_name)\n\nThrow an error if no point set set_name is found in the dictionary point_sets.\n\n\n\n\n\n","category":"function"},{"location":"private_api_reference/#Peridynamics.find_points","page":"Private API","title":"Peridynamics.find_points","text":"find_points(f, position)\n\nFind all points whose positions meet function f.\n\nThe function f accepts only one positional argument and will be used in a findall call. Depending on the argument name, a different input will be processed. See point_set!.\n\n\n\n\n\n","category":"function"},{"location":"private_api_reference/#Peridynamics.apply_precracks!","page":"Private API","title":"Peridynamics.apply_precracks!","text":"apply_precracks!(chunk, body)\n\nApply all predefined cracks for chunk by calling apply_precrack! for each crack.\n\n\n\n\n\n","category":"function"},{"location":"private_api_reference/#Peridynamics.apply_precrack!","page":"Private API","title":"Peridynamics.apply_precrack!","text":"apply_precrack!(chunk, body, crack)\n\nApply the predefined crack of the body for the considered chunk by breaking the concerned bonds.\n\n\n\n\n\n","category":"function"},{"location":"private_api_reference/#Peridynamics.point_sets_intersect","page":"Private API","title":"Peridynamics.point_sets_intersect","text":"point_sets_intersect(point_sets, key_a, key_b)\n\nReturn true if point sets key_a and key_b out of the dictionary point_sets have at least one common point, return false if they do not.\n\n\n\n\n\n","category":"function"},{"location":"private_api_reference/#Peridynamics.velocity_databc!","page":"Private API","title":"Peridynamics.velocity_databc!","text":"velocity_databc!(body, data, set_name, dims)\n\nSpecifies velocity boundary conditions for points of the set set_name in body. The value of the boundary condition is assigned by reading the corresponding positions in the matrix data. Multiple dimensions can be handled at once.\n\nwarning: Compatibility feature with other packages\nThis method / feature is used for compatibility with other packages developing with Peridynamics.jl. It is likely to change in the future, since the functionality of updating the values of the matrix during the simulation is not yet implemented. Consequently, at this stage, it is only available as a private API to facilitate future modifications and ensure easier implementation of changes.\n\nArguments\n\nbody::AbstractBody: Body the condition is specified on.\ndata::Matrix: A matrix of size length(dims) x n_points that contains the values of   the boundary condition for each point in the body. But only the conditions of points   contained in the set set_name are applied during the simulation! It should be noted,   that the value of the data matrix is constant and currently cannot be updated during   the simulation. The data matrix is not checked for NaN values, since this is handled   in the apply_bc! function. If it contains NaN values, then these values are ignored.\nset_name::Symbol: The name of a point set of this body. The condition applies only to   the points in this set, even if the data matrix contains values for all points in the   body.\ndims::Vector{Union{Integer,Symbol}}: Vector containing the directions of the condition   that should be applied, either specified as Symbol or integer.\nx-direction: :x or 1\ny-direction: :y or 2\nz-direction: :z or 3\nIt should not contain more than 3 elements, and the elements should be unique. The order   of the elements does not matter, however it must match the values in the data matrix.   So if the first column of the data matrix contains the values for the x-direction,   then the first element of dims should be 1 or :x, and so on.\n\nThrows\n\nErrors if the body does not contain a set with set_name.\nErrors if the directions are not correctly specified.\nErrors if the dimensions of the data matrix are incorrect.\n\n\n\n\n\n","category":"function"},{"location":"private_api_reference/#Peridynamics.forcedensity_databc!","page":"Private API","title":"Peridynamics.forcedensity_databc!","text":"forcedensity_databc!(body, data, set_name, dims)\n\nSpecifies forcedensity boundary conditions for points of the set set_name in body. The value of the boundary condition is assigned by reading the corresponding positions in the matrix data. Multiple dimensions can be handled at once.\n\nwarning: Compatibility feature with other packages\nThis method / feature is used for compatibility with other packages developing with Peridynamics.jl. It is likely to change in the future, since the functionality of updating the values of the matrix during the simulation is not yet implemented. Consequently, at this stage, it is only available as a private API to facilitate future modifications and ensure easier implementation of changes.\n\nArguments\n\nbody::AbstractBody: Body the condition is specified on.\ndata::Matrix: A matrix of size length(dims) x n_points that contains the values of   the boundary condition for each point in the body. But only the conditions of points   contained in the set set_name are applied during the simulation! It should be noted,   that the value of the data matrix is constant and currently cannot be updated during   the simulation. The data matrix is not checked for NaN values, since this is handled   in the apply_bc! function. If it contains NaN values, then these values are ignored.\nset_name::Symbol: The name of a point set of this body. The condition applies only to   the points in this set, even if the data matrix contains values for all points in the   body.\ndims::Vector{Union{Integer,Symbol}}: Vector containing the directions of the condition   that should be applied, either specified as Symbol or integer.\nx-direction: :x or 1\ny-direction: :y or 2\nz-direction: :z or 3\nIt should not contain more than 3 elements, and the elements should be unique. The order   of the elements does not matter, however it must match the values in the data matrix.   So if the first column of the data matrix contains the values for the x-direction,   then the first element of dims should be 1 or :x, and so on.\n\nThrows\n\nErrors if the body does not contain a set with set_name.\nErrors if the directions are not correctly specified.\nErrors if the dimensions of the data matrix are incorrect.\n\n\n\n\n\n","category":"function"},{"location":"private_api_reference/#Peridynamics.InterfaceError","page":"Private API","title":"Peridynamics.InterfaceError","text":"InterfaceError\n\nA type for a customized error that is thrown when a material model is not implemented correctly.\n\nFields\n\ntype::DataType: Type that is used.\nfunc::String: Function that is used.\n\n\n\n\n\n","category":"type"},{"location":"private_api_reference/#Peridynamics.HaloExchange","page":"Private API","title":"Peridynamics.HaloExchange","text":"HaloExchange\n\nA type used for communication between body chunks. This type is used with both MPI and multithreaded simulations. Note that the tag is only used with MPI and has the value 0 in multithreaded simulations.\n\nFields\n\ntag::Int: Tag used for the MPI sending and receiving commands.\nsrc_chunk_id::Int: Index of the chunk that sends information.\ndest_chunk_id::Int: Index of the chunk that receives information.\nsrc_idxs::Vector{Int}: Indices of the points in the source chunk that send information.\ndest_idxs::Vector{Int}: Indices of the points in the destination chunk that receive   information.\n\n\n\n\n\n","category":"type"},{"location":"private_api_reference/#Peridynamics.JobOptions","page":"Private API","title":"Peridynamics.JobOptions","text":"JobOptions{F,V}\n\nA type that contains the options of a job.\n\nType Parameters\n\nF: Type for fields of simulation.\nV: Type for basename of vtk-files.\n\nFields\n\nexport_allowed::Bool: Specify if data is exported for the job.\nroot::String: Path of the folder where all data is saved.\nvtk::String: Path of the folder where vtk-files are saved.\nlogfile::String: Complete path of the logfile.\nfreq::Int: Frequency of exported time steps.\nfields::F: Exported fields of the job.\nvtk_filebase::V: Basename of exported vtk-files.\n\n\n\n\n\n","category":"type"},{"location":"private_api_reference/#Peridynamics.MPIHaloInfo","page":"Private API","title":"Peridynamics.MPIHaloInfo","text":"MPIHaloInfo\n\nA type providing information about the halo points of body chunks.\n\nFields\n\npoint_ids::Dict{Int,Vector{Int}}: Indices of local and halo points of each chunk.\nhalos_points::Dict{Int,Vector{Int}}: Indices of halo points of each chunk.\nlocalizers::Dict{Int,Dict{Int,Int}}: Localizes global indices to local indices in the   corresponding chunks.\nhidxs_by_src::Dict{Int,Dict{Int,Vector{Int}}}: Dict specifying for each chunk the   indices of halo points but depending on the chunk they belong to.\n\n\n\n\n\n","category":"type"},{"location":"private_api_reference/#Peridynamics.MPIBodyDataHandler","page":"Private API","title":"Peridynamics.MPIBodyDataHandler","text":"MPIBodyDataHandler\n\nA type for handling information and communication for a body chunk in MPI.\n\nType Parameters\n\nSys: Type of system of the body.\nM: Type of the material model.\nP: Material parameter type.\nS: Storage type of the system.\nBufs: Type for buffers.\n\nFields\n\nchunk::BodyChunk{Sys,M,P,S}: Body chunk of the body.\nn_halo_fields::Int: Number of chunks in communication with this chunk due to existing   halo points.\nlth_exs_send::Vector{HaloExchange}: Local-to-halo-exchanges of the body chunk that   send information.\nlth_exs_recv::Vector{HaloExchange}: Local-to-halo-exchanges of the body chunk that   receive information.\nhtl_exs_send::Vector{HaloExchange}: Halo-to-local-exchanges of the body chunk that   send information.\nhtl_exs_recv::Vector{HaloExchange}: Halo-to-local-exchanges of the body chunk that   receive information.\nlth_send_bufs::Vector{Bufs}: Buffers for local-to-halo-exchanges that send information.\nlth_recv_bufs::Vector{Bufs}: Buffers for local-to-halo-exchanges that receive   information.\nhtl_send_bufs::Vector{Bufs}: Buffers for halo-to-local-exchanges that send information.\nhtl_recv_bufs::Vector{Bufs}: Buffers for halo-to-local-exchanges that receive   information.\nfield_to_buf::Dict{Symbol,Int}: Dict specifying the index in the buffer of each field   of the simulation.\nlth_reqs::Vector{Vector{MPI.Request}}: Pre-allocated buffer for requests for   local-to-halo-exchanges.\nhtl_reqs::Vector{Vector{MPI.Request}}: Pre-allocated buffer for requests for   halo-to-local-exchanges.\n\n\n\n\n\n","category":"type"},{"location":"private_api_reference/#Peridynamics.SingleParamChunk","page":"Private API","title":"Peridynamics.SingleParamChunk","text":"SingleParamChunk\n\nType for a body chunk of a body with only one material parameter set.\n\n\n\n\n\n","category":"type"},{"location":"private_api_reference/#Peridynamics.MultiParamChunk","page":"Private API","title":"Peridynamics.MultiParamChunk","text":"MultiParamChunk\n\nType for a body chunk of a body with multiple material parameter sets.\n\n\n\n\n\n","category":"type"},{"location":"private_api_reference/#Peridynamics.ParameterHandler","page":"Private API","title":"Peridynamics.ParameterHandler","text":"ParameterHandler\n\nA type used to manage multiple point parameters defined for the same body. It is used to assign different point parameters to the points of a body.\n\nType Parameters\n\nP<:AbstractPointParameters: Point parameter type.\n\nFields\n\nparameters::Vector{P}: All parameter sets defined in the simulation.\npoint_mapping::Vector{Int}: Vector assigning the related parameter set to each   material point.\n\n\n\n\n\n","category":"type"},{"location":"private_api_reference/#Peridynamics.ThreadsBodyDataHandler","page":"Private API","title":"Peridynamics.ThreadsBodyDataHandler","text":"ThreadsBodyDataHandler\n\nA type for handling all data of a body in multithreading simulations.\n\nType Parameters\n\nSys: Type of system of the body.\nM: Type of the material model.\nP: Material parameter type.\nS: Storage type of the system.\n\nFields\n\nn_chunks::Int: Number of chunks of the body.\nchunks::Vector{BodyChunk{Sys,M,P,S}}: All body chunks of the body.\nlth_exs::Vector{Vector{HaloExchange}}: All local-to-halo-exchanges of each body chunk   of the body.\nhtl_exs::Vector{Vector{HaloExchange}}: All halo-to-local-exchanges of each body chunk   of the body.\n\n\n\n\n\n","category":"type"},{"location":"private_api_reference/#Peridynamics.ThreadsMultibodyDataHandler","page":"Private API","title":"Peridynamics.ThreadsMultibodyDataHandler","text":"ThreadsMultibodyDataHandler\n\nA type for handling all data of multiple bodies in multithreading simulations.\n\nType Parameters\n\nBDH: Body data handler type.\nPC: Position cache type.\nVC: Volume cache type.\n\nFields\n\nn_bodies::Int: Number of bodies in the simulation.\nbody_dhs::BDH: Tuple containing all body data handlers.\nbody_names::Vector{Symbol}: Names of the bodies.\nbody_idxs::Dict{Symbol,Int}: Names of bodies assigned to their indices.\nsrf_contacts::Vector{ShortRangeForceContact}: All short range force contacts of this   simulation.\nposition_caches::PC: Positions of all points of all bodies (should be of type   Vector{Matrix{Float64}}).\nvolume_caches::VC: Volumes of all points of all bodies (should be of type   Vector{Vector{Float64}}).\n\n\n\n\n\n","category":"type"},{"location":"private_api_reference/#Peridynamics.BodyChunk","page":"Private API","title":"Peridynamics.BodyChunk","text":"BodyChunk{System, Material, Params, Storage}\n\nA type that contains all data of a body chunk. For parallel simulations, the body is divided into multiple chunks. Each BodyChunk instance contains all necessary information for the simulation on this specific chunk. This type is used for multithreading and MPI.\n\nType Parameters\n\nSystem<:AbstractSystem: Type of the system.\nMaterial<:AbstractMaterial: Type of the material model of the system.\nParams<:AbstractParameterSetup: Material parameters of the points in the body chunk.\nStorage<:AbstractStorage: Storage of all information that changes during the simulation.\n\nFields\n\nbody_name::Symbol: Name of the body in multibody simulations.\nsystem::System: System with all information that is known before the simulation.\nmat::Material: Material model of the system.\nparamsetup::Params: Material parameters of the points in the body chunk.\nstorage::Storage: Storage of all information that changes during the simulation.\npsets::Dict{Symbol,Vector{Int}}: Point sets of the chunk with local indices.\nsdbcs::Vector{SingleDimBC}: Single dimension boundary conditions.\npdsdbcs::Vector{PosDepSingleDimBC}: Position dependent single dimension boundary   conditions.\ncells::Vector{MeshCell{VTKCellType,Tuple{Int64}}}: Cells for vtk export.\n\n\n\n\n\n","category":"type"},{"location":"private_api_reference/#Peridynamics.Bond","page":"Private API","title":"Peridynamics.Bond","text":"Bond\n\nType that describes a bond of two points in a peridynamics body.\n\nFields\n\nneighbor::Int: The index of the neighbor point with which the bond is formed.\nlength::Float64: The length of the bond.\nfail_permit::Bool: Describes whether failure is allowed or not for this bond.\n\n\n\n\n\n","category":"type"},{"location":"private_api_reference/#Peridynamics.BondSystem","page":"Private API","title":"Peridynamics.BondSystem","text":"BondSystem{Correction}\n\nA type for a system for all peridynamic formulations that work with just bonds of two points.\n\nType Parameters\n\nCorrection<:AbstractCorrection: Applied surface correction.\n\nFields\n\nposition::Matrix{Float64}: Positions of all points of the system.\nvolume::Vector{Float64}: Volumes of the points of the system.\nbonds::Vector{Bond}: Vector containing all bonds of the bond system.\nn_neighbors::Vector{Int}: Number of neighbors for each point of the system.\nbond_ids::Vector{UnitRange{Int}}: Range of the bonds vector containing bonds of   considered point.\ncorrection::Correction: Applied surface correction.\nchunk_handler::ChunkHandler: Type to handle the chunks for the simulation.   See ChunkHandler.\n\n\n\n\n\n","category":"type"},{"location":"private_api_reference/#Peridynamics.ChunkHandler","page":"Private API","title":"Peridynamics.ChunkHandler","text":"ChunkHandler\n\nA type to handle a body chunk and its communication to other chunks.\n\nFields\n\nn_loc_points::Int: Number of local points that belong to the body chunk.\npoint_ids::Vector{Int}: Indices of all local and halo points of the chunk.\nloc_points::UnitRange{Int}: Indices of local points of the chunk.\nhalo_points::Vector{Int}: Indices of halo points of the chunk.\nhidxs_by_src::Dict{Int,UnitRange{Int}}: Dict specifying the indices of halo Points   depending on the body chunk they belong to.\nlocalizer::Dict{Int,Int}: Localizes global indices to local indices in this chunk.\n\n\n\n\n\n","category":"type"},{"location":"private_api_reference/#Peridynamics.PointDecomposition","page":"Private API","title":"Peridynamics.PointDecomposition","text":"PointDecomposition\n\nA type that describes how a body is divided into multiple body chunks.\n\nFields\n\nn_chunks::Int: Number of body chunks.\ndecomp::Vector{UnitRange{Int}}: Indices of the points belonging to each chunk.\npoint_src::Dict{Int,Int}: Dict that assigns all point indices to the chunk they belong   to.\n\n\n\n\n\n","category":"type"},{"location":"private_api_reference/#Peridynamics.TwoNeighborInteraction","page":"Private API","title":"Peridynamics.TwoNeighborInteraction","text":"TwoNeighborInteraction\n\nType for two-neighbor interactions.\n\nFields\n\noni_j::Int: One-neighbor interaction of considered point with point j.\noni_k::Int: One-neighbor interaction of considered point with point k.\nsurface::Float64: Surface spread by this two-neighbor interaction.\n\n\n\n\n\n","category":"type"},{"location":"private_api_reference/#Peridynamics.ThreeNeighborInteraction","page":"Private API","title":"Peridynamics.ThreeNeighborInteraction","text":"ThreeNeighborInteraction\n\nType for three-neighbor interactions.\n\nFields\n\noni_j::Int: One-neighbor interaction of considered point with point j.\noni_k::Int: One-neighbor interaction of considered point with point k.\noni_l::Int: One-neighbor interaction of considered point with point l.\nvolume::Float64: Volume spread by this three-neighbor interaction.\n\n\n\n\n\n","category":"type"},{"location":"private_api_reference/#Peridynamics.InteractionSystem","page":"Private API","title":"Peridynamics.InteractionSystem","text":"InteractionSystem\n\nA peridynamic system type that is mainly designed for continuum-kinematics-inspired peridynamics [JMS19].\n\nFields\n\nposition::Matrix{Float64}: Positions of all points of the system.\none_nis::Vector{Bond}: Vector containing all one-neighbor interactions (bonds) of the   system.\ntwo_nis::Vector{TwoNeighborInteraction}: Vector containing all two-neighbor   interactions of the system.\nthree_nis::Vector{ThreeNeighborInteraction}: Vector containing all three-neighbor   interactions of the system.\nvolume::Vector{Float64}: Volumes of the points of the system.\nvolume_one_nis::Vector{Float64}: Effective volumes of one-neighbor interactions.\nvolume_two_nis::Vector{Float64}: Effective volumes of two-neighbor interactions.\nvolume_three_nis::Vector{Float64}: Effective volumes of three-neighbor interactions.\nn_one_nis::Vector{Int}: Number of one-neighbor interactions for each point of the   system.\nn_two_nis::Vector{Int}: Number of two-neighbor interactions for each point of the   system.\nn_three_nis::Vector{Int}: Number of three-neighbor interactions for each point of the   system.\none_ni_idxs::Vector{UnitRange{Int}}: Range of the one-neighbor interactions vector   containing interactions of considered point.\ntwo_ni_idxs::Vector{UnitRange{Int}}: Range of the two-neighbor interactions vector   containing interactions of considered point.\nthree_ni_idxs::Vector{UnitRange{Int}}: Range of the three-neighbor interactions vector   containing interactions of considered point.\nchunk_handler::ChunkHandler: Type to handle the chunks for the simulation.   See ChunkHandler.\n\n\n\n\n\n","category":"type"},{"location":"private_api_reference/#Peridynamics.PointSetsPreCrack","page":"Private API","title":"Peridynamics.PointSetsPreCrack","text":"PointSetsPreCrack\n\nType describing a predefined crack in a peridynamic body.\n\nFields\n\nset_a::Symbol: Point set containing points on one side of the crack.\nset_b::Symbol: Point set with points on other side of the crack.\nfilter_bonds::Bool: If true, the involved bonds are filtered out so no damage is   present at the beginning of the simulation. Else, all involved bonds are marked broken   from the beginning.\n\n\n\n\n\n","category":"type"},{"location":"private_api_reference/#Peridynamics.StandardPointParameters","page":"Private API","title":"Peridynamics.StandardPointParameters","text":"StandardPointParameters\n\nType containing the material parameters for a standard peridynamics model using the bond-based, ordinary state-based or non-ordinary state-based correspondence formulation of peridynamics.\n\nFields\n\nδ::Float64: Horizon.\nrho::Float64: Density.\nE::Float64: Young's modulus.\nnu::Float64: Poisson's ratio.\nG::Float64: Shear modulus.\nK::Float64: Bulk modulus.\nλ::Float64: 1st Lamé parameter.\nμ::Float64: 2nd Lamé parameter.\nGc::Float64: Critical energy release rate.\nεc::Float64: Critical strain.\nbc::Float64: Bond constant.\n\n\n\n\n\n","category":"type"},{"location":"private_api_reference/#Peridynamics.SingleDimBC","page":"Private API","title":"Peridynamics.SingleDimBC","text":"SingleDimBC{F}\n\nType for a boundary condition in a single dimension for a peridynamic simulation.\n\nType Parameters\n\nF<:Function: Time dependent function which describes the boundary condition.\n\nFields\n\nfun::F: Time dependent function which describes the boundary condition.\nfield::Symbol: Field of the condition (e.g. velocity, force density).\npoint_set::Symbol: Point set on which the condition is applied.\ndim::UInt8: Dimension in which the condition is applied.\n\n\n\n\n\n","category":"type"},{"location":"private_api_reference/#Peridynamics.PosDepSingleDimBC","page":"Private API","title":"Peridynamics.PosDepSingleDimBC","text":"PosDepSingleDimBC{F}\n\nType for a position dependent boundary condition in a single dimension for a peridynamic simulation.\n\nType Parameters\n\nF<:Function: Position and time dependent function which describes the boundary   condition.\n\nFields\n\nfun::F: Position and time dependent function which describes the boundary condition.\nfield::Symbol: Field of the condition (e.g. velocity, force density).\npoint_set::Symbol: Point set on which the condition is applied.\ndim::UInt8: Dimension in which the condition is applied.\n\n\n\n\n\n","category":"type"},{"location":"private_api_reference/#Peridynamics.CKIPointParameters","page":"Private API","title":"Peridynamics.CKIPointParameters","text":"CKIPointParameters\n\nType containing the material parameters for a continuum-kinematics-inspired peridynamics model.\n\nFields\n\nδ::Float64: Horizon.\nrho::Float64: Density.\nE::Float64: Young's modulus.\nnu::Float64: Poisson's ratio.\nG::Float64: Shear modulus.\nK::Float64: Bulk modulus.\nλ::Float64: 1st Lamé parameter.\nμ::Float64: 2nd Lamé parameter.\nGc::Float64: Critical energy release rate.\nεc::Float64: Critical strain.\nC1::Float64: Material constant for one-neighbor interactions.\nC2::Float64: Material constant for two-neighbor interactions.\nC3::Float64: Material constant for three-neighbor interactions.\n\n\n\n\n\n","category":"type"},{"location":"private_api_reference/#Peridynamics.BACPointParameters","page":"Private API","title":"Peridynamics.BACPointParameters","text":"BACPointParameters\n\nType containing the material parameters for a peridynamics model using the bond-associated correspondence formulation of Chen and Spencer.\n\nFields\n\nδ::Float64: Horizon.\nδb::Float64: Bond-associated horizon.\nrho::Float64: Density.\nE::Float64: Young's modulus.\nnu::Float64: Poisson's ratio.\nG::Float64: Shear modulus.\nK::Float64: Bulk modulus.\nλ::Float64: 1st Lamé parameter.\nμ::Float64: 2nd Lamé parameter.\nGc::Float64: Critical energy release rate.\nεc::Float64: Critical strain.\nbc::Float64: Bond constant.\n\n\n\n\n\n","category":"type"},{"location":"private_api_reference/#Peridynamics.SingleDimIC","page":"Private API","title":"Peridynamics.SingleDimIC","text":"SingleDimIC\n\nType for an initial condition in a single dimension for a peridynamic simulation.\n\nFields\n\nvalue::Float64: Value of the condition.\nfield::Symbol: Field of the condition (e.g. velocity, force density).\npoint_set::Symbol: Point set on which the condition is applied.\ndim::UInt8: Dimension in which the condition is applied.\n\n\n\n\n\n","category":"type"},{"location":"private_api_reference/#Peridynamics.PosDepSingleDimIC","page":"Private API","title":"Peridynamics.PosDepSingleDimIC","text":"PosDepSingleDimIC{F}\n\nType for a position dependent initial condition in a single dimension for a peridynamic simulation.\n\nType Parameters\n\nF<:Function: Position dependent function which describes the initial condition.\n\nFields\n\nfun::F: Position dependent function which describes the initial condition.\nfield::Symbol: Field of the condition (e.g. velocity, force density).\npoint_set::Symbol: Point set on which the condition is applied.\ndim::UInt8: Dimension in which the condition is applied.\n\n\n\n\n\n","category":"type"},{"location":"private_api_reference/#Peridynamics.ShortRangeForceContact","page":"Private API","title":"Peridynamics.ShortRangeForceContact","text":"ShortRangeForceContact\n\nA type for contact simulations with the short range forces algorithm.\n\nType Parameters\n\nN: Neighborhood search object used by PointNeighbors.jl.\n\nFields\n\nbody_id_a::Symbol: Index of a body of the contact.\nbody_id_b::Symbol: Index of a body of the contact.\nradius::Float64: Search radius for contact.\npenalty_factor::Float64: Penalty factor for the contact simulation.\nnhs::N: Neighborhood search object used by PointNeighbors.jl.\n\n\n\n\n\n","category":"type"},{"location":"private_api_reference/#Peridynamics.@storage","page":"Private API","title":"Peridynamics.@storage","text":"@storage material storage\n@storage material solver storage\n\nA macro for automatic creation of a storage type. The macro then maps a specified material type with the storage structure. When no solver is specified, this storage is always used independently of the solver type. Specifying a solver allows the usage of customized storages for a solver.\n\nThe following macros can be used before field definitions inside the storage struct:\n\n@pointfield: Specifies a point field (data that each point has). Most of the time a   Matrix (column i is a vectorial quantity of the local point i) or a Vector   (entry i is a scalar value of local point i).\n@lthfield: Specifies a point field with local-to-halo exchange during the simulation   (creates a buffer and automatically updates this field when running the local-to-halo   update functions).\n@htlfield: Specifies a point field with halo-to-local exchange during the simulation,   similar to @lthfield.\n\nExample\n\nExample definition of the storage for the bond-based material:\n\n@storage BBMaterial struct BBStorage <: AbstractStorage\n    @lthfield position::Matrix{Float64}\n    @pointfield displacement::Matrix{Float64}\n    @pointfield velocity::Matrix{Float64}\n    @pointfield velocity_half::Matrix{Float64}\n    @pointfield velocity_half_old::Matrix{Float64}\n    @pointfield acceleration::Matrix{Float64}\n    @pointfield b_int::Matrix{Float64}\n    @pointfield b_int_old::Matrix{Float64}\n    @pointfield b_ext::Matrix{Float64}\n    @pointfield density_matrix::Matrix{Float64}\n    @pointfield damage::Vector{Float64}\n    bond_active::Vector{Bool}\n    @pointfield n_active_bonds::Vector{Int}\nend\n\n\n\n\n\n","category":"macro"},{"location":"expl_references/#References","page":"References","title":"References","text":"","category":"section"},{"location":"expl_references/","page":"References","title":"References","text":"P. Diehl, S. Prudhomme and M. Lévesque. A Review of Benchmark Experiments for the Validation of Peridynamics Models. Journal of Peridynamics and Nonlocal Modeling 1, 14–35 (2019).\n\n\n\nA. Javili, A. McBride and P. Steinmann. Continuum-kinematics-inspired peridynamics. Mechanical problems. Journal of the Mechanics and Physics of Solids 131 (2019).\n\n\n\nA. Javili, R. Morasata, E. Oterkus and S. Oterkus. Peridynamics review. Mathematics and Mechanics of Solids 24, 3714–3739 (2019).\n\n\n\nQ. Le and F. Bobaru. Surface corrections for peridynamic models in elasticity and fracture. Computational Mechanics 61, 1–20 (2018).\n\n\n\nE. Madenci and E. Oterkus. Peridynamic Theory and Its Applications (Springer New York, New York, 2014).\n\n\n\nK. Partmann, M. Dienst and K. Weinberg. Peridynamic computations of wave propagation and reflection at material interfaces. Archive of Applied Mechanics (2024).\n\n\n\nS. A. Silling. Reformulation of elasticity theory for discontinuities and long-range forces. Journal of the Mechanics and Physics of Solids 48, 175–209 (2000).\n\n\n\nS. A. Silling, M. Epton, O. Weckner, J. Xu and E. Askari. Peridynamic States and Constitutive Modeling. Journal of Elasticity 88, 151–184 (2007). Accessed on Oct 15, 2020.\n\n\n\nS. Silling and E. Askari. A meshfree method based on the peridynamic model of solid mechanics. Computers & Structures 83, 1526–1535 (2005).\n\n\n\nS. Silling and F. Bobaru. Peridynamic modeling of membranes and fibers. International Journal of Non-Linear Mechanics 40, 395–409 (2005). Special Issue in Honour of C.O. Horgan.\n\n\n\nJ. Trageser and P. Seleson. Bond-Based Peridynamics: a Tale of Two Poisson's Ratios. Journal of Peridynamics and Nonlocal Modeling 2, 278–288 (2020).\n\n\n\n","category":"page"},{"location":"howto_visualization/#visualization","page":"Visualization with ParaView","title":"Visualization with ParaView","text":"","category":"section"},{"location":"howto_visualization/","page":"Visualization with ParaView","title":"Visualization with ParaView","text":"The following section explains a few visualization basics with ParaView (ParaView 5.10.1 on macOS Monterey).","category":"page"},{"location":"howto_visualization/#Basics","page":"Visualization with ParaView","title":"Basics","text":"","category":"section"},{"location":"howto_visualization/#1.-Load-the-results","page":"Visualization with ParaView","title":"1. Load the results","text":"","category":"section"},{"location":"howto_visualization/","page":"Visualization with ParaView","title":"Visualization with ParaView","text":"Load the resulting .vtu files into ParaView with File rightarrow Open.","category":"page"},{"location":"howto_visualization/","page":"Visualization with ParaView","title":"Visualization with ParaView","text":"<img src=\"https://github.com/kaipartmann/Peridynamics.jl/assets/68582683/a5cfb0f2-db8a-4c3b-9f9e-6fc1c66b3716\" width=\"600\" />","category":"page"},{"location":"howto_visualization/#2.-Select-the-time-array","page":"Visualization with ParaView","title":"2. Select the time array","text":"","category":"section"},{"location":"howto_visualization/","page":"Visualization with ParaView","title":"Visualization with ParaView","text":"Select the time array and all the parameters you want to analyze and then Apply.","category":"page"},{"location":"howto_visualization/","page":"Visualization with ParaView","title":"Visualization with ParaView","text":"<img src=\"https://github.com/kaipartmann/Peridynamics.jl/assets/68582683/32246ca6-548d-4883-87e0-c9fb88baffd4\" width=\"1000\" />","category":"page"},{"location":"howto_visualization/#3.-Representation-and-coloring","page":"Visualization with ParaView","title":"3. Representation and coloring","text":"","category":"section"},{"location":"howto_visualization/","page":"Visualization with ParaView","title":"Visualization with ParaView","text":"Change the representation to Points and then choose the coloring parameter.","category":"page"},{"location":"howto_visualization/","page":"Visualization with ParaView","title":"Visualization with ParaView","text":"<img src=\"https://github.com/kaipartmann/Peridynamics.jl/assets/68582683/78c618e8-0a3b-455c-a1f7-707079714479\" width=\"1000\" />","category":"page"},{"location":"howto_visualization/#4.-Point-styling","page":"Visualization with ParaView","title":"4. Point styling","text":"","category":"section"},{"location":"howto_visualization/","page":"Visualization with ParaView","title":"Visualization with ParaView","text":"Activate the setting to render points as spheres and set an appropriate point size.","category":"page"},{"location":"howto_visualization/","page":"Visualization with ParaView","title":"Visualization with ParaView","text":"<img src=\"https://github.com/kaipartmann/Peridynamics.jl/assets/68582683/484cdf0a-16ac-4c64-b2b4-9ad96ca6c817\" width=\"1000\" />","category":"page"},{"location":"howto_visualization/#5.-Legend-styling","page":"Visualization with ParaView","title":"5. Legend styling","text":"","category":"section"},{"location":"howto_visualization/","page":"Visualization with ParaView","title":"Visualization with ParaView","text":"By default, the legend limits are set for the current range of the coloring parameter. In this example, for the initial time step all damage values are zero so strange legend limits appear.","category":"page"},{"location":"howto_visualization/","page":"Visualization with ParaView","title":"Visualization with ParaView","text":"<img src=\"https://github.com/kaipartmann/Peridynamics.jl/assets/68582683/7a38a834-1157-469b-9b79-3c3b24388c39\" width=\"1000\" />","category":"page"},{"location":"howto_visualization/#6.-Save-animation","page":"Visualization with ParaView","title":"6. Save animation","text":"","category":"section"},{"location":"howto_visualization/","page":"Visualization with ParaView","title":"Visualization with ParaView","text":"To generate a animation, use File rightarrow Save Animation... and follow the instructions.","category":"page"},{"location":"howto_visualization/#Additional-Learning-Resources","page":"Visualization with ParaView","title":"Additional Learning Resources","text":"","category":"section"},{"location":"howto_visualization/","page":"Visualization with ParaView","title":"Visualization with ParaView","text":"ParaView has a great documentation and a lot of resources for learning. For example, see:","category":"page"},{"location":"howto_visualization/","page":"Visualization with ParaView","title":"Visualization with ParaView","text":"ParaView Documentation\nParaView User's Guide","category":"page"},{"location":"expl_nosbased/#expl_nosb","page":"Non-ordinary state-based peridynamics","title":"Non-ordinary state-based peridynamics","text":"","category":"section"},{"location":"expl_nosbased/","page":"Non-ordinary state-based peridynamics","title":"Non-ordinary state-based peridynamics","text":"Non-ordinary state-based formulations have been developed to extend state-based peridynamics. Hereafter, the correspondence formulation of non-ordinary state based peridynamics is considered, which uses an elastic model from the classical theory. [SEW+07]","category":"page"},{"location":"expl_nosbased/","page":"Non-ordinary state-based peridynamics","title":"Non-ordinary state-based peridynamics","text":"First, the symmetric shape tensor is calculated:","category":"page"},{"location":"expl_nosbased/","page":"Non-ordinary state-based peridynamics","title":"Non-ordinary state-based peridynamics","text":"boldsymbolK^i = boldsymbolK(boldsymbolX^i) = int_mathcalH_i omega  boldsymbolDelta X^ij otimes boldsymbolDelta X^ij  mathrmdV^j  ","category":"page"},{"location":"expl_nosbased/","page":"Non-ordinary state-based peridynamics","title":"Non-ordinary state-based peridynamics","text":"Here, omega is an influence function to weigh points differently. The deformation gradient is thus approximated as [SEW+07]","category":"page"},{"location":"expl_nosbased/","page":"Non-ordinary state-based peridynamics","title":"Non-ordinary state-based peridynamics","text":"boldsymbolF^i = boldsymbolF(boldsymbolX^it) = left(int_mathcalH_i omega  boldsymbolDelta x^ij otimes boldsymbolDelta X^ij  mathrmdV^jright) left(boldsymbolK^iright)^-1  ","category":"page"},{"location":"expl_nosbased/","page":"Non-ordinary state-based peridynamics","title":"Non-ordinary state-based peridynamics","text":"Using the deformation gradient, now the first Piola-Kirchhoff stress tensor can be determined with the Helmholtz energy density Psi:","category":"page"},{"location":"expl_nosbased/","page":"Non-ordinary state-based peridynamics","title":"Non-ordinary state-based peridynamics","text":"boldsymbolP^i = boldsymbolP(boldsymbolX^it) = fracpartial Psipartial boldsymbolF^i  = boldsymbolF boldsymbolS  ","category":"page"},{"location":"expl_nosbased/","page":"Non-ordinary state-based peridynamics","title":"Non-ordinary state-based peridynamics","text":"Using the calculated variables, the force vector state can now be determined by [SEW+07]","category":"page"},{"location":"expl_nosbased/","page":"Non-ordinary state-based peridynamics","title":"Non-ordinary state-based peridynamics","text":"boldsymbolt^i = omega boldsymbolP^i  left(boldsymbolK^iright)^-1 boldsymbolDelta X^ij  ","category":"page"},{"location":"expl_nosbased/","page":"Non-ordinary state-based peridynamics","title":"Non-ordinary state-based peridynamics","text":"Size Symbol Unit\nBond in mathcalB_0 boldsymbolDelta X^ij mathrmm\nBond in mathcalB_t boldsymbolDelta x^ij mathrmm\nInfluence function omega -\nVolume of point j V^j leftmathrmm^3right\nSymmetric shape tensor boldsymbolK^i leftmathrmm^5right\nDeformation gradient boldsymbolF^i -\nHelmholtz energy density Psi leftfracmathrmkgmathrmmmathrms^2right\nPiola-Kirchhoff stress tensor boldsymbolP^i leftfracmathrmkgmathrmmmathrms^2right\nForce vector state boldsymbolt^i leftfracmathrmkgmathrmm^5mathrms^2right","category":"page"},{"location":"public_api_reference/#Public-API","page":"Public API","title":"Public API","text":"","category":"section"},{"location":"public_api_reference/","page":"Public API","title":"Public API","text":"Pages = [\"public_api_reference.md\"]","category":"page"},{"location":"public_api_reference/#Material-models","page":"Public API","title":"Material models","text":"","category":"section"},{"location":"public_api_reference/#Peridynamics.BBMaterial","page":"Public API","title":"Peridynamics.BBMaterial","text":"BBMaterial()\nBBMaterial{Correction}()\n\nA material type used to assign the material of a Body with the standard bond-based formulation of peridynamics.\n\nKeywords\n\ndmgmodel::AbstractDamageModel: Damage model defining the fracture behavior.   (default: CriticalStretch())\n\nPossible correction methods are:\n\nNoCorrection: No correction is applied. (default)\nEnergySurfaceCorrection: The energy based surface correction method of   Le and Bobaru (2018) is applied.\n\nExamples\n\njulia> mat = BBMaterial()\nBBMaterial{NoCorrection}()\n\njulia> mat = BBMaterial{EnergySurfaceCorrection}()\nBBMaterial{EnergySurfaceCorrection}()\n\n\n\nBBMaterial{Correction}\n\nMaterial type for the bond-based peridynamics formulation.\n\nType Parameters\n\nCorrection: A correction algorithm type. See the constructor docs for more informations.\nDM: A damage model type.\n\nAllowed material parameters\n\nWhen using material! on a Body with BBMaterial, then the following parameters are allowed: Material parameters:\n\nhorizon::Float64: Radius of point interactions.\nrho::Float64: Density.\n\nElastic parameters\n\nE::Float64: Young's modulus.\nG::Float64: Shear modulus.\nK::Float64: Bulk modulus.\nlambda::Float64: 1st Lamé parameter.\nmu::Float64: 2nd Lamé parameter.\n\nFracture parameters:\n\nGc::Float64: Critical energy release rate.\nepsilon_c::Float64: Critical strain.\n\nnote: Poisson's ratio and bond-based peridynamics\nIn bond-based peridynamics, the Poisson's ratio is limited to 1/4 for 3D simulations. Therefore, only one additional elastic parameter is required. Optionally, the specification of a second keyword is allowed, if the parameter combination results in nu = 1/4.\n\nAllowed export fields\n\nWhen specifying the fields keyword of Job for a Body with BBMaterial, the following fields are allowed:\n\nposition::Matrix{Float64}: Position of each point.\ndisplacement::Matrix{Float64}: Displacement of each point.\nvelocity::Matrix{Float64}: Velocity of each point.\nvelocity_half::Matrix{Float64}: Velocity parameter for Verlet time solver.\nacceleration::Matrix{Float64}: Acceleration of each point.\nb_int::Matrix{Float64}: Internal force density of each point.\nb_ext::Matrix{Float64}: External force density of each point.\ndamage::Vector{Float64}: Damage of each point.\nn_active_bonds::Vector{Int}: Number of intact bonds of each point.\n\n\n\n\n\n","category":"type"},{"location":"public_api_reference/#Peridynamics.DHBBMaterial","page":"Public API","title":"Peridynamics.DHBBMaterial","text":"DHBBMaterial()\nDHBBMaterial{Correction}()\n\nA material type used to assign the material of a Body with the dual-horizon bond-based formulation of peridynamics.\n\nKeywords\n\ndmgmodel::AbstractDamageModel: Damage model defining the fracture behavior.   (default: CriticalStretch())\n\nPossible correction methods are:\n\nNoCorrection: No correction is applied. (default)\nEnergySurfaceCorrection: The energy based surface correction method of   Le and Bobaru (2018) is applied.\n\nExamples\n\njulia> mat = DHBBMaterial()\nDHBBMaterial{NoCorrection}()\n\njulia> mat = DHBBMaterial{EnergySurfaceCorrection}()\nDHBBMaterial{EnergySurfaceCorrection}()\n\n\n\nDHBBMaterial{Correction}\n\nMaterial type for the dual-horizon bond-based peridynamics formulation.\n\nType Parameters\n\nCorrection: A correction algorithm type. See the constructor docs for more informations.\nDM: A damage model type.\n\nAllowed material parameters\n\nWhen using material! on a Body with DHBBMaterial, then the following parameters are allowed: Material parameters:\n\nhorizon::Float64: Radius of point interactions.\nrho::Float64: Density.\n\nElastic parameters:\n\nE::Float64: Young's modulus.\nG::Float64: Shear modulus.\nK::Float64: Bulk modulus.\nlambda::Float64: 1st Lamé parameter.\nmu::Float64: 2nd Lamé parameter.\n\nFracture parameters:\n\nGc::Float64: Critical energy release rate.\nepsilon_c::Float64: Critical strain.\n\nnote: Poisson's ratio and bond-based peridynamics\nIn bond-based peridynamics, the Poisson's ratio is limited to 1/4 for 3D simulations. Therefore, only one additional elastic parameter is required. Optionally, the specification of a second keyword is allowed, if the parameter combination results in nu = 1/4.\n\nAllowed export fields\n\nWhen specifying the fields keyword of Job for a Body with DHBBMaterial, the following fields are allowed:\n\nposition::Matrix{Float64}: Position of each point.\ndisplacement::Matrix{Float64}: Displacement of each point.\nvelocity::Matrix{Float64}: Velocity of each point.\nvelocity_half::Matrix{Float64}: Velocity parameter for Verlet time solver.\nacceleration::Matrix{Float64}: Acceleration of each point.\nb_int::Matrix{Float64}: Internal force density of each point.\nb_ext::Matrix{Float64}: External force density of each point.\ndamage::Vector{Float64}: Damage of each point.\nn_active_bonds::Vector{Int}: Number of intact bonds of each point.\n\n\n\n\n\n","category":"type"},{"location":"public_api_reference/#Peridynamics.OSBMaterial","page":"Public API","title":"Peridynamics.OSBMaterial","text":"OSBMaterial(; kernel, dmgmodel)\nOSBMaterial{Correction}(; kernel, dmgmodel)\n\nA material type used to assign the material of a Body with the ordinary state-based formulation of peridynamics.\n\nPossible correction methods are:\n\nNoCorrection: No correction is applied. (default)\nEnergySurfaceCorrection: The energy based surface correction method of   Le and Bobaru (2018) is applied.\n\nKeywords\n\nkernel::Function: Kernel function used for weighting the interactions between points. \n  (default: linear_kernel)\ndmgmodel::AbstractDamageModel: Damage model defining the damage behavior. \n  (default: CriticalStretch())\n\nExamples\n\njulia> mat = OSBMaterial()\nOSBMaterial{NoCorrection}(dmgmodel=CriticalStretch())\n\njulia> mat = OSBMaterial{EnergySurfaceCorrection}()\nOSBMaterial{EnergySurfaceCorrection}(dmgmodel=CriticalStretch())\n\n\n\nOSBMaterial{Correction,K,DM}\n\nMaterial type for the ordinary state-based peridynamics formulation.\n\nType Parameters\n\nCorrection: A correction algorithm type. See the constructor docs for more informations.\nK: A kernel function type. See the constructor docs for more informations.\nDM: A damage model type. See the constructor docs for more informations.\n\nFields\n\nkernel::Function: Kernel function used for weighting the interactions between points.\ndmgmodel::AbstractDamageModel: Damage model defining the damage behavior. See the   constructor docs for more informations.\n\nAllowed material parameters\n\nWhen using material! on a Body with OSBMaterial, then the following parameters are allowed: Material parameters:\n\nhorizon::Float64: Radius of point interactions.\nrho::Float64: Density.\n\nElastic parameters:\n\nE::Float64: Young's modulus.\nnu::Float64: Poisson's ratio.\nG::Float64: Shear modulus.\nK::Float64: Bulk modulus.\nlambda::Float64: 1st Lamé parameter.\nmu::Float64: 2nd Lamé parameter.\n\nFracture parameters:\n\nGc::Float64: Critical energy release rate.\nepsilon_c::Float64: Critical strain.\n\nnote: Elastic parameters\nNote that exactly two elastic parameters are required to specify a material. Please choose two out of the six allowed elastic parameters.\n\nAllowed export fields\n\nWhen specifying the fields keyword of Job for a Body with OSBMaterial, the following fields are allowed:\n\nposition::Matrix{Float64}: Position of each point.\ndisplacement::Matrix{Float64}: Displacement of each point.\nvelocity::Matrix{Float64}: Velocity of each point.\nvelocity_half::Matrix{Float64}: Velocity parameter for Verlet time solver.\nacceleration::Matrix{Float64}: Acceleration of each point.\nb_int::Matrix{Float64}: Internal force density of each point.\nb_ext::Matrix{Float64}: External force density of each point.\ndamage::Vector{Float64}: Damage of each point.\nn_active_bonds::Vector{Int}: Number of intact bonds of each point.\n\n\n\n\n\n","category":"type"},{"location":"public_api_reference/#Peridynamics.CMaterial","page":"Public API","title":"Peridynamics.CMaterial","text":"CMaterial(; kernel, model, zem, dmgmodel, maxdmg)\n\nA material type used to assign the material of a Body with the local continuum consistent (correspondence) formulation of non-ordinary state-based peridynamics.\n\nKeywords\n\nkernel::Function: Kernel function used for weighting the interactions between points. \n  (default: linear_kernel) \n  The following kernels can be used:\nlinear_kernel\ncubic_b_spline_kernel\nmodel::AbstractConstitutiveModel: Constitutive model defining the material behavior. \n  (default: LinearElastic()) \n  The following models can be used:\nLinearElastic\nNeoHooke\nMooneyRivlin\nSaintVenantKirchhoff\nzem::AbstractZEMStabilization: Algorithm of zero-energy mode stabilization. \n  (default: ZEMSilling) \n  The following algorithms can be used:\nZEMSilling\nZEMWan\ndmgmodel::AbstractDamageModel: Damage model defining the damage behavior. \n  (default: CriticalStretch)\nmaxdmg::Float64: Maximum value of damage a point is allowed to obtain. If this value is   exceeded, all bonds of that point are broken because the deformation gradient would then   possibly contain NaN values. \n  (default: 0.85)\n\nnote: Stability of fracture simulations\nThis formulation is known to be not suitable for fracture simulations without stabilization of the zero-energy modes. Therefore be careful when doing fracture simulations and try out different parameters for maxdmg and zem.\n\nExamples\n\njulia> mat = CMaterial()\nCMaterial{LinearElastic, ZEMSilling, typeof(linear_kernel), CriticalStretch}(maxdmg=0.85)\n\n\n\nCMaterial{CM,ZEM,K,DM}\n\nMaterial type for the local continuum consistent (correspondence) formulation of non-ordinary state-based peridynamics.\n\nType Parameters\n\nCM: A constitutive model type. See the constructor docs for more informations.\nZEM: A zero-energy mode stabilization type. See the constructor docs for more        informations.\nK: A kernel function type. See the constructor docs for more informations.\nDM: A damage model type. See the constructor docs for more informations.\n\nFields\n\nkernel::Function: Kernel function used for weighting the interactions between points.   See the constructor docs for more informations.\nmodel::AbstractConstitutiveModel: Constitutive model defining the material behavior. See   the constructor docs for more informations.\nzem::AbstractZEMStabilization: Zero-energy mode stabilization. See the constructor docs   for more informations.\ndmgmodel::AbstractDamageModel: Damage model defining the damage behavior. See the   constructor docs for more informations.\nmaxdmg::Float64: Maximum value of damage a point is allowed to obtain. See the   constructor docs for more informations.\n\nAllowed material parameters\n\nWhen using material! on a Body with CMaterial, then the following parameters are allowed: Material parameters:\n\nhorizon::Float64: Radius of point interactions.\nrho::Float64: Density.\n\nElastic parameters:\n\nE::Float64: Young's modulus.\nnu::Float64: Poisson's ratio.\nG::Float64: Shear modulus.\nK::Float64: Bulk modulus.\nlambda::Float64: 1st Lamé parameter.\nmu::Float64: 2nd Lamé parameter.\n\nFracture parameters:\n\nGc::Float64: Critical energy release rate.\nepsilon_c::Float64: Critical strain.\n\nnote: Elastic parameters\nNote that exactly two elastic parameters are required to specify a material. Please choose two out of the six allowed elastic parameters.\n\nAllowed export fields\n\nWhen specifying the fields keyword of Job for a Body with CMaterial, the following fields are allowed:\n\nposition::Matrix{Float64}: Position of each point.\ndisplacement::Matrix{Float64}: Displacement of each point.\nvelocity::Matrix{Float64}: Velocity of each point.\nvelocity_half::Matrix{Float64}: Velocity parameter for Verlet time solver.\nacceleration::Matrix{Float64}: Acceleration of each point.\nb_int::Matrix{Float64}: Internal force density of each point.\nb_ext::Matrix{Float64}: External force density of each point.\ndamage::Vector{Float64}: Damage of each point.\nn_active_bonds::Vector{Int}: Number of intact bonds of each point.\nstress::Matrix{Float64}: Stress tensor of each point.\nvon_mises_stress::Vector{Float64}: Von Mises stress of each point.\n\n\n\n\n\n","category":"type"},{"location":"public_api_reference/#Peridynamics.CRMaterial","page":"Public API","title":"Peridynamics.CRMaterial","text":"CRMaterial(; kernel, model, zem, dmgmodel, maxdmg)\n\nA material type used to assign the material of a Body with the local continuum consistent (correspondence) formulation of non-ordinary state-based peridynamics.\n\nKeywords\n\nkernel::Function: Kernel function used for weighting the interactions between points. \n  (default: linear_kernel) \n  The following kernels can be used:\nlinear_kernel\ncubic_b_spline_kernel\nmodel::AbstractConstitutiveModel: Constitutive model defining the material behavior. \n  (default: LinearElastic()) \n  Only the following model can be used:\nLinearElastic\nzem::AbstractZEMStabilization: Algorithm of zero-energy mode stabilization. \n  (default: ZEMSilling) \n  The following algorithms can be used:\nZEMSilling\nZEMWan\ndmgmodel::AbstractDamageModel: Damage model defining the damage behavior. \n  (default: CriticalStretch)\nmaxdmg::Float64: Maximum value of damage a point is allowed to obtain. If this value is   exceeded, all bonds of that point are broken because the deformation gradient would then   possibly contain NaN values. \n  (default: 0.85)\n\nnote: Stability of fracture simulations\nThis formulation is known to be not suitable for fracture simulations without stabilization of the zero-energy modes. Therefore be careful when doing fracture simulations and try out different parameters for maxdmg and zem.\n\nExamples\n\njulia> mat = CRMaterial()\nCRMaterial{LinearElastic, ZEMSilling, typeof(linear_kernel), CriticalStretch}(maxdmg=0.85)\n\n\n\nCRMaterial{CM,ZEM,K,DM}\n\nMaterial type for the local continuum consistent (correspondence) formulation of non-ordinary state-based peridynamics.\n\nType Parameters\n\nCM: A constitutive model type. See the constructor docs for more informations.\nZEM: A zero-energy mode stabilization type. See the constructor docs for more        informations.\nK: A kernel function type. See the constructor docs for more informations.\nDM: A damage model type. See the constructor docs for more informations.\n\nFields\n\nkernel::Function: Kernel function used for weighting the interactions between points.   See the constructor docs for more informations.\nmodel::AbstractConstitutiveModel: Constitutive model defining the material behavior. See   the constructor docs for more informations.\nzem::AbstractZEMStabilization: Zero-energy mode stabilization. See the constructor docs   for more informations.\ndmgmodel::AbstractDamageModel: Damage model defining the damage behavior. See the   constructor docs for more informations.\nmaxdmg::Float64: Maximum value of damage a point is allowed to obtain. See the   constructor docs for more informations.\n\nAllowed material parameters\n\nWhen using material! on a Body with CRMaterial, then the following parameters are allowed: Material parameters:\n\nhorizon::Float64: Radius of point interactions\nrho::Float64: Density\n\nElastic parameters:\n\nE::Float64: Young's modulus\nnu::Float64: Poisson's ratio\nG::Float64: Shear modulus\nK::Float64: Bulk modulus\nlambda::Float64: 1st Lamé parameter\nmu::Float64: 2nd Lamé parameter\n\nFracture parameters:\n\nGc::Float64: Critical energy release rate\nepsilon_c::Float64: Critical strain\n\nnote: Elastic parameters\nNote that exactly two elastic parameters are required to specify a material. Please choose two out of the six allowed elastic parameters.\n\nAllowed export fields\n\nWhen specifying the fields keyword of Job for a Body with CRMaterial, the following fields are allowed:\n\nposition::Matrix{Float64}: Position of each point\ndisplacement::Matrix{Float64}: Displacement of each point\nvelocity::Matrix{Float64}: Velocity of each point\nvelocity_half::Matrix{Float64}: Velocity parameter for Verlet time solver\nacceleration::Matrix{Float64}: Acceleration of each point\nb_int::Matrix{Float64}: Internal force density of each point\nb_ext::Matrix{Float64}: External force density of each point\ndamage::Vector{Float64}: Damage of each point\nn_active_bonds::Vector{Int}: Number of intact bonds of each point\nstress::Matrix{Float64}: Stress tensor of each point\nvon_mises_stress::Vector{Float64}: Von Mises stress of each point\n\n\n\n\n\n","category":"type"},{"location":"public_api_reference/#Peridynamics.BACMaterial","page":"Public API","title":"Peridynamics.BACMaterial","text":"BACMaterial(; kernel, model, dmgmodel, maxdmg)\n\nA material type used to assign the material of a Body with the bond-associated correspondence formulation of Chen and Spencer (2019).\n\nKeywords\n\nkernel::Function: Kernel function used for weighting the interactions between points.   (default: linear_kernel)\nmodel::AbstractConstitutiveModel: Constitutive model defining the material behavior.   (default: LinearElastic())\ndmgmodel::AbstractDamageModel: Damage model defining the fracture behavior.   (default: CriticalStretch())\nmaxdmg::Float64: Maximum value of damage a point is allowed to obtain. If this value is   exceeded, all bonds of that point are broken because the deformation gradient would then   possibly contain NaN values.   (default: 0.85)\n\nExamples\n\njulia> mat = BACMaterial()\nBACMaterial{LinearElastic, typeof(linear_kernel), CriticalStretch}()\n\n\n\nBACMaterial{CM,K,DM}\n\nMaterial type for the bond-associated correspondence formulation of Chen and Spencer (2019).\n\nType Parameters\n\nCM: A constitutive model type. See the constructor docs for more informations.\nK: A kernel function type. See the constructor docs for more informations.\nDM: A damage model type.\n\nFields\n\nkernel::Function: Kernel function used for weighting the interactions between points.\nmodel::AbstractConstitutiveModel: Constitutive model defining the material behavior.\ndmgmodel::AbstractDamageModel: Damage model defining the fracture behavior.\nmaxdmg::Float64: Maximum value of damage a point is allowed to obtain. See the   constructor docs for more informations.\n\nAllowed material parameters\n\nWhen using material! on a Body with BACMaterial, then the following parameters are allowed:\n\nhorizon::Float64: Radius of point interactions.\nrho::Float64: Density.\nE::Float64: Young's modulus.\nnu::Float64: Poisson's ratio.\nGc::Float64: Critical energy release rate.\nepsilon_c::Float64: Critical strain.\n\nAllowed export fields\n\nWhen specifying the fields keyword of Job for a Body with BACMaterial, the following fields are allowed:\n\nposition::Matrix{Float64}: Position of each point.\ndisplacement::Matrix{Float64}: Displacement of each point.\nvelocity::Matrix{Float64}: Velocity of each point.\nvelocity_half::Matrix{Float64}: Velocity parameter for Verlet time solver.\nacceleration::Matrix{Float64}: Acceleration of each point.\nb_int::Matrix{Float64}: Internal force density of each point.\nb_ext::Matrix{Float64}: External force density of each point.\ndamage::Vector{Float64}: Damage of each point.\nn_active_bonds::Vector{Int}: Number of intact bonds of each point.\n\n\n\n\n\n","category":"type"},{"location":"public_api_reference/#Peridynamics.CKIMaterial","page":"Public API","title":"Peridynamics.CKIMaterial","text":"CKIMaterial(; dmgmodel)\n\nA material type used to assign the material of a Body with the continuum-kinematics-inspired peridynamics formulation.\n\nKeywords\n\ndmgmodel::AbstractDamageModel: Damage model defining the damage behavior. \n  (default: CriticalStretch())\n\nExamples\n\njulia> mat = CKIMaterial()\nCKIMaterial(dmgmodel=CriticalStretch())\n\n\n\nCKIMaterial{DM}\n\nMaterial type for the continuum-kinematics-inspired peridynamics framework.\n\nType Parameters\n\nDM: A damage model type. See the constructor docs for more informations.\n\nFields\n\ndmgmodel::AbstractDamageModel: Damage model defining the damage behavior. See the   constructor docs for more informations.\n\nAllowed material parameters\n\nWhen using material! on a Body with CKIMaterial, then the following parameters are allowed: Material parameters:\n\nhorizon::Float64: Radius of point interactions.\nrho::Float64: Density.\n\nElastic parameters:\n\nE::Float64: Young's modulus.\nnu::Float64: Poisson's ratio.\nG::Float64: Shear modulus.\nK::Float64: Bulk modulus.\nlambda::Float64: 1st Lamé parameter.\nmu::Float64: 2nd Lamé parameter.\n\nFracture parameters:\n\nGc::Float64: Critical energy release rate.\nepsilon_c::Float64: Critical strain.\n\nInteraction parameters:\n\nC1::Float64: One-neighbor interaction parameter. (default: 0.0)\nC2::Float64: Two-neighbor interaction parameter. (default: 0.0)\nC3::Float64: Two-neighbor interaction parameter. (default: 0.0)\n\nwarning: Specification of interaction parameters\nIf any of the interaction parameters is used with material!, the Young's modulus and Poisson's ratio are ignored and only the specified interaction parameters will influence the force density calculated from that interaction.If no interaction parameter is specified, then the Young's modulus and Poisson's ratio are used to calculate these parameters accordingly to Ekiz, Steinmann, and Javili (2022).\n\nnote: Elastic parameters\nNote that exactly two elastic parameters are required to specify a material. Please choose two out of the six allowed elastic parameters.\n\nAllowed export fields\n\nWhen specifying the fields keyword of Job for a Body with CKIMaterial, the following fields are allowed:\n\nposition::Matrix{Float64}: Position of each point.\ndisplacement::Matrix{Float64}: Displacement of each point.\nvelocity::Matrix{Float64}: Velocity of each point.\nvelocity_half::Matrix{Float64}: Velocity parameter for Verlet time solver.\nacceleration::Matrix{Float64}: Acceleration of each point.\nb_int::Matrix{Float64}: Internal force density of each point.\nb_ext::Matrix{Float64}: External force density of each point.\ndamage::Vector{Float64}: Damage of each point.\nn_active_one_nis::Vector{Int}: Number of intact one-neighbor interactions of each point.\n\n\n\n\n\n","category":"type"},{"location":"public_api_reference/#System-or-material-related-types","page":"Public API","title":"System or material related types","text":"","category":"section"},{"location":"public_api_reference/#Peridynamics.CriticalStretch","page":"Public API","title":"Peridynamics.CriticalStretch","text":"CriticalStretch\n\nA damage model based on the stretch of the bond. The bond is considered to be broken if the stretch exceeds a critical value. The critical value can be defined via the fracture energy Gc or the critical stretch εc using the material! function. The damage model is defined globally for the whole body as part of the material.\n\n\n\n\n\n","category":"type"},{"location":"public_api_reference/#Peridynamics.NoCorrection","page":"Public API","title":"Peridynamics.NoCorrection","text":"NoCorrection\n\nA correction handler for materials that use the bond system. If NoCorrection is used, then no correction will be applied.\n\nSee also BBMaterial, OSBMaterial for further information on how to use the correction type.\n\n\n\n\n\n","category":"type"},{"location":"public_api_reference/#Peridynamics.EnergySurfaceCorrection","page":"Public API","title":"Peridynamics.EnergySurfaceCorrection","text":"EnergySurfaceCorrection\n\nA correction handler for materials that use the bond system. If EnergySurfaceCorrection is used, then the energy based surface correction method of Le and Bobaru (2018) is used.\n\nSee also BBMaterial, OSBMaterial for further information on how to use the correction type.\n\n\n\n\n\n","category":"type"},{"location":"public_api_reference/#Peridynamics.ZEMSilling","page":"Public API","title":"Peridynamics.ZEMSilling","text":"ZEMSilling(; Cs)\n\nZero-energy mode stabilization algorithm of Silling (2017). This is necessary for the correspondence formulation to stabilize the zero-energy modes. See also CMaterial on how to use this stabilization algorithm.\n\nKeywords\n\nCs::Real: Stabilization factor. (default: 100.0)\n\n\n\n\n\n","category":"type"},{"location":"public_api_reference/#Peridynamics.ZEMWan","page":"Public API","title":"Peridynamics.ZEMWan","text":"ZEMWan()\n\nZero-energy mode stabilization algorithm of Wan et al. (2019), which is an improvement to Silling's algorithm that does not require a stabilization parameter. See also CMaterial on how to use this stabilization algorithm.\n\n\n\n\n\n","category":"type"},{"location":"public_api_reference/#Peridynamics.LinearElastic","page":"Public API","title":"Peridynamics.LinearElastic","text":"LinearElastic\n\nLinear elastic constitutive model that can be specified when using a CMaterial and BACMaterial. The first Piola-Kirchhoff stress boldsymbolP is given by\n\nboldsymbolP = mathbbC  boldsymbolE  \n\nwith the elastic stiffness tensor  mathbbC and the Green-Lagrange strain tensor boldsymbolE with\n\nboldsymbolE = frac12 left( boldsymbolF^top boldsymbolF - boldsymbolI\n                             right)  \n\n\n\n\n\n","category":"type"},{"location":"public_api_reference/#Peridynamics.NeoHooke","page":"Public API","title":"Peridynamics.NeoHooke","text":"NeoHooke\n\nNeo-Hookean constitutive model that can be specified when using a CMaterial and BACMaterial. The first Piola-Kirchhoff stress boldsymbolP is given by\n\nbeginaligned\nboldsymbolC = boldsymbolF^top boldsymbolF   \nboldsymbolS = mu left( boldsymbolI - boldsymbolC^-1 right)\n    + lambda log(J) boldsymbolC^-1   \nboldsymbolP = boldsymbolF  boldsymbolS  \nendaligned\n\nwith the deformation gradient boldsymbolF, the right Cauchy-Green deformation tensor boldsymbolC, the Jacobian J = mathrmdet(boldsymbolF), the second Piola-Kirchhoff stress boldsymbolS, and the first and second Lamé parameters lambda and mu.\n\n\n\n\n\n","category":"type"},{"location":"public_api_reference/#Peridynamics.MooneyRivlin","page":"Public API","title":"Peridynamics.MooneyRivlin","text":"MooneyRivlin\n\nMooney-Rivlin constitutive model that can be specified when using a CMaterial and BACMaterial. The first Piola-Kirchhoff stress boldsymbolP is given by\n\nbeginaligned\nboldsymbolC = boldsymbolF^top boldsymbolF   \nboldsymbolS = G left( boldsymbolI - frac13 mathrmtr(boldsymbolC)\n                           boldsymbolC^-1 right) cdot J^-frac23\n                + fracK4 left( J^2 - J^-2 right) boldsymbolC^-1   \nboldsymbolP = boldsymbolF  boldsymbolS  \nendaligned\n\nwith the deformation gradient boldsymbolF, the right Cauchy-Green deformation tensor boldsymbolC, the Jacobian J = mathrmdet(boldsymbolF), the second Piola-Kirchhoff stress boldsymbolS, the shear modulus G, and the bulk modulus K.\n\nError handling\n\nIf the Jacobian J is smaller than the machine precision eps() or a NaN, the first Piola-Kirchhoff stress tensor is defined as boldsymbolP = boldsymbol0.\n\n\n\n\n\n","category":"type"},{"location":"public_api_reference/#Peridynamics.SaintVenantKirchhoff","page":"Public API","title":"Peridynamics.SaintVenantKirchhoff","text":"SaintVenantKirchhoff\n\nSaint-Venant-Kirchhoff constitutive model that can be specified when using a CMaterial and BACMaterial. The first Piola-Kirchhoff stress boldsymbolP is given by\n\nbeginaligned\nboldsymbolE = frac12 left( boldsymbolF^top boldsymbolF - boldsymbolI\n                              right)   \nboldsymbolS = lambda  mathrmtr(boldsymbolE)  boldsymbolI\n                + 2 mu boldsymbolE   \nboldsymbolP = boldsymbolF  boldsymbolS  \nendaligned\n\nwith the deformation gradient boldsymbolF, the Green-Lagrange strain tensor boldsymbolE, the second Piola-Kirchhoff stress boldsymbolS, and the first and second Lamé parameters lambda and mu.\n\n\n\n\n\n","category":"type"},{"location":"public_api_reference/#Peridynamics.linear_kernel","page":"Public API","title":"Peridynamics.linear_kernel","text":"linear_kernel(δ, L)\n\nA linear kernel function omega (also called influence function) used for weighting the bonds in a family. The kernel function is defined as\n\nomega = fracdeltaL  \n\nwith the horizon delta and the initial bond length L.\n\n\n\n\n\n","category":"function"},{"location":"public_api_reference/#Peridynamics.cubic_b_spline_kernel","page":"Public API","title":"Peridynamics.cubic_b_spline_kernel","text":"cubic_b_spline_kernel(δ, L)\n\nA cubic B-spline kernel function omega used for weighting the bonds in a family. The kernel function is defined as\n\nbeginaligned\nxi = fracLdelta   \nomega = left\n    beginarrayll\n        frac23 - 4 xi^2 + 4 xi^3  quad textif  0  xi leq 05   3pt\n        frac43 - 4 xi + 4 xi^2 - frac43 xi^3  quad textif  05  xi leq 1   3pt\n        0  quad textelse  \n    endarray\n    right\nendaligned\n\nwith the horizon delta and the initial bond length L.\n\n\n\n\n\n","category":"function"},{"location":"public_api_reference/#Discretization","page":"Public API","title":"Discretization","text":"","category":"section"},{"location":"public_api_reference/#Peridynamics.Body","page":"Public API","title":"Peridynamics.Body","text":"Body(material, position, volume)\nBody(material, inp_file)\n\nConstruct a Body for a peridynamics simulation.\n\nArguments\n\nmaterial::AbstractMaterial: The material which is defined for the whole body.   Available material models:\nBBMaterial: Bond-based peridynamics\nOSBMaterial: Ordinary state-based peridynamics\nCMaterial: Correspondence formulation\nBACMaterial: Bond-associated correspondence formulation of Chen and Spencer\nCKIMaterial: Continuum-kinematics-inspired peridynamics\nposition::AbstractMatrix: A 3×n matrix with the point position of the n points.\nvolume::AbstractVector: A vector with the volume of each point.\ninp_file::AbstractString: An Abaqus input file containing meshes, imported with   read_inp.\n\nThrows\n\nError if the number of points is not larger than zero.\nError if position is not a 3×n matrix and has the same length as volume.\nError if position or volume contain NaN values.\n\nExample\n\njulia> Body(BBMaterial(), rand(3, 10), rand(10))\n10-point Body{BBMaterial{NoCorrection}}:\n  1 point set(s):\n    10-point set `all_points`\n\n\n\nwarning: Internal use only\nPlease note that the fields are intended for internal use only. They are not part of the public API of Peridynamics.jl, and thus can be altered (or removed) at any time without it being considered a breaking change.\n\nBody{Material,PointParameters}\n\nType Parameters\n\nMaterial <: AbstractMaterial: Type of the specified material model.\nPointParameters <: AbstractPointParameters: Type of the point parameters.\n\nFields\n\nmat::Material: The material formulation.\nn_points::Int: The number of points that in the body.\nposition::Matrix{Float64}: A 3×n_points matrix with the position of the points.\nvolume::Vector{Float64}: A vector with the volume of each point.\nfail_permit::Vector{Bool}: A vector that describes if failure is allowed for each point.\npoint_sets::Dict{Symbol,Vector{Int}}: A dictionary containing point sets.\npoint_params::Vector{PointParameters}: A vector containing all different point parameter   instances of the body. Each point can have its own PointParameters instance.\nparams_map::Vector{Int}: A vector that maps each point index to a parameter instance in   point_params.\nsingle_dim_bcs::Vector{SingleDimBC}: A vector with boundary conditions on a single   dimension.\nposdep_single_dim_bcs::Vector{PosDepSingleDimBC}: A vector with position dependent   boundary conditions on a single dimension.\nsingle_dim_ics::Vector{SingleDimIC}: A vector with initial conditions on a single   dimension.\nposdep_single_dim_ics::Vector{PosDepSingleDimIC}: A vector with position dependent   initial conditions on a single dimension.\ndata_bcs::Vector{DataBC}: A vector with data boundary conditions.\npoint_sets_precracks::Vector{PointSetsPreCrack}: A vector with predefined point set   cracks.\n\n\n\n\n\n","category":"type"},{"location":"public_api_reference/#Peridynamics.MultibodySetup","page":"Public API","title":"Peridynamics.MultibodySetup","text":"MultibodySetup(body_pairs...)\n\nSetup for a peridynamic simulation with multiple bodies.\n\nArguments\n\nbody_pairs::Pair{Symbol,<:AbstractBody}: Pairs of :body_name => body_object.   The name of the body has to be specified as a Symbol.\n\nThrows\n\nError if less than 2 bodies are defined.\n\nExamples\n\njulia> sphere = Body(BBMaterial(), pos_sphere, vol_sphere)\n280-point Body{BBMaterial{NoCorrection}}:\n  1 point set(s):\n    280-point set `all_points`\n\njulia> plate = Body(BBMaterial(), pos_plate, vol_plate)\n25600-point Body{BBMaterial{NoCorrection}}:\n  1 point set(s):\n    25600-point set `all_points`\n\njulia> ms = MultibodySetup(:sphere => sphere, :plate => plate)\n25880-point MultibodySetup:\n  280-point Body{BBMaterial{NoCorrection}} with name `sphere`\n  25600-point Body{BBMaterial{NoCorrection}} with name `plate`\n\n\n\nwarning: Internal use only\nPlease note that the fields are intended for internal use only. They are not part of the public API of Peridynamics.jl, and thus can be altered (or removed) at any time without it being considered a breaking change.\n\nMultibodySetup{Bodies}\n\nType Parameters\n\nBodies <: Tuple: All types of the different bodies in the multibody setup.\n\nFields\n\nbodies::Bodies: A Tuple containing all the bodies.\nbody_names::Vector{Symbol}: All body names.\nbody_idxs::Dict{Symbol,Int}: A Dict to get the body index with the body name.\nsrf_contacts::Vector{ShortRangeForceContact}: All short range force contacts.\n\n\n\n\n\n","category":"type"},{"location":"public_api_reference/#Peridynamics.point_set!","page":"Public API","title":"Peridynamics.point_set!","text":"point_set!(body, set_name, points)\npoint_set!(fun, body, set_name)\n\nAdd a point set to a Body. The points of the set can be either specified directly with the points::AbstractVector argument, or as the result of the filter function fun. By default, a body already contains a point set with the name :all_points, containg a set with all points.\n\nArguments\n\nbody::AbstractBody: Body where the set will be added.\nset_name::Symbol: Name of the point set.\npoints::AbstractVector: Some vector containing the point indices of the set.   The indices have to be in bounds with the position and volume of body.\nfun::Function: Function for filtering points. This function accepts only one positional   argument and will be used in a findall call. Depending on the argument name,   a different input will be processed:\nx: The function will receive the x-coordinate of each point in position of body:\npoints = findall(fun, @view(position[1, :]))\ny: The function will receive the y-coordinate of each point in position of body:\npoints = findall(fun, @view(position[2, :]))\nz: The function will receive the z-coordinate of each point in position of body:\npoints = findall(fun, @view(position[3, :]))\np: The function will receive the a vector containing each dimension of each point in position of body:\npoints = findall(fun, eachcol(position))\n\nThrows\n\nError if a point set with the same set_name already exists.\nError if points are not in bounds with position and volume of the body.\n\nExamples\n\nAdd a point set to body with all points that have a x-corrdinate larger than zero:\n\njulia> point_set!(x -> x > 0, body, :larger_than_zero)\n\njulia> point_sets(body)\nDict{Symbol, Vector{Int64}} with 2 entries:\n  :larger_than_zero => [6, 7, 8, 9, 10, 16, 17, 18, 19, 20  …  9…\n  :all_points       => [1, 2, 3, 4, 5, 6, 7, 8, 9, 10  …  991, 9…\n\nAdd a point set to body with all points that are positioned inside a sphere with radius r around the center. Note that the do-syntax can be used, as fun is the first argument of point_set!:\n\njulia> point_set!(body, :inside_sphere) do p\n           sqrt(p[1]^2 + p[2]^2 + p[3]^2) ≤ r\n       end\n\njulia> point_sets(body)\nDict{Symbol, Vector{Int64}} with 2 entries:\n  :larger_than_zero => [6, 7, 8, 9, 10, 16, 17, 18, 19, 20  …  9…\n  :inside_sphere    => [1, 2, 3, 4, 5, 6, 7, 8, 9, 10  …  991, 9…\n\n\n\n\n\n","category":"function"},{"location":"public_api_reference/#Peridynamics.point_sets","page":"Public API","title":"Peridynamics.point_sets","text":"point_sets(body)\n\nReturn all point sets of body.\n\nArguments\n\nbody::AbstractBody: Body.\n\nExample\n\njulia> body = Body(BBMaterial(), rand(3,100), rand(100))\n100-point Body{BBMaterial{NoCorrection}}:\n  100-point set `all_points`\n\njulia> point_set!(body, :set_a, 1:10) # first ten points\n\njulia> Peridynamics.point_sets(body)\nDict{Symbol, Vector{Int64}} with 2 entries:\n  :all_points => [1, 2, 3, 4, 5, 6, 7, 8, 9, 10  …  91, 92, 93, 94, 95, 96, 97, 98, 9…\n  :set_a      => [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n\n\n\n\n\n","category":"function"},{"location":"public_api_reference/#Peridynamics.no_failure!","page":"Public API","title":"Peridynamics.no_failure!","text":"no_failure!(body::AbstractBody, set_name::Symbol)\nno_failure!(body::AbstractBody)\n\nDisallow failure for all points of the point set set_name of the body. If no set_name is specified, failure is prohibited for the whole body.\n\nArguments\n\nbody::AbstractBody: Body for which failure is prohibited.\nset_name::Symbol: The name of a point set of this body.\n\ndanger: Overwriting failure permission with `material!` and `no_failure!`\nThe function material! sets failure permissions due to the provided input parameters, so if it is used afterwards, previously set failure prohibitions might be overwritten!\n\nThrows\n\nError if the body does not contain a set with set_name.\n\nExamples\n\njulia> no_failure!(body)\n\njulia> body\n1000-point Body{BBMaterial{NoCorrection}}:\n  1 point set(s):\n    1000-point set `all_points`\n  1000 points with failure prohibited\n\n\n\n\n\n","category":"function"},{"location":"public_api_reference/#Peridynamics.material!","page":"Public API","title":"Peridynamics.material!","text":"material!(body, set_name; kwargs...)\nmaterial!(body; kwargs...)\n\nAssign material point parameters to points of body. If no set_name is specified, then the parameters will be set for all points of the body.\n\nArguments\n\nbody::AbstractBody: Body.\nset_name::Symbol: The name of a point set of this body.\n\nKeywords\n\nAllowed keywords depend on the selected material model. Please look at the documentation of the material you specified when creating the body. The default material keywords are:\n\nMaterial parameters:\n\nhorizon::Float64: Radius of point interactions.\nrho::Float64: Density.\n\nElastic parameters:\n\nE::Float64: Young's modulus.\nnu::Float64: Poisson's ratio.\nG::Float64: Shear modulus.\nK::Float64: Bulk modulus.\nlambda::Float64: 1st Lamé parameter.\nmu::Float64: 2nd Lamé parameter.\n\nFracture parameters:\n\nGc::Float64: Critical energy release rate.\nepsilon_c::Float64: Critical strain.\n\nnote: Elastic parameters\nNote that exactly two elastic parameters are required to specify a material.\n\nnote: Fracture parameters\nTo enable fracture in a simulation, define one of the allowed fracture parameters. If none are defined, fracture is disabled.\n\nThrows\n\nError if a kwarg is not eligible for specification with the body material.\n\nExample\n\njulia> material!(body; horizon=3.0, E=2.1e5, rho=8e-6, Gc=2.7)\n\njulia> body\n1000-point Body{BBMaterial{NoCorrection}}:\n  1 point set(s):\n    1000-point set `all_points`\n  1 point parameter(s):\n    Parameters BBMaterial: δ=3.0, E=210000.0, nu=0.25, rho=8.0e-6, Gc=2.7\n\n\n\n\n\n","category":"function"},{"location":"public_api_reference/#Peridynamics.velocity_bc!","page":"Public API","title":"Peridynamics.velocity_bc!","text":"velocity_bc!(fun, body, set_name, dim)\n\nSpecify velocity boundary condition for points of the set set_name in body. The value of the boundary condition is calculated with the function fun at every time step.\n\nArguments\n\nfun::Function: Condition function for the calculation of a value, should return a   Float64. If the condition function returns a NaN, then this value is ignored, which   can be used to turn conditions off after a specified period of time. This function   accepts one ore two positional arguments and is aware of the argument names.   Possible arguments and names:\nfun(t): The function will receive the current time t at every time step.   This makes it possible to specify conditions that change over time.\nfun(p, t): This function will be processed for every point of set_name and   receives the reference position of a point as SVector{3} and the current time t   at every time step. This makes it possible to specify conditions that   also depend on the position of a point.\nbody::AbstractBody: Body the condition is specified on.\nset_name::Symbol: The name of a point set of this body.\ndim::Union{Integer,Symbol}: Direction of the condition, either specified as Symbol or   integer.\nx-direction: :x or 1\ny-direction: :y or 2\nz-direction: :z or 3\n\nThrows\n\nError if the body does not contain a set with set_name.\nError if the direction is not correctly specified.\nError if function is not suitable as condition function and has the wrong arguments.\n\nExample\n\njulia> velocity_bc!(t -> 2.0, body, :all_points, 1)\n\njulia> velocity_bc!((p,t) -> p[1] * t, body, :all_points, :y)\n\njulia> velocity_bc!(t -> t > 0.00001 ? 1.0 : NaN, body, :all_points, :z)\n\njulia> body\n1000-point Body{BBMaterial{NoCorrection}}:\n  1 point set(s):\n    1000-point set `all_points`\n  3 boundary condition(s):\n    BC on velocity: point_set=all_points, dim=1\n    BC on velocity: point_set=all_points, dim=3\n    Pos.-dep. BC on velocity: point_set=all_points, dim=2\n\n\n\n\n\n","category":"function"},{"location":"public_api_reference/#Peridynamics.velocity_ic!","page":"Public API","title":"Peridynamics.velocity_ic!","text":"velocity_ic!(body, set_name, dim, value)\nvelocity_ic!(fun, body, set_name, dim)\n\nSpecify velocity initial condition for points of the set set_name in body. The value of the initial condition is specified before time integration. If a function fun is specified, then the value is with that function.\n\nArguments\n\nbody::AbstractBody: Body the condition is specified on.\nset_name::Symbol: The name of a point set of this body.\ndim::Union{Integer,Symbol}: Direction of the condition, either specified as Symbol or   integer.\nx-direction: :x or 1\ny-direction: :y or 2\nz-direction: :z or 3\nvalue::Real: Value that is specified before time integration.\nfun::Function: Condition function for the calculation of a value, should return a   Float64. If the condition function returns a NaN, then this value is ignored, which   can be used to turn off the condition for a specified position. This function   accepts one ore two positional arguments and is aware of the argument names.   Possible arguments and names:\nfun(p): The function will receive the reference position p of a point as   SVector{3}.\n\nThrows\n\nError if the body does not contain a set with set_name.\nError if the direction is not correctly specified.\nError if function is not suitable as condition function and has the wrong arguments.\n\nExample\n\njulia> velocity_ic!(body, :all_points, :x, -100.0)\n\njulia> body\n1000-point Body{BBMaterial{NoCorrection}}:\n  1 point set(s):\n    1000-point set `all_points`\n  1 initial condition(s):\n    IC on velocity: point_set=all_points, dim=1\n\n\n\n\n\n","category":"function"},{"location":"public_api_reference/#Peridynamics.forcedensity_bc!","page":"Public API","title":"Peridynamics.forcedensity_bc!","text":"forcedensity_bc!(fun, body, set, dim)\n\nSpecify force density boundary condition for points of the set set_name in body. The value of the boundary condition is calculated with the function fun at every time step.\n\nArguments\n\nfun::Function: Condition function for the calculation of a value, should return a   Float64. If the condition function returns a NaN, then this value is ignored, which   can be used to turn conditions off after a specified period of time. This function   accepts one ore two positional arguments and is aware of the argument names.   Possible arguments and names:\nfun(t): The function will receive the current time t at every time step.   This makes it possible to specify conditions that change over time.\nfun(p, t): This function will be processed for every point of set_name and   receives the reference position of a point as SVector{3} and the current time t   at every time step. This makes it possible to specify conditions that   also depend on the position of a point.\nbody::AbstractBody: Body the condition is specified on.\nset_name::Symbol: The name of a point set of this body.\ndim::Union{Integer,Symbol}: Direction of the condition, either specified as Symbol or   integer.\nx-direction: :x or 1\ny-direction: :y or 2\nz-direction: :z or 3\n\nThrows\n\nError if the body does not contain a set with set_name.\nError if the direction is not correctly specified.\nError if function is not suitable as condition function and has the wrong arguments.\n\nExample\n\njulia> forcedensity_bc!(t -> 8000.0, body, :all_points, :x)\n\njulia> forcedensity_bc!((p,t) -> p[1] * t, body, :all_points, :y)\n\njulia> forcedensity_bc!(t -> t > 0.00001 ? 8000.0 : NaN, body, :all_points, :z)\n\njulia> body\n1000-point Body{BBMaterial{NoCorrection}}:\n  1 point set(s):\n    1000-point set `all_points`\n  3 boundary condition(s):\n    BC on force density: point_set=all_points, dim=1\n    BC on force density: point_set=all_points, dim=3\n    Pos.-dep. BC on force density: point_set=all_points, dim=2\n\n\n\n\n\n","category":"function"},{"location":"public_api_reference/#Peridynamics.precrack!","page":"Public API","title":"Peridynamics.precrack!","text":"precrack!(body, set_a, set_b; update_dmg=true)\n\nCreate a crack between two point sets by prohibiting interaction between points of different point sets. The points in set_a are not allowed to interact with points in set_b.\n\nArguments\n\nbody::AbstractBody: Body.\nset_a::Symbol: The name of a point set of this body.\nset_b::Symbol: The name of a point set of this body.\n\nKeywords\n\nupdate_dmg::Bool: If true, the material points involved in the predefined crack are   initially damaged. If false, the bonds involved are deleted and the material points   involved with the predefined crack are not damaged in the reference results.   (default: true)\n\nThrows\n\nError if the body does not contain sets with name set_a and set_b.\nError if the point sets intersect and a point is included in both sets.\n\nExample\n\njulia> point_set!(body, :a, 1:2)\n\njulia> point_set!(body, :b, 3:4)\n\njulia> precrack!(body, :a, :b)\n\njulia> body\n1000-point Body{BBMaterial{NoCorrection}}:\n  3 point set(s):\n    1000-point set `all_points`\n    2-point set `a`\n    2-point set `b`\n  1 predefined crack(s)\n\n\n\n\n\n","category":"function"},{"location":"public_api_reference/#Peridynamics.contact!","page":"Public API","title":"Peridynamics.contact!","text":"contact!(multibody_setup, name_body_a, name_body_b; kwargs...)\n\nDefine a short range force contact between body name_body_a and name_body_b in the MultibodySetup multibody_setup.\n\nArguments\n\nmultibody_setup::MultibodySetup: MultibodySetup.\nname_body_a::Symbol: The name of a body in this multibody setup.\nname_body_b::Symbol: The name of a body in this multibody setup.\n\nKeywords\n\nradius::Float64: Contact search radius. If a the distance of a point in body   name_body_a and a point in body name_body_b is lower than this radius, a contact   force is calculated. This radius should be in the order of the point spacing of a   point cloud.\npenalty_factor::Float64: Penalty factor for the short range force contact algorithm.   (default: 1e12)\n\nThrows\n\nError if multibody_setup does not contain bodies with name name_body_a and   name_body_b.\nError if the keyword radius is not specified or radius ≤ 0.\nError if penalty_factor ≤ 0.\n\nExamples\n\njulia> ms = MultibodySetup(:a => body_a, :b => body_b)\n2000-point MultibodySetup:\n  1000-point Body{BBMaterial{NoCorrection}} with name `b`\n  1000-point Body{BBMaterial{NoCorrection}} with name `b`\n\njulia> contact!(ms, :a, :b; radius=0.001)\n\njulia> ms\n2000-point MultibodySetup:\n  1000-point Body{BBMaterial{NoCorrection}} with name `b`\n  1000-point Body{BBMaterial{NoCorrection}} with name `b`\n  2 short range force contact(s)\n\n\n\n\n\n","category":"function"},{"location":"public_api_reference/#Peridynamics.uniform_box","page":"Public API","title":"Peridynamics.uniform_box","text":"uniform_box(lx, ly, lz, ΔX0; kwargs...)\n\nCreate a grid of uniformly distributed points in a cuboid with lengths lx, ly and lz and point spacing ΔX0.\n\nArguments\n\nlx::Real: Length in x-dimension.\nly::Real: Length in y-dimension.\nlz::Real: Length in z-dimension.\nΔX0::Real: Spacing of the points.\n\nKeywords\n\ncenter: The coordinates of the center of the cuboid. Default: (0, 0, 0)\n\nReturns\n\nposition::Matrix{Float64}: A 3×n_points matrix with the position of the points.\nvolume::Vector{Float64}: A vector with the volume of each point.\n\nExamples\n\njulia> position, volume = uniform_box(10, 10, 10, 2);\n\njulia> position\n3×125 Matrix{Float64}:\n -4.0  -2.0   0.0   2.0   4.0  -4.0  -2.0  …  0.0  2.0  4.0  -4.0  -2.0  0.0  2.0  4.0\n -4.0  -4.0  -4.0  -4.0  -4.0  -2.0  -2.0     2.0  2.0  2.0   4.0   4.0  4.0  4.0  4.0\n -4.0  -4.0  -4.0  -4.0  -4.0  -4.0  -4.0     4.0  4.0  4.0   4.0   4.0  4.0  4.0  4.0\n\njulia> volume\n125-element Vector{Int64}:\n 8\n 8\n 8\n 8\n ⋮\n 8\n 8\n 8\n 8\n\n\n\n\n\n","category":"function"},{"location":"public_api_reference/#Peridynamics.uniform_sphere","page":"Public API","title":"Peridynamics.uniform_sphere","text":"uniform_sphere(diameter, ΔX0; kwargs...)\n\nCreate a grid of uniformly distributed points in a sphere with a specific diameter and the point spacing ΔX0. Due to the uniform point spacings, edges on the surface of the sphere can occur.\n\nArguments\n\ndiameter::Real: Diameter of the sphere.\nΔX0::Real: Spacing of the points.\n\nKeywords\n\ncenter: The coordinates of the center of the sphere. Default: (0, 0, 0)\n\nReturns\n\nposition::Matrix{Float64}: A 3×n_points matrix with the position of the points.\nvolume::Vector{Float64}: A vector with the volume of each point.\n\nExamples\n\njulia> position, volume = uniform_sphere(10, 2);\n\njulia> position\n3×81 Matrix{Float64}:\n -2.0   0.0   2.0  -2.0   0.0   2.0  -2.0  …   0.0   2.0  -2.0  0.0  2.0  -2.0  0.0  2.0\n -2.0  -2.0  -2.0   0.0   0.0   0.0   2.0     -2.0  -2.0   0.0  0.0  0.0   2.0  2.0  2.0\n -4.0  -4.0  -4.0  -4.0  -4.0  -4.0  -4.0      4.0   4.0   4.0  4.0  4.0   4.0  4.0  4.0\n\njulia> volume\n81-element Vector{Int64}:\n 8\n 8\n 8\n 8\n 8\n ⋮\n 8\n 8\n 8\n 8\n 8\n\n\n\n\n\n","category":"function"},{"location":"public_api_reference/#Peridynamics.uniform_cylinder","page":"Public API","title":"Peridynamics.uniform_cylinder","text":"uniform_cylinder(diameter::Real, height::Real, ΔX0::Real; kwargs...)\n\nCreate a grid of uniformly distributed points in a cylindrical shape with a specific height in z-dimension, a diameter and the point spacing ΔX0. Due to the uniform point spacings, edges on the surface of the cylinder can occur.\n\nArguments\n\ndiameter::Real: Diameter of the cylinder.\nheight::Real: Height of the cylinder.\nΔX0::Real: Spacing of the points.\n\nKeywords\n\ncenter: The coordinates of the center of the cylinder. Default: (0, 0, 0)\n\nReturns\n\nposition::Matrix{Float64}: A 3×n_points matrix with the position of the points.\nvolume::Vector{Float64}: A vector with the volume of each point.\n\nExamples\n\njulia> position, volume = uniform_cylinder(5, 10, 2);\n\njulia> position\n3×20 Matrix{Float64}:\n -1.0   1.0  -1.0   1.0  -1.0   1.0  -1.0  …   1.0  -1.0  1.0  -1.0   1.0  -1.0  1.0\n -1.0  -1.0   1.0   1.0  -1.0  -1.0   1.0     -1.0   1.0  1.0  -1.0  -1.0   1.0  1.0\n -4.0  -4.0  -4.0  -4.0  -2.0  -2.0  -2.0      2.0   2.0  2.0   4.0   4.0   4.0  4.0\n\njulia> volume\n20-element Vector{Int64}:\n 8\n 8\n 8\n 8\n 8\n ⋮\n 8\n 8\n 8\n 8\n 8\n\n\n\n\n\n","category":"function"},{"location":"public_api_reference/#Peridynamics.round_sphere","page":"Public API","title":"Peridynamics.round_sphere","text":"round_sphere(diameter, ΔX0; kwargs...)\n\nCreate a grid of points distributed in a smooth sphere without edges on the surface with a specific diameter and the point spacing ΔX0. Internally, some parts of TrixiParticles.jl were copied and adapted for this function.\n\nArguments\n\ndiameter::Real: Diameter of the sphere.\nΔX0::Real: Spacing of the points.\n\nKeywords\n\ncenter: The coordinates of the center of the sphere. Default: (0, 0, 0)\n\nReturns\n\nposition::Matrix{Float64}: A 3×n_points matrix with the position of the points.\nvolume::Vector{Float64}: A vector with the volume of each point.\n\nExamples\n\njulia> position, volume = round_sphere(10, 2);\n\njulia> position\n3×63 Matrix{Float64}:\n 0.0  1.74586  0.539501  -1.41243  -1.41243  …  -1.95518   -0.48289   1.35303   0.0\n 0.0  0.0      1.66041    1.02619  -1.02619     -0.941566  -2.11568  -1.69664   0.0\n 2.0  0.97569  0.97569    0.97569   0.97569     -3.36017   -3.36017  -3.36017  -4.0\n\njulia> volume\n63-element Vector{Float64}:\n 8.311091676163475\n 8.311091676163475\n 8.311091676163475\n 8.311091676163475\n 8.311091676163475\n ⋮\n 8.311091676163475\n 8.311091676163475\n 8.311091676163475\n 8.311091676163475\n\n\n\n\n\n","category":"function"},{"location":"public_api_reference/#Peridynamics.round_cylinder","page":"Public API","title":"Peridynamics.round_cylinder","text":"round_cylinder(diameter::Real, height::Real, ΔX0::Real; kwargs...)\n\nCreate a grid of  points distributed in a cylindrical shape with a specific height in z-dimension, a diameter and the point spacing ΔX0. Due to a concentric point distribution in the x-y-plane, there are no sharp edges that appear on the surface of the cylinder.\n\nArguments\n\ndiameter::Real: Diameter of the cylinder.\nheight::Real: Height of the cylinder.\nΔX0::Real: Spacing of the points.\n\nKeywords\n\ncenter: The coordinates of the center of the cylinder. Default: (0, 0, 0)\n\nReturns\n\nposition::Matrix{Float64}: A 3×n_points matrix with the position of the points.\nvolume::Vector{Float64}: A vector with the volume of each point.\n\nExamples\n\njulia> position, volume = round_cylinder(5, 10, 2);\n\njulia> position\n3×30 Matrix{Float64}:\n  1.5   0.463525  -1.21353   -1.21353   …  -1.21353   -1.21353    0.463525\n  0.0   1.42658    0.881678  -0.881678      0.881678  -0.881678  -1.42658\n -5.0  -5.0       -5.0       -5.0           5.0        5.0        5.0\n\njulia> volume\n30-element Vector{Int64}:\n 13.089969389957473\n 13.089969389957473\n 13.089969389957473\n 13.089969389957473\n 13.089969389957473\n  ⋮\n 13.089969389957473\n 13.089969389957473\n 13.089969389957473\n 13.089969389957473\n\n\n\n\n\n","category":"function"},{"location":"public_api_reference/#Peridynamics.n_points","page":"Public API","title":"Peridynamics.n_points","text":"n_points(body)\n\nReturn the total number of points in a body.\n\nArguments\n\nbody::Body: Body.\n\nReturns\n\nn_points::Int: The number of points in the body.\n\nExamples\n\njulia> body = Body(BBMaterial(), pos, vol)\n1000-point Body{BBMaterial{NoCorrection}}:\n  1 point set(s):\n    1000-point set `all_points`\n\njulia> n_points(body)\n1000\n\n\n\nn_points(multibody_setup)\n\nReturn the total number of points in a multibody setup.\n\nArguments\n\nmultibody_setup::MultibodySetup: MultibodySetup.\n\nReturns\n\nn_points::Int: The sum of all points from all bodies in the multibody setup.\n\nExamples\n\njulia> ms = MultibodySetup(:a => body_a, :b => body_b)\n2000-point MultibodySetup:\n  1000-point Body{BBMaterial{NoCorrection}} with name `a`\n  1000-point Body{BBMaterial{NoCorrection}} with name `b`\n\njulia> n_points(ms)\n2000\n\n\n\n\n\n","category":"function"},{"location":"public_api_reference/#Preprocessing-and-simulation-setup","page":"Public API","title":"Preprocessing & simulation setup","text":"","category":"section"},{"location":"public_api_reference/#Peridynamics.AbaqusMeshConverter.read_inp","page":"Public API","title":"Peridynamics.AbaqusMeshConverter.read_inp","text":"read_inp(file::String)\n\nRead Abaqus .inp-file and convert meshes to a point cloud with the help of the AbaqusReader.jl package. Every element is converted to a point. The center of the element becomes the position of the point and the element volume becomes the point volume. Element sets defined in Abaqus are converted to corresponding point sets.\n\nCurrently supported mesh elements: [:Tet4, :Hex8]\n\nArguments\n\nfile::String: Path to Abaqus .inp-file.\n\nReturns\n\nposition::Matrix{Float64}: Point position (midpoint of every element).\nvolume::Vector{Float64}: Point volume (volume of every element).\npoint_sets: Element sets defined in the .inp-file.\n\n\n\n\n\n","category":"function"},{"location":"public_api_reference/#Peridynamics.mpi_isroot","page":"Public API","title":"Peridynamics.mpi_isroot","text":"mpi_isroot()\n\nHelper function that returns a bool indicating if a process is the MPI root process. It can be safely used even for multithreading simulations, as it is always true if the package is started in a normal Julia environment which is not started by MPI.\n\n\n\n\n\n","category":"function"},{"location":"public_api_reference/#Peridynamics.force_mpi_run!","page":"Public API","title":"Peridynamics.force_mpi_run!","text":"force_mpi_run!()\n\nHelper function to force the usage of the MPI backend. After this function is called, all following simulations will use MPI.\n\n\n\n\n\n","category":"function"},{"location":"public_api_reference/#Peridynamics.force_threads_run!","page":"Public API","title":"Peridynamics.force_threads_run!","text":"force_threads_run!()\n\nHelper function to force the usage of the multithreading backend. After this function is called, all following simulations will use multithreading.\n\n\n\n\n\n","category":"function"},{"location":"public_api_reference/#Peridynamics.enable_mpi_timers!","page":"Public API","title":"Peridynamics.enable_mpi_timers!","text":"enable_mpi_timers!()\n\nHelper function to enable timers defined with the TimerOutputs for simulations with the MPI backend. The results of the timers then will be exported into the specified path of a Job. By default, not timers will be used with MPI simulations. It can be safely used with multithreading.\n\nSee also disable_mpi_timers!.\n\n\n\n\n\n","category":"function"},{"location":"public_api_reference/#Peridynamics.disable_mpi_timers!","page":"Public API","title":"Peridynamics.disable_mpi_timers!","text":"disable_mpi_timers!()\n\nHelper function to disable timers defined with the TimerOutputs for simulations with the MPI backend. It is mainly used to reset the behaviour after a call of enable_mpi_timers!. It can be safely used with multithreading.\n\n\n\n\n\n","category":"function"},{"location":"public_api_reference/#Peridynamics.enable_mpi_progress_bars!","page":"Public API","title":"Peridynamics.enable_mpi_progress_bars!","text":"enable_mpi_progress_bars!()\n\nHelper function to enable progress bars with MPI simulations on a personal computer. After this function is called, progress bars are beeing shown with MPI simulations like with multithreading simulations. This behavior can be reset to default with reset_mpi_progress_bars!.\n\nwarning: Progress bars and output files\nProgress bars are by default disabled with MPI simulations, because they can really mess up with the output files produced by a HPC system. Therefore, a warning is shown as a reminder to reset this behaviour before submitting a job to a cluster!\n\n\n\n\n\n","category":"function"},{"location":"public_api_reference/#Peridynamics.reset_mpi_progress_bars!","page":"Public API","title":"Peridynamics.reset_mpi_progress_bars!","text":"reset_mpi_progress_bars!()\n\nAfter this function is called, progress bars are again disabled on MPI simulations (standard setting). This will reset the behavior after a call of enable_mpi_progress_bars!.\n\n\n\n\n\n","category":"function"},{"location":"public_api_reference/#Peridynamics.@mpitime","page":"Public API","title":"Peridynamics.@mpitime","text":"@mpitime expression\n\nTime the expression if the mpi rank is zero. Lowers to:\n\nif mpi_isroot()\n    @time expression\nelse\n    expression\nend\n\nSee also: mpi_isroot.\n\n\n\n\n\n","category":"macro"},{"location":"public_api_reference/#Peridynamics.@mpiroot","page":"Public API","title":"Peridynamics.@mpiroot","text":"@mpiroot [option] expression\n\nRun the code if the mpi rank is zero. Lowers to something similar as:\n\nif mpi_isroot()\n    expression\nend\n\nOptions\n\n:wait: All MPI ranks will wait until the root rank finishes evaluating expression.\n\nSee also: mpi_isroot.\n\n\n\n\n\n","category":"macro"},{"location":"public_api_reference/#Solving","page":"Public API","title":"Solving","text":"","category":"section"},{"location":"public_api_reference/#Peridynamics.VelocityVerlet","page":"Public API","title":"Peridynamics.VelocityVerlet","text":"VelocityVerlet(; kwargs...)\n\nTime integration solver for the Velocity Verlet algorithm. Specify either the number of steps or the time the simulation should cover.\n\nKeywords\n\ntime::Real: The total time the simulation will cover. If this keyword is specified, the   keyword steps is no longer allowed. (optional)\nsteps::Int: Number of calculated time steps. If this keyword is specified, the keyword   time is no longer allowed. (optional)\nstepsize::Real: Manually specify the size of the time step. (optional)\nsafety_factor::Real: Safety factor for step size to ensure stability. (default: 0.7)\n\nwarning: Specification of the time step\nKeep in mind that manually specifying the critical time step is dangerous! If the specified time step is too high and the CFL condition no longer holds, the simulation will give wrong results and maybe crash!\n\nThrows\n\nError if both time and steps are specified as keywords.\nError if neither time nor steps are specified as keywords.\nError if safety_factor < 0 or safety_factor > 1.\n\nExample\n\njulia> VelocityVerlet(steps=2000)\nVelocityVerlet:\n  n_steps        2000\n  safety_factor  0.7\n\njulia> VelocityVerlet(time=0.001)\nVelocityVerlet:\n  end_time       0.001\n  safety_factor  0.7\n\njulia> VelocityVerlet(steps=2000, stepsize=0.0001)\n┌ Warning: stepsize specified! Please be sure that the CFD-condition holds!\n└ @ Peridynamics ~/Code/Peridynamics.jl/src/time_solvers/velocity_verlet.jl:66\nVelocityVerlet:\n  n_steps        2000\n  Δt             0.0001\n  safety_factor  0.7\n\n\n\n\n\n","category":"type"},{"location":"public_api_reference/#Peridynamics.DynamicRelaxation","page":"Public API","title":"Peridynamics.DynamicRelaxation","text":"DynamicRelaxation(; kwargs...)\n\nTime integration solver for the adaptive dynamic relaxation algorithm used for quasi-static simulations.\n\nKeywords\n\nsteps::Int: Number of calculated time steps. If this keyword is specified, the keyword   time is no longer allowed.\nstepsize::Real: Manually specify the size of the time step. (default: 1.0)\ndamping_factor::Real: Damping factor to increase the value in the mass matrix.   (default: 1.0)\n\nThrows\n\nError if steps < 0.\nError if stepsize < 0.\nError if damping_factor < 0.\n\nExample\n\njulia> DynamicRelaxation(steps=1000)\nDynamicRelaxation:\n  n_steps  1000\n  Δt       1\n  Λ        1\n\njulia> DynamicRelaxation(steps=1000, damping_factor=2)\nDynamicRelaxation:\n  n_steps  1000\n  Δt       1\n  Λ        2\n\n\n\n\n\n","category":"type"},{"location":"public_api_reference/#Peridynamics.Job","page":"Public API","title":"Peridynamics.Job","text":"Job(spatial_setup, time_solver; kwargs...)\n\nA type that contains all the information necessary for a peridynamic simulation. You can submit a Job to start the simulation.\n\nArguments\n\nspatial_setup: A Body or MultibodySetup.\ntime_solver: VelocityVerlet or DynamicRelaxation.\n\nKeywords\n\npath::String: Path to store results. If it does not exist yet it will be created during   the simulation. (optional)\nfreq::Int: Output frequency of result files. A output file will be written every   freq-th time step. (default: 10)\nfields: Fields that should be exported to output files. Allowed keywords depend on the   selected material model. Please look at the documentation of the material you specified   when creating the body. (default: (:displacement, :damage))\nIf spatial_setup is a Body, the fields keyword can be of the form:\nfields::Symbol: A symbol specifying a single output field.\nfields::NTuple{N,Symbol} where N: A Tuple specifying multiple output fields.\nfields::Vector{Symbol}: A Vector specifying multiple output fields.\nIf spatial_setup is a MultibodySetup, the fields keyword can also be specified   for every body separately:\nfields::Dict{Symbol,T}: A Dictionary containing the fields separately for every   body. T is here every possible type of the fields keyword that can be used for a   single body.\n\nnote: No file export\nIf no keyword is specified when creating a Job, then no files will be exported.\n\nExample\n\njulia> job = Job(multibody_setup, verlet_solver; path=\"my_results/sim1\")\nJob:\n  spatial_setup  25880-point MultibodySetup\n  time_solver    VelocityVerlet(n_steps=2000, safety_factor=0.7)\n  options        export_allowed=true, freq=10\n\n\n\n\n\n","category":"type"},{"location":"public_api_reference/#Peridynamics.submit","page":"Public API","title":"Peridynamics.submit","text":"submit(job::Job; quiet=false)\n\nRun the simulation by submitting the job.\n\nArguments\n\njob::Job: Job that contains all defined parameters and conditions.\n\nKeywords\n\nquiet::Bool: If true, no outputs are printed in the terminal. (default: false)\n\n\n\n\n\n","category":"function"},{"location":"public_api_reference/#Postprocessing","page":"Public API","title":"Postprocessing","text":"","category":"section"},{"location":"public_api_reference/#Peridynamics.VtkReader.read_vtk","page":"Public API","title":"Peridynamics.VtkReader.read_vtk","text":"read_vtk(file::AbstractString)\n\nRead vtu or pvtu file containing simulation results of a time step.\n\nArguments\n\nfile::String: Path to VTK file in vtu or pvtu format.\n\nReturns\n\nDict{String, VecOrMat{Float64}}: Simulation results as a dictionary.\n\nExamples\n\njulia> read_vtk(\"results/fragmenting_cylinder/vtk/timestep_000520.pvtu\")\nDict{Symbol, VecOrMat{Float64}} with 4 entries:\n  :position     => [0.0263309 0.027315 … 0.0293543 0.030339; 0.000292969 0.000294475…\n  :displacement => [0.00583334 0.00581883 … 0.00585909 0.00584271; -0.000162852 -0.0…\n  :damage       => [0.616071, 0.569343, 0.528571, 0.463415, 0.438776, 0.553571, 0.56…\n  :time         => [9.69363e-5]\n\n\n\n\n\n","category":"function"},{"location":"public_api_reference/#Peridynamics.process_each_export","page":"Public API","title":"Peridynamics.process_each_export","text":"process_each_export(f, vtk_path; kwargs...)\nprocess_each_export(f, job; kwargs...)\n\nA function for postprocessing every exported file. This function works with multithreading and MPI and determines the backend exactly like the submit function.\n\nArguments\n\nf::Function: The processing function with signature f(r0, r, id).\nr0: The results of read_vtk for the exported file of the reference   results.\nr: The results of read_vtk for a time step.\nid::Ind: An ID indicating the number of the exported file (counted from 1, starting   with the reference file).\nvtk_path::AbstractString: A path that should contain the export results of a simulation.\njob::Job: A job object. The path of the VTK files will then be processed from the   job options.\n\nKeywords\n\nserial::Bool: If true, all results will be processed in the correct order of the time   steps and on a single thread, cf. the MPI root rank.\n\n\n\n\n\n","category":"function"},{"location":"generated/tutorial_brazilian_test/#tutorial_brazilian_test","page":"Brazilian Test","title":"Brazilian Test","text":"","category":"section"},{"location":"generated/tutorial_brazilian_test/","page":"Brazilian Test","title":"Brazilian Test","text":"This tutorial sets up the Brazilian Test experiment, commonly used to investigate fracture of brittle materials like ultra-high performance concrete. Therefore a cylindrical specimen is loaded by two opposing forces applying pressure on the cross section of the specimen.","category":"page"},{"location":"generated/tutorial_brazilian_test/","page":"Brazilian Test","title":"Brazilian Test","text":"To start, we import the package.","category":"page"},{"location":"generated/tutorial_brazilian_test/","page":"Brazilian Test","title":"Brazilian Test","text":"using Peridynamics","category":"page"},{"location":"generated/tutorial_brazilian_test/","page":"Brazilian Test","title":"Brazilian Test","text":"Then we define the geometrical parameters of the specimen which are the diameter Ø and the length l as well as the point spacing Δx of the model. The parameter b is used later defining point sets for the boundary conditions.","category":"page"},{"location":"generated/tutorial_brazilian_test/","page":"Brazilian Test","title":"Brazilian Test","text":"Ø = 0.05 # [m]\nl = 0.015 # [m]\nΔx = Ø/61 # [m]\nb = 0.017 # [m]","category":"page"},{"location":"generated/tutorial_brazilian_test/","page":"Brazilian Test","title":"Brazilian Test","text":"With the diameter, length and point spacing, we create the cylindrical body. The peridynamics model we employ is a bond-based model applying the energy based surface correction method of Le and Bobaru [LB18].","category":"page"},{"location":"generated/tutorial_brazilian_test/","page":"Brazilian Test","title":"Brazilian Test","text":"pos, vol = uniform_cylinder(Ø, l, Δx)\ncyl = Body(BBMaterial{EnergySurfaceCorrection}(), pos, vol)","category":"page"},{"location":"generated/tutorial_brazilian_test/","page":"Brazilian Test","title":"Brazilian Test","text":"The horizon is specified in relation to the point spacing.","category":"page"},{"location":"generated/tutorial_brazilian_test/","page":"Brazilian Test","title":"Brazilian Test","text":"δ = 3.015Δx","category":"page"},{"location":"generated/tutorial_brazilian_test/","page":"Brazilian Test","title":"Brazilian Test","text":"Then the material parameters are set.","category":"page"},{"location":"generated/tutorial_brazilian_test/","page":"Brazilian Test","title":"Brazilian Test","text":"material!(cyl; horizon=δ, E=50e9, rho=2400, Gc=140)","category":"page"},{"location":"generated/tutorial_brazilian_test/","page":"Brazilian Test","title":"Brazilian Test","text":"To apply the opposing forces, two point sets are generated.","category":"page"},{"location":"generated/tutorial_brazilian_test/","page":"Brazilian Test","title":"Brazilian Test","text":"point_set!(p -> p[1] ≥ Ø/2-3Δx && abs(p[2]) ≤ 1.1*b/2, cyl, :set_1)\npoint_set!(p -> p[1] ≤ -Ø/2+3Δx && abs(p[2]) ≤ 1.1*b/2, cyl, :set_2)","category":"page"},{"location":"generated/tutorial_brazilian_test/","page":"Brazilian Test","title":"Brazilian Test","text":"The functions for the velocity boundary conditions, that have the same value but act in different directions, are defined next.","category":"page"},{"location":"generated/tutorial_brazilian_test/","page":"Brazilian Test","title":"Brazilian Test","text":"v_set1(p, t) = - 2 * exp(-t/0.00002) * (-1/0.02^2 * p[2]^2 + 1)\nv_set2(p, t) =  2 * exp(-t/0.00002) * (-1/0.02^2 * p[2]^2 + 1)","category":"page"},{"location":"generated/tutorial_brazilian_test/","page":"Brazilian Test","title":"Brazilian Test","text":"Then these functions are set as the boundary conditions in x-direction, while the velocites of the points in y- and z-direction are 0.","category":"page"},{"location":"generated/tutorial_brazilian_test/","page":"Brazilian Test","title":"Brazilian Test","text":"velocity_bc!(v_set1, cyl, :set_1, :x)\nvelocity_bc!(t -> 0, cyl, :set_1, :y)\nvelocity_bc!(t -> 0, cyl, :set_1, :z)\nvelocity_bc!(v_set2, cyl, :set_2, :x)\nvelocity_bc!(t -> 0, cyl, :set_2, :y)\nvelocity_bc!(t -> 0, cyl, :set_2, :z)","category":"page"},{"location":"generated/tutorial_brazilian_test/","page":"Brazilian Test","title":"Brazilian Test","text":"The Velocity Verlet algotihm is employed as time integration method where 6000 time steps are calculated.","category":"page"},{"location":"generated/tutorial_brazilian_test/","page":"Brazilian Test","title":"Brazilian Test","text":"vv = VelocityVerlet(steps=6000)","category":"page"},{"location":"generated/tutorial_brazilian_test/","page":"Brazilian Test","title":"Brazilian Test","text":"Finally the job is defined and submitted.","category":"page"},{"location":"generated/tutorial_brazilian_test/","page":"Brazilian Test","title":"Brazilian Test","text":"job = Job(cyl, vv; path=\"results/brazilian_bb_uniform\")\nsubmit(job)","category":"page"},{"location":"generated/tutorial_brazilian_test/","page":"Brazilian Test","title":"Brazilian Test","text":"    <video controls loop=\"true\">\n        <source src=\"https://github.com/user-attachments/assets/dea25e90-34e1-4faf-9241-a5161a741c68\" />\n    </video>","category":"page"},{"location":"expl_continuumbased/#expl_cki","page":"Continuum-kinematics-inspired peridynamics","title":"Continuum-kinematics-inspired peridynamics","text":"","category":"section"},{"location":"expl_continuumbased/","page":"Continuum-kinematics-inspired peridynamics","title":"Continuum-kinematics-inspired peridynamics","text":"Continuum-kinematics-inspired peridynamics (CPD) is a formulation that is supposed to deliver more freedom in specifying material parameters. The internal force density is calculated as the sum of three types of point interactions which are one-, two- and three-neighbor interactions [JMS19]:","category":"page"},{"location":"expl_continuumbased/","page":"Continuum-kinematics-inspired peridynamics","title":"Continuum-kinematics-inspired peridynamics","text":"boldsymbolb^mathrminti = boldsymbolb_1^mathrminti + boldsymbolb_2^mathrminti + boldsymbolb_3^mathrminti  ","category":"page"},{"location":"expl_continuumbased/","page":"Continuum-kinematics-inspired peridynamics","title":"Continuum-kinematics-inspired peridynamics","text":"Size Symbol Unit\nInternal force density boldsymbolb^mathrminti leftfracmathrmkgmathrmm^2mathrms^2right\nForce density shares due to one-, two- & three-neighbor interactions boldsymbolb_1^mathrminti , boldsymbolb_2^mathrminti , boldsymbolb_3^mathrminti leftfracmathrmkgmathrmm^2mathrms^2right","category":"page"},{"location":"expl_continuumbased/#One-neighbor-interactions","page":"Continuum-kinematics-inspired peridynamics","title":"One-neighbor interactions","text":"","category":"section"},{"location":"expl_continuumbased/","page":"Continuum-kinematics-inspired peridynamics","title":"Continuum-kinematics-inspired peridynamics","text":"<img src=\"https://github.com/kaipartmann/Peridynamics.jl/assets/68582683/0380b1b8-4527-4f38-a20e-435a6f1c8ba1\" width=\"250\"/>","category":"page"},{"location":"expl_continuumbased/","page":"Continuum-kinematics-inspired peridynamics","title":"Continuum-kinematics-inspired peridynamics","text":"One-neighbor interactions in CPD correspond to the bonds in bond-based peridynamics, but there is a slightly different way to calculate the internal forces.","category":"page"},{"location":"expl_continuumbased/","page":"Continuum-kinematics-inspired peridynamics","title":"Continuum-kinematics-inspired peridynamics","text":"First, the neighborhood volume is determined:","category":"page"},{"location":"expl_continuumbased/","page":"Continuum-kinematics-inspired peridynamics","title":"Continuum-kinematics-inspired peridynamics","text":"V_mathcalH^i = beta^i  frac 4 3  pi  delta^3  ","category":"page"},{"location":"expl_continuumbased/","page":"Continuum-kinematics-inspired peridynamics","title":"Continuum-kinematics-inspired peridynamics","text":"Here beta^iin 01 is a factor for the completeness of the neighborhood that takes incomplete point families at the surface into account (see figure 1).","category":"page"},{"location":"expl_continuumbased/","page":"Continuum-kinematics-inspired peridynamics","title":"Continuum-kinematics-inspired peridynamics","text":"<img src=\"https://github.com/kaipartmann/Peridynamics.jl/assets/68582683/b899c8d3-e358-4d4d-b52f-13b6c0af747b\" width=\"350\"/>","category":"page"},{"location":"expl_continuumbased/","page":"Continuum-kinematics-inspired peridynamics","title":"Continuum-kinematics-inspired peridynamics","text":"Now, the effective one-neighbor volume can be calculated","category":"page"},{"location":"expl_continuumbased/","page":"Continuum-kinematics-inspired peridynamics","title":"Continuum-kinematics-inspired peridynamics","text":"V_1^i = fracV_mathcalH^iN_1^i","category":"page"},{"location":"expl_continuumbased/","page":"Continuum-kinematics-inspired peridynamics","title":"Continuum-kinematics-inspired peridynamics","text":"with the number of interactions N_1^i.","category":"page"},{"location":"expl_continuumbased/","page":"Continuum-kinematics-inspired peridynamics","title":"Continuum-kinematics-inspired peridynamics","text":"The internal force density is determined by","category":"page"},{"location":"expl_continuumbased/","page":"Continuum-kinematics-inspired peridynamics","title":"Continuum-kinematics-inspired peridynamics","text":"    boldsymbolb_1^mathrminti = int_mathcalH_1^i C_1 left( fracl^ijL^ij - 1 right) fracboldsymbolDelta x^ijl^ij  mathrmd V_1^i","category":"page"},{"location":"expl_continuumbased/","page":"Continuum-kinematics-inspired peridynamics","title":"Continuum-kinematics-inspired peridynamics","text":"with the parameters:","category":"page"},{"location":"expl_continuumbased/","page":"Continuum-kinematics-inspired peridynamics","title":"Continuum-kinematics-inspired peridynamics","text":"Size Symbol Unit\nNeighborhood volume V_mathcalH^i mathrmm^3\nNeighborhood completeness beta^iin 01 -\nEffective one-neighbor volume V_1^i mathrmm^3\nNumber of one-neighbor interactions N_1^i -\nMaterial constant C_1 fracmathrmkgmathrmm^5mathrms^2\nRelative length measures L^ij, l^ij mathrmm","category":"page"},{"location":"expl_continuumbased/#Two-neighbor-interactions","page":"Continuum-kinematics-inspired peridynamics","title":"Two-neighbor interactions","text":"","category":"section"},{"location":"expl_continuumbased/","page":"Continuum-kinematics-inspired peridynamics","title":"Continuum-kinematics-inspired peridynamics","text":"<img src=\"https://github.com/kaipartmann/Peridynamics.jl/assets/68582683/5b340634-7c3f-4ddf-a056-06c31564077c\" width=\"250\"/>","category":"page"},{"location":"expl_continuumbased/","page":"Continuum-kinematics-inspired peridynamics","title":"Continuum-kinematics-inspired peridynamics","text":"For two-neighbor interactions, the deformation of the area spanned by point i and two of its neighbors j and k is analyzed to calculate the internal force density. For this, relative area measures are defined:","category":"page"},{"location":"expl_continuumbased/","page":"Continuum-kinematics-inspired peridynamics","title":"Continuum-kinematics-inspired peridynamics","text":"    A^ijk=left boldsymbolDelta X^ij times boldsymbolDelta X^ik right   qquad a^ijk=left boldsymbolDelta x^ij times boldsymbolDelta x^ik right   qquad boldsymbola^ijk= boldsymbolDelta x^ij times boldsymbolDelta x^ik  ","category":"page"},{"location":"expl_continuumbased/","page":"Continuum-kinematics-inspired peridynamics","title":"Continuum-kinematics-inspired peridynamics","text":"Other sizes needed to identify the force density are the material constant C_2 and the effective two-neighbor volume","category":"page"},{"location":"expl_continuumbased/","page":"Continuum-kinematics-inspired peridynamics","title":"Continuum-kinematics-inspired peridynamics","text":"    V_2^i = fracleft(V_mathcalH^iright)^2N_2^i","category":"page"},{"location":"expl_continuumbased/","page":"Continuum-kinematics-inspired peridynamics","title":"Continuum-kinematics-inspired peridynamics","text":"with the number of interactions N_2. ","category":"page"},{"location":"expl_continuumbased/","page":"Continuum-kinematics-inspired peridynamics","title":"Continuum-kinematics-inspired peridynamics","text":"The internal force density induced by two-neighbor interactions is ","category":"page"},{"location":"expl_continuumbased/","page":"Continuum-kinematics-inspired peridynamics","title":"Continuum-kinematics-inspired peridynamics","text":"    boldsymbolb_2^mathrmint  i = \n2  C_2 int_mathcalH_2^i left( fraca^ijkA^ijk - 1 right)\nfracboldsymbolDelta x^ik times boldsymbola^ijka^ijk  mathrmd V_2^i  ","category":"page"},{"location":"expl_continuumbased/","page":"Continuum-kinematics-inspired peridynamics","title":"Continuum-kinematics-inspired peridynamics","text":"Size Symbol Unit\nRelative area measures A^ijk, a^ijk, boldsymbola^ijk mathrmm^2\nEffective two-neighbor volume V_2^i mathrmm^6\nNumber of two-neighbor interactions N_2^i -\nMaterial constant C_2 fracmathrmkgmathrmm^9mathrms^2","category":"page"},{"location":"expl_continuumbased/#Three-neighbor-interactions","page":"Continuum-kinematics-inspired peridynamics","title":"Three-neighbor interactions","text":"","category":"section"},{"location":"expl_continuumbased/","page":"Continuum-kinematics-inspired peridynamics","title":"Continuum-kinematics-inspired peridynamics","text":"<img src=\"https://github.com/kaipartmann/Peridynamics.jl/assets/68582683/e908c804-a6d4-4bf6-b75a-988f33989213\" width=\"250\"/>","category":"page"},{"location":"expl_continuumbased/","page":"Continuum-kinematics-inspired peridynamics","title":"Continuum-kinematics-inspired peridynamics","text":"Three-neighbor interactions regard the volume defined by the bond vectors between point i and its three neighbors j, k and l:","category":"page"},{"location":"expl_continuumbased/","page":"Continuum-kinematics-inspired peridynamics","title":"Continuum-kinematics-inspired peridynamics","text":"V^ijkl = left(boldsymbolDelta X^ij times boldsymbolDelta X^ikright) cdot boldsymbolDelta X^il  qquad\n    v^ijkl = left(boldsymbolDelta x^ij times boldsymbolDelta x^ikright) cdot boldsymbolDelta x^il  ","category":"page"},{"location":"expl_continuumbased/","page":"Continuum-kinematics-inspired peridynamics","title":"Continuum-kinematics-inspired peridynamics","text":"Additionally, the effective three-neighbor volume","category":"page"},{"location":"expl_continuumbased/","page":"Continuum-kinematics-inspired peridynamics","title":"Continuum-kinematics-inspired peridynamics","text":"    V_3^i = frac left(V_mathcalH^iright)^3N_3^i  ","category":"page"},{"location":"expl_continuumbased/","page":"Continuum-kinematics-inspired peridynamics","title":"Continuum-kinematics-inspired peridynamics","text":"is defined. For the internal force density of three-neighbor interactions, the equation","category":"page"},{"location":"expl_continuumbased/","page":"Continuum-kinematics-inspired peridynamics","title":"Continuum-kinematics-inspired peridynamics","text":"boldsymbolb_3^mathrmint  i = \n3  C_3 int_mathcalH_3^i left( fracleftv^ijklrightleftV^ijklright - 1 right)\nfracleft(boldsymbolDelta x^ik times boldsymbolDelta x^ilright) v^ijklleftv^ijklright  mathrmd V_3^i","category":"page"},{"location":"expl_continuumbased/","page":"Continuum-kinematics-inspired peridynamics","title":"Continuum-kinematics-inspired peridynamics","text":"with the material constant C_3 is used.","category":"page"},{"location":"expl_continuumbased/","page":"Continuum-kinematics-inspired peridynamics","title":"Continuum-kinematics-inspired peridynamics","text":"Size Symbol Unit\nRelative volume measures V^ijkl, v^ijkl mathrmm^3\nEffective three-neighbor volume V_3^i mathrmm^9\nNumber of three-neighbor interactions N_3^i -\nMaterial constant C_3 fracmathrmkgmathrmm^13mathrms^2","category":"page"},{"location":"generated/tutorial_tension_dynfrac/#tutorial_tension_dynfrac","page":"Tensile test dynamic","title":"Tensile test dynamic","text":"","category":"section"},{"location":"generated/tutorial_tension_dynfrac/","page":"Tensile test dynamic","title":"Tensile test dynamic","text":"Import the package:","category":"page"},{"location":"generated/tutorial_tension_dynfrac/","page":"Tensile test dynamic","title":"Tensile test dynamic","text":"using Peridynamics","category":"page"},{"location":"generated/tutorial_tension_dynfrac/","page":"Tensile test dynamic","title":"Tensile test dynamic","text":"Read and convert the Abaqus FEM mesh of a tensile test into a point cloud for the peridynamic model:","category":"page"},{"location":"generated/tutorial_tension_dynfrac/","page":"Tensile test dynamic","title":"Tensile test dynamic","text":"# insert your correct path to the downloaded mesh file!\ninp_file = joinpath(@__DIR__, \"..\", \"assets\", \"TensileTestMesh.inp\");\nnothing #hide","category":"page"},{"location":"generated/tutorial_tension_dynfrac/","page":"Tensile test dynamic","title":"Tensile test dynamic","text":"(Image: )","category":"page"},{"location":"generated/tutorial_tension_dynfrac/","page":"Tensile test dynamic","title":"Tensile test dynamic","text":"Create a body with the points from the mesh: (The bond-based material model with energy based surface correction is used here.)","category":"page"},{"location":"generated/tutorial_tension_dynfrac/","page":"Tensile test dynamic","title":"Tensile test dynamic","text":"body = Body(BBMaterial(), inp_file)","category":"page"},{"location":"generated/tutorial_tension_dynfrac/","page":"Tensile test dynamic","title":"Tensile test dynamic","text":"The element sets defined in Abaqus were converted into point sets of the Body:","category":"page"},{"location":"generated/tutorial_tension_dynfrac/","page":"Tensile test dynamic","title":"Tensile test dynamic","text":"point_sets(body)","category":"page"},{"location":"generated/tutorial_tension_dynfrac/","page":"Tensile test dynamic","title":"Tensile test dynamic","text":"Specify the material parameters as:","category":"page"},{"location":"generated/tutorial_tension_dynfrac/","page":"Tensile test dynamic","title":"Tensile test dynamic","text":"material parameter value\nHorizon $ δ $ 001  mathrmm\nDensity ρ $ 2700 \\,\\mathrm{kg}\\,\\mathrm{m}^{-3}$\nYoung's modulus E $ 70 \\cdot 10^{9} \\, \\mathrm{Pa}$\nGriffith's parameter G_c 100  mathrmN  mathrmm^-1","category":"page"},{"location":"generated/tutorial_tension_dynfrac/","page":"Tensile test dynamic","title":"Tensile test dynamic","text":"material!(body; horizon=0.01, rho=2700, E=70e9, Gc=100)","category":"page"},{"location":"generated/tutorial_tension_dynfrac/","page":"Tensile test dynamic","title":"Tensile test dynamic","text":"As loading condition for the specimen, a constant velocity of 06  mathrmmmathrms^-1 in x-direction is set for the bottom and top.","category":"page"},{"location":"generated/tutorial_tension_dynfrac/","page":"Tensile test dynamic","title":"Tensile test dynamic","text":"velocity_bc!(t -> -0.6, body, :bottom, 1)\nvelocity_bc!(t -> 0.6, body, :top, 1)","category":"page"},{"location":"generated/tutorial_tension_dynfrac/","page":"Tensile test dynamic","title":"Tensile test dynamic","text":"Set the number of time steps for the Velocity Verlet algorithm to 500 time steps:","category":"page"},{"location":"generated/tutorial_tension_dynfrac/","page":"Tensile test dynamic","title":"Tensile test dynamic","text":"vv = VelocityVerlet(steps=500)","category":"page"},{"location":"generated/tutorial_tension_dynfrac/","page":"Tensile test dynamic","title":"Tensile test dynamic","text":"Create the job:","category":"page"},{"location":"generated/tutorial_tension_dynfrac/","page":"Tensile test dynamic","title":"Tensile test dynamic","text":"job = Job(body, vv; path=\"results/tension_dynamic_fracture\")","category":"page"},{"location":"generated/tutorial_tension_dynfrac/","page":"Tensile test dynamic","title":"Tensile test dynamic","text":"Submit the job to start simulations:","category":"page"},{"location":"generated/tutorial_tension_dynfrac/","page":"Tensile test dynamic","title":"Tensile test dynamic","text":"submit(job)","category":"page"},{"location":"generated/tutorial_tension_dynfrac/","page":"Tensile test dynamic","title":"Tensile test dynamic","text":"    <video controls loop=\"true\">\n        <source src=\"https://github.com/user-attachments/assets/332babb0-5c6f-4ae0-89e8-3ae1a7a80177\" />\n    </video>","category":"page"},{"location":"generated/tutorial_tension_precrack/#tutorial_tension_precrack","page":"Tension with predefined crack","title":"Tension with predefined crack","text":"","category":"section"},{"location":"generated/tutorial_tension_precrack/","page":"Tension with predefined crack","title":"Tension with predefined crack","text":"Import the package:","category":"page"},{"location":"generated/tutorial_tension_precrack/","page":"Tension with predefined crack","title":"Tension with predefined crack","text":"using Peridynamics","category":"page"},{"location":"generated/tutorial_tension_precrack/","page":"Tension with predefined crack","title":"Tension with predefined crack","text":"First some geometrical parameters are defined. These are edge length l, point spacing Δx and crack length a. Now a cuboid body with the specified edge lengths and a thickness of one tenth thereof is created using the bond-based material model.","category":"page"},{"location":"generated/tutorial_tension_precrack/","page":"Tension with predefined crack","title":"Tension with predefined crack","text":"l, Δx, a = 1.0, 1/50, 0.5\npos, vol = uniform_box(l, l, 0.1l, Δx)\nbody = Body(BBMaterial(), pos, vol)","category":"page"},{"location":"generated/tutorial_tension_precrack/","page":"Tension with predefined crack","title":"Tension with predefined crack","text":"(Image: )","category":"page"},{"location":"generated/tutorial_tension_precrack/","page":"Tension with predefined crack","title":"Tension with predefined crack","text":"The following material parameters are set:","category":"page"},{"location":"generated/tutorial_tension_precrack/","page":"Tension with predefined crack","title":"Tension with predefined crack","text":"material parameter value\nHorizon $ δ $ 3015 cdot Δx\nYoung's modulus E $ 210000 \\, \\mathrm{MPa}$\nDensity ρ $ 8 \\cdot 10^{-6}\\,\\mathrm{kg}\\,\\mathrm{mm}^{-3}$\nGriffith's parameter G_c 27  mathrmN  mathrmmm^-1","category":"page"},{"location":"generated/tutorial_tension_precrack/","page":"Tension with predefined crack","title":"Tension with predefined crack","text":"δ = 3.015Δx\nmaterial!(body; horizon=δ, E=2.1e5, rho=8e-6, Gc=2.7)","category":"page"},{"location":"generated/tutorial_tension_precrack/","page":"Tension with predefined crack","title":"Tension with predefined crack","text":"Two point sets are defined to insert a crack between them:","category":"page"},{"location":"generated/tutorial_tension_precrack/","page":"Tension with predefined crack","title":"Tension with predefined crack","text":"point_set!(p -> p[1] ≤ -l/2+a && 0 ≤ p[2] ≤ 2δ, body, :set_a)\npoint_set!(p -> p[1] ≤ -l/2+a && -2δ ≤ p[2] < 0, body, :set_b)\nprecrack!(body, :set_a, :set_b)","category":"page"},{"location":"generated/tutorial_tension_precrack/","page":"Tension with predefined crack","title":"Tension with predefined crack","text":"(Image: )","category":"page"},{"location":"generated/tutorial_tension_precrack/","page":"Tension with predefined crack","title":"Tension with predefined crack","text":"Two more point sets at the top and at the bottom are created, which are used for the velocity boundary condition.","category":"page"},{"location":"generated/tutorial_tension_precrack/","page":"Tension with predefined crack","title":"Tension with predefined crack","text":"point_set!(p -> p[2] > l/2-Δx, body, :set_top)\npoint_set!(p -> p[2] < -l/2+Δx, body, :set_bottom)","category":"page"},{"location":"generated/tutorial_tension_precrack/","page":"Tension with predefined crack","title":"Tension with predefined crack","text":"(Image: )","category":"page"},{"location":"generated/tutorial_tension_precrack/","page":"Tension with predefined crack","title":"Tension with predefined crack","text":"The tension is applied by moving the ends of the body apart at a constant speed of pm 50  mathrmmm  mathrms^-1:","category":"page"},{"location":"generated/tutorial_tension_precrack/","page":"Tension with predefined crack","title":"Tension with predefined crack","text":"velocity_bc!(t -> -30, body, :set_bottom, :y)\nvelocity_bc!(t -> 30, body, :set_top, :y)","category":"page"},{"location":"generated/tutorial_tension_precrack/","page":"Tension with predefined crack","title":"Tension with predefined crack","text":"The Velocity Verlet algorithm is used as time integration method and 2000 time steps are calculated:","category":"page"},{"location":"generated/tutorial_tension_precrack/","page":"Tension with predefined crack","title":"Tension with predefined crack","text":"vv = VelocityVerlet(steps=2000)","category":"page"},{"location":"generated/tutorial_tension_precrack/","page":"Tension with predefined crack","title":"Tension with predefined crack","text":"Now the job is defined","category":"page"},{"location":"generated/tutorial_tension_precrack/","page":"Tension with predefined crack","title":"Tension with predefined crack","text":"job = Job(body, vv; path=\"results/mode_i_tension_precrack\")","category":"page"},{"location":"generated/tutorial_tension_precrack/","page":"Tension with predefined crack","title":"Tension with predefined crack","text":"Finally the job is submitted to start simulations","category":"page"},{"location":"generated/tutorial_tension_precrack/","page":"Tension with predefined crack","title":"Tension with predefined crack","text":"submit(job)","category":"page"},{"location":"generated/tutorial_tension_precrack/#Damage-results:","page":"Tension with predefined crack","title":"Damage results:","text":"","category":"section"},{"location":"generated/tutorial_tension_precrack/","page":"Tension with predefined crack","title":"Tension with predefined crack","text":"    <video controls loop=\"true\">\n        <source src=\"https://github.com/user-attachments/assets/918aed7b-735d-418f-900c-e0a996db2bab\" />\n    </video>","category":"page"},{"location":"expl_damage/#expl_dmg","page":"Damage in peridynamics formulations","title":"Damage in peridynamics formulations","text":"","category":"section"},{"location":"expl_damage/","page":"Damage in peridynamics formulations","title":"Damage in peridynamics formulations","text":"For damage simulations with peridynamics, some slight extensions to the material formulations need to be made.","category":"page"},{"location":"expl_damage/#Bond-based-formulation","page":"Damage in peridynamics formulations","title":"Bond-based formulation","text":"","category":"section"},{"location":"expl_damage/","page":"Damage in peridynamics formulations","title":"Damage in peridynamics formulations","text":"In bond-based peridynamics, the pairwise force function is expanded by the factor d^ij, which states whether the bond between points i and j is intact (d^ij=1) or damaged (d^ij=0). Therefore the pairwise force function reads","category":"page"},{"location":"expl_damage/","page":"Damage in peridynamics formulations","title":"Damage in peridynamics formulations","text":" boldsymbolf = d^ij  c  varepsilon^ij  boldsymboln ","category":"page"},{"location":"expl_damage/","page":"Damage in peridynamics formulations","title":"Damage in peridynamics formulations","text":"with the bond failure quantity d^ij in 01.","category":"page"},{"location":"expl_damage/#State-based-formulation","page":"Damage in peridynamics formulations","title":"State-based formulation","text":"","category":"section"},{"location":"expl_damage/","page":"Damage in peridynamics formulations","title":"Damage in peridynamics formulations","text":"In all state-based peridynamic formulations, damage is introduced by using a failure considering influence function:","category":"page"},{"location":"expl_damage/","page":"Damage in peridynamics formulations","title":"Damage in peridynamics formulations","text":" omega_d = d^ij  omega","category":"page"},{"location":"expl_damage/","page":"Damage in peridynamics formulations","title":"Damage in peridynamics formulations","text":"with the bond failure quantity d^ij in 01.","category":"page"},{"location":"expl_damage/#Continuum-kinematics-inspired-formulation","page":"Damage in peridynamics formulations","title":"Continuum-kinematics-inspired formulation","text":"","category":"section"},{"location":"expl_damage/","page":"Damage in peridynamics formulations","title":"Damage in peridynamics formulations","text":"For continuum-kinematics-inspired peridynamics there are three different bond failure factors, one for each kind of interaction. For one-neighbor interactions it is similar to the failure in the bond-based formulation. Here the internal force density due to one-neighbor interactions is","category":"page"},{"location":"expl_damage/","page":"Damage in peridynamics formulations","title":"Damage in peridynamics formulations","text":"    boldsymbolb_1^mathrminti = int_mathcalH_1^i d^ij C_1 left( fracl^ijL^ij - 1 right) fracboldsymbolDelta x^ijl^ij  mathrmd V_1^i","category":"page"},{"location":"expl_damage/","page":"Damage in peridynamics formulations","title":"Damage in peridynamics formulations","text":"with the bond failure quantity d^ij in 01.","category":"page"},{"location":"expl_damage/","page":"Damage in peridynamics formulations","title":"Damage in peridynamics formulations","text":"In two-neighbor interactions a factor describing the failure of the considered area element is included:","category":"page"},{"location":"expl_damage/","page":"Damage in peridynamics formulations","title":"Damage in peridynamics formulations","text":"    boldsymbolb_2^mathrmint  i = \n2  C_2 int_mathcalH_2^i d^ijk left( fraca^ijkA^ijk - 1 right)\nfracboldsymbolDelta x^ik times boldsymbola^ijka^ijk  mathrmd V_2^i ","category":"page"},{"location":"expl_damage/","page":"Damage in peridynamics formulations","title":"Damage in peridynamics formulations","text":"with the two-neighbor interaction failure quantity d^ijk in 01.","category":"page"},{"location":"expl_damage/","page":"Damage in peridynamics formulations","title":"Damage in peridynamics formulations","text":"For three-neighbor interactions the internal force density eventually reads","category":"page"},{"location":"expl_damage/","page":"Damage in peridynamics formulations","title":"Damage in peridynamics formulations","text":"boldsymbolb_3^mathrmint  i = \n3  C_3 int_mathcalH_3^i d^ijkl left( fracleftv^ijklrightleftV^ijklright - 1 right)\nfracleft(boldsymbolDelta x^ik times boldsymbolDelta x^ilright) v^ijklleftv^ijklright  mathrmd V_3^i","category":"page"},{"location":"expl_damage/","page":"Damage in peridynamics formulations","title":"Damage in peridynamics formulations","text":"with the three-neighbor interaction failure quantity d^ijkl in 01.","category":"page"},{"location":"expl_damage/","page":"Damage in peridynamics formulations","title":"Damage in peridynamics formulations","text":"Size Symbol Unit\nBond failure quantity d^ij in 01 -\nTwo-neighbor interaction failure quantity d^ijk in 01 -\nThree-neighbor interaction failure quantity d^ijkl in 01 -","category":"page"},{"location":"generated/tutorial_kalthoff-winkler_dynfrac/#tutorial_kalthoff-winkler","page":"Kalthoff-Winkler experiment","title":"Kalthoff-Winkler experiment","text":"","category":"section"},{"location":"generated/tutorial_kalthoff-winkler_dynfrac/","page":"Kalthoff-Winkler experiment","title":"Kalthoff-Winkler experiment","text":"This tutorial demonstrates how to set up and run the Kalthoff-Winkler experiment using the Peridynamics.jl package. The Kalthoff-Winkler experiment is a classic dynamic fracture experiment involving a pre-notched sample subjected to impact loading.","category":"page"},{"location":"generated/tutorial_kalthoff-winkler_dynfrac/#Introduction","page":"Kalthoff-Winkler experiment","title":"Introduction","text":"","category":"section"},{"location":"generated/tutorial_kalthoff-winkler_dynfrac/","page":"Kalthoff-Winkler experiment","title":"Kalthoff-Winkler experiment","text":"The Kalthoff-Winkler experiment is widely used to study fracture mechanics under high strain rates. This setup provides valuable insights into the behavior of materials under dynamic loading conditions, making it an interesting experiment in the field of fracture mechanics.","category":"page"},{"location":"generated/tutorial_kalthoff-winkler_dynfrac/","page":"Kalthoff-Winkler experiment","title":"Kalthoff-Winkler experiment","text":"In this tutorial, we will simulate the Kalthoff-Winkler experiment using peridynamics without the impactor. To do so, first we would import the package.","category":"page"},{"location":"generated/tutorial_kalthoff-winkler_dynfrac/","page":"Kalthoff-Winkler experiment","title":"Kalthoff-Winkler experiment","text":"using Peridynamics","category":"page"},{"location":"generated/tutorial_kalthoff-winkler_dynfrac/#Geometrical-Parameters","page":"Kalthoff-Winkler experiment","title":"Geometrical Parameters","text":"","category":"section"},{"location":"generated/tutorial_kalthoff-winkler_dynfrac/","page":"Kalthoff-Winkler experiment","title":"Kalthoff-Winkler experiment","text":"Define the sample length l, width w, and thickness t, with point spacing Δx, horizon size $ δ $ and crack length a.","category":"page"},{"location":"generated/tutorial_kalthoff-winkler_dynfrac/","page":"Kalthoff-Winkler experiment","title":"Kalthoff-Winkler experiment","text":"l  = 200.0E-3  # Length of the sample (meters)\nw  = 100.0E-3  # Width of the sample (meters)\nt  =   9.0E-3  # Thickness of the sample (meters)\nΔx =   1.0E-3  # Discretization size (meters)\nδ  =  4.015Δx  # Horizon (meters)\na  =  50.0E-3  # Crack length (meters)\nnothing #hide","category":"page"},{"location":"generated/tutorial_kalthoff-winkler_dynfrac/#Create-the-Body","page":"Kalthoff-Winkler experiment","title":"Create the Body","text":"","category":"section"},{"location":"generated/tutorial_kalthoff-winkler_dynfrac/","page":"Kalthoff-Winkler experiment","title":"Kalthoff-Winkler experiment","text":"Create a body with the specified dimensions using the bond-based material model with surface corrections:","category":"page"},{"location":"generated/tutorial_kalthoff-winkler_dynfrac/","page":"Kalthoff-Winkler experiment","title":"Kalthoff-Winkler experiment","text":"pos, vol = uniform_box(l, w, t, Δx)\nbody = Body(BBMaterial{EnergySurfaceCorrection}(), pos, vol)","category":"page"},{"location":"generated/tutorial_kalthoff-winkler_dynfrac/#Material-Parameters","page":"Kalthoff-Winkler experiment","title":"Material Parameters","text":"","category":"section"},{"location":"generated/tutorial_kalthoff-winkler_dynfrac/","page":"Kalthoff-Winkler experiment","title":"Kalthoff-Winkler experiment","text":"The following material parameters are set:","category":"page"},{"location":"generated/tutorial_kalthoff-winkler_dynfrac/","page":"Kalthoff-Winkler experiment","title":"Kalthoff-Winkler experiment","text":"material parameter value\nHorizon $ δ $ 4015 cdot Δx\nYoung's modulus E $ 191\\cdot 10^{9} \\, \\mathrm{Pa}$\nDensity ρ $ 8000 ,\\mathrm{kg}\\,\\mathrm{m}^{-3}$\nCritical stretch varepsilon_c 001","category":"page"},{"location":"generated/tutorial_kalthoff-winkler_dynfrac/","page":"Kalthoff-Winkler experiment","title":"Kalthoff-Winkler experiment","text":"material!(body; horizon=δ, E=191.0e9, rho=8000.0, epsilon_c=0.015)","category":"page"},{"location":"generated/tutorial_kalthoff-winkler_dynfrac/#Define-Pre-cracks","page":"Kalthoff-Winkler experiment","title":"Define Pre-cracks","text":"","category":"section"},{"location":"generated/tutorial_kalthoff-winkler_dynfrac/","page":"Kalthoff-Winkler experiment","title":"Kalthoff-Winkler experiment","text":"Define the point sets to insert a crack at the left side of the domain (-x):","category":"page"},{"location":"generated/tutorial_kalthoff-winkler_dynfrac/","page":"Kalthoff-Winkler experiment","title":"Kalthoff-Winkler experiment","text":"point_set!(p -> -a / 2 - δ ≤ p[1] ≤ -a / 2 && 0 ≤ p[2] < w / 2, body, :set_crack1_a)\npoint_set!(p -> -a / 2 ≤ p[1] ≤ -a / 2 + δ && 0 ≤ p[2] < w / 2, body, :set_crack1_b)\nprecrack!(body, :set_crack1_a, :set_crack1_b)","category":"page"},{"location":"generated/tutorial_kalthoff-winkler_dynfrac/","page":"Kalthoff-Winkler experiment","title":"Kalthoff-Winkler experiment","text":"Define the point sets to insert a crack at the right side of the domain (+x):","category":"page"},{"location":"generated/tutorial_kalthoff-winkler_dynfrac/","page":"Kalthoff-Winkler experiment","title":"Kalthoff-Winkler experiment","text":"point_set!(p -> a / 2 - δ ≤ p[1] ≤ a / 2 && 0 ≤ p[2] < w / 2, body, :set_crack2_a)\npoint_set!(p -> a / 2 ≤ p[1] ≤ a / 2 + δ && 0 ≤ p[2] < w / 2, body, :set_crack2_b)\nprecrack!(body, :set_crack2_a, :set_crack2_b)","category":"page"},{"location":"generated/tutorial_kalthoff-winkler_dynfrac/#Velocity-Boundary-Condition","page":"Kalthoff-Winkler experiment","title":"Velocity Boundary Condition","text":"","category":"section"},{"location":"generated/tutorial_kalthoff-winkler_dynfrac/","page":"Kalthoff-Winkler experiment","title":"Kalthoff-Winkler experiment","text":"Apply a velocity boundary condition that is active for 01  mathrmms on the top edge:","category":"page"},{"location":"generated/tutorial_kalthoff-winkler_dynfrac/","page":"Kalthoff-Winkler experiment","title":"Kalthoff-Winkler experiment","text":"point_set!(p -> -a / 2 < p[1] < a / 2 && p[2] ≥ w / 2 - 4Δx, body, :set_top)\nvelocity_bc!(t -> t < 0.0001 ? -32.0 : NaN, body, :set_top, :y)","category":"page"},{"location":"generated/tutorial_kalthoff-winkler_dynfrac/","page":"Kalthoff-Winkler experiment","title":"Kalthoff-Winkler experiment","text":"A layer of 3 points at the uncracked boundary is not allowed to obtain failure.","category":"page"},{"location":"generated/tutorial_kalthoff-winkler_dynfrac/","page":"Kalthoff-Winkler experiment","title":"Kalthoff-Winkler experiment","text":"point_set!(y -> y < -w / 2 + 3Δx, body, :no_fail_zone)\nno_failure!(body, :no_fail_zone)","category":"page"},{"location":"generated/tutorial_kalthoff-winkler_dynfrac/#Simulation","page":"Kalthoff-Winkler experiment","title":"Simulation","text":"","category":"section"},{"location":"generated/tutorial_kalthoff-winkler_dynfrac/","page":"Kalthoff-Winkler experiment","title":"Kalthoff-Winkler experiment","text":"Use the Velocity Verlet algorithm as the time integration method and calculate 2000 time steps:","category":"page"},{"location":"generated/tutorial_kalthoff-winkler_dynfrac/","page":"Kalthoff-Winkler experiment","title":"Kalthoff-Winkler experiment","text":"vv = VelocityVerlet(time=0.0003, safety_factor=0.8)","category":"page"},{"location":"generated/tutorial_kalthoff-winkler_dynfrac/","page":"Kalthoff-Winkler experiment","title":"Kalthoff-Winkler experiment","text":"Define the storage path:","category":"page"},{"location":"generated/tutorial_kalthoff-winkler_dynfrac/","page":"Kalthoff-Winkler experiment","title":"Kalthoff-Winkler experiment","text":"path = joinpath(\"results\", \"KW\")\nispath(path) && rm(path; recursive=true)  # Delete existing results if they exist","category":"page"},{"location":"generated/tutorial_kalthoff-winkler_dynfrac/","page":"Kalthoff-Winkler experiment","title":"Kalthoff-Winkler experiment","text":"Create and submit the job:","category":"page"},{"location":"generated/tutorial_kalthoff-winkler_dynfrac/","page":"Kalthoff-Winkler experiment","title":"Kalthoff-Winkler experiment","text":"job = Job(body, vv; path=path)","category":"page"},{"location":"generated/tutorial_kalthoff-winkler_dynfrac/","page":"Kalthoff-Winkler experiment","title":"Kalthoff-Winkler experiment","text":"@mpitime submit(job)","category":"page"},{"location":"generated/tutorial_kalthoff-winkler_dynfrac/","page":"Kalthoff-Winkler experiment","title":"Kalthoff-Winkler experiment","text":"    <video controls loop=\"true\">\n        <source src=\"https://github.com/user-attachments/assets/49aca8fe-cbe8-4e5a-8a78-02ce4aeb3cae\" />\n    </video>","category":"page"},{"location":"generated/tutorial_kalthoff-winkler_dynfrac/#Conclusion","page":"Kalthoff-Winkler experiment","title":"Conclusion","text":"","category":"section"},{"location":"generated/tutorial_kalthoff-winkler_dynfrac/","page":"Kalthoff-Winkler experiment","title":"Kalthoff-Winkler experiment","text":"This tutorial demonstrated how to set up and run the Kalthoff-Winkler experiment using Peridynamics.jl. By simulating this experiment, we can gain insights into the dynamic fracture behavior of materials under high strain rates.","category":"page"},{"location":"expl_osbased/#expl_osb","page":"Ordinary state-based peridynamics","title":"Ordinary state-based peridynamics","text":"","category":"section"},{"location":"expl_osbased/","page":"Ordinary state-based peridynamics","title":"Ordinary state-based peridynamics","text":"The state-based peridynamics formulation considers not only the deformation of the bonds of one material point, but also the states of all neighbors to calculate the internal force density boldsymbolb^mathrminti as","category":"page"},{"location":"expl_osbased/","page":"Ordinary state-based peridynamics","title":"Ordinary state-based peridynamics","text":"boldsymbolb^mathrminti = boldsymbolb^mathrmint (boldsymbolX^it) = int_mathcalH_i boldsymbolt^i - boldsymbolt^j  mathrmdV^j  ","category":"page"},{"location":"expl_osbased/","page":"Ordinary state-based peridynamics","title":"Ordinary state-based peridynamics","text":"with the force vector states boldsymbolt^i=boldsymbolt(boldsymbolDelta X^ij t) and boldsymbolt^j=boldsymbolt(-boldsymbolDelta X^ij t), which characterize the state of each bond at time t [SEW+07]. To determine the force vector states, the weighted volume m_i is calculated first as","category":"page"},{"location":"expl_osbased/","page":"Ordinary state-based peridynamics","title":"Ordinary state-based peridynamics","text":"m_i = m left( boldsymbolX^i right) = int_mathcalH_i omega   boldsymbolDelta X^ij ^2  mathrmd V^j  ","category":"page"},{"location":"expl_osbased/","page":"Ordinary state-based peridynamics","title":"Ordinary state-based peridynamics","text":"Here, omega is the influence function that gives a greater influence to neighbors near the root point. [SEW+07] Then the dilatation theta_i is needed, which is defined with the weighted volume m_i as","category":"page"},{"location":"expl_osbased/","page":"Ordinary state-based peridynamics","title":"Ordinary state-based peridynamics","text":"theta_i = theta left( boldsymbolX^i right) = frac3m_i int_mathcalH_i omega   boldsymbolDelta X^ij   left( boldsymbolDelta x^ij-boldsymbolDelta X^ij right) mathrmd V^j  ","category":"page"},{"location":"expl_osbased/","page":"Ordinary state-based peridynamics","title":"Ordinary state-based peridynamics","text":"With the previously determined variables, the force vector state boldsymbolt^i is defined as ","category":"page"},{"location":"expl_osbased/","page":"Ordinary state-based peridynamics","title":"Ordinary state-based peridynamics","text":"boldsymbolt^i left( boldsymbolDelta X^ij right) = fracK  theta_im_i  omega   boldsymbolDelta X^ij  + frac15  Gm_i  omega  left( boldsymbolDelta x^ij-boldsymbolDelta X^ij - fractheta_i  boldsymbolDelta X^ij3 right)  ","category":"page"},{"location":"expl_osbased/","page":"Ordinary state-based peridynamics","title":"Ordinary state-based peridynamics","text":"with shear modulus G and bulk modulus K [SEW+07].","category":"page"},{"location":"expl_osbased/","page":"Ordinary state-based peridynamics","title":"Ordinary state-based peridynamics","text":"Size Symbol Unit\nInternal force density boldsymbolb^mathrminti leftfracmathrmkgmathrmm^2mathrms^2right\nForce vector state $ \\boldsymbol{t}^i $ leftfracmathrmkgmathrmm^5mathrms^2right\nVolume of point j V^j leftmathrmm^3right\nBond in mathcalB_0 boldsymbolDelta X^ij mathrmm\nBond in mathcalB_t boldsymbolDelta x^ij mathrmm\nBond length in mathcalB_0 leftboldsymbolDelta X^ijright mathrmm\nBond length in mathcalB_t leftboldsymbolDelta x^ijright mathrmm\nInfluence function omega -\nWeighted volume $ m_i $ leftmathrmm^5right\nDilatation theta_i -\nShear modulus G leftfracmathrmkgmathrmmmathrms^2right\nBulk modulus K leftfracmathrmkgmathrmmmathrms^2right","category":"page"},{"location":"generated/tutorial_tension_static/#tutorial_tension_static","page":"Tensile test quasi-static","title":"Tensile test quasi-static","text":"","category":"section"},{"location":"generated/tutorial_tension_static/","page":"Tensile test quasi-static","title":"Tensile test quasi-static","text":"Import the package:","category":"page"},{"location":"generated/tutorial_tension_static/","page":"Tensile test quasi-static","title":"Tensile test quasi-static","text":"using Peridynamics","category":"page"},{"location":"generated/tutorial_tension_static/","page":"Tensile test quasi-static","title":"Tensile test quasi-static","text":"Read and convert the Abaqus FEM mesh of a tensile test into a point cloud for the peridynamic model:","category":"page"},{"location":"generated/tutorial_tension_static/","page":"Tensile test quasi-static","title":"Tensile test quasi-static","text":"# insert your correct path to the downloaded mesh file!\ninp_file = joinpath(@__DIR__, \"..\", \"assets\", \"TensileTestMesh.inp\");\nnothing #hide","category":"page"},{"location":"generated/tutorial_tension_static/","page":"Tensile test quasi-static","title":"Tensile test quasi-static","text":"(Image: )","category":"page"},{"location":"generated/tutorial_tension_static/","page":"Tensile test quasi-static","title":"Tensile test quasi-static","text":"Create a body with the points from the mesh: (The bond-based material model is used here.)","category":"page"},{"location":"generated/tutorial_tension_static/","page":"Tensile test quasi-static","title":"Tensile test quasi-static","text":"body = Body(BBMaterial(), inp_file)","category":"page"},{"location":"generated/tutorial_tension_static/","page":"Tensile test quasi-static","title":"Tensile test quasi-static","text":"The element sets defined in Abaqus were converted into point sets of the Body:","category":"page"},{"location":"generated/tutorial_tension_static/","page":"Tensile test quasi-static","title":"Tensile test quasi-static","text":"point_sets(body)","category":"page"},{"location":"generated/tutorial_tension_static/","page":"Tensile test quasi-static","title":"Tensile test quasi-static","text":"Specify the material parameters as:","category":"page"},{"location":"generated/tutorial_tension_static/","page":"Tensile test quasi-static","title":"Tensile test quasi-static","text":"material parameter value\nHorizon $ δ $ 001  mathrmm\nDensity ρ $ 2700 \\,\\mathrm{kg}\\,\\mathrm{m}^{-3}$\nYoung's modulus E $ 70 \\cdot 10^{9} \\, \\mathrm{Pa}$\nGriffith's parameter G_c 100  mathrmN  mathrmm^-1","category":"page"},{"location":"generated/tutorial_tension_static/","page":"Tensile test quasi-static","title":"Tensile test quasi-static","text":"material!(body; horizon=0.01, rho=2700, E=70e9, Gc=100)","category":"page"},{"location":"generated/tutorial_tension_static/","page":"Tensile test quasi-static","title":"Tensile test quasi-static","text":"As loading condition for the specimen, a constant force density of 1 times 10^9  mathrmNmathrmm^-3 in x-direction is set for the bottom and top.","category":"page"},{"location":"generated/tutorial_tension_static/","page":"Tensile test quasi-static","title":"Tensile test quasi-static","text":"forcedensity_bc!(t -> -3e11, body, :bottom, 1)\nforcedensity_bc!(t -> 3e11, body, :top, 1)","category":"page"},{"location":"generated/tutorial_tension_static/","page":"Tensile test quasi-static","title":"Tensile test quasi-static","text":"Do not allow failure in the entire body:","category":"page"},{"location":"generated/tutorial_tension_static/","page":"Tensile test quasi-static","title":"Tensile test quasi-static","text":"no_failure!(body)","category":"page"},{"location":"generated/tutorial_tension_static/","page":"Tensile test quasi-static","title":"Tensile test quasi-static","text":"We set the number of time steps for the dynamic relaxation algorithm to 500 time steps.","category":"page"},{"location":"generated/tutorial_tension_static/","page":"Tensile test quasi-static","title":"Tensile test quasi-static","text":"dr = DynamicRelaxation(steps=500, damping_factor=0.2)","category":"page"},{"location":"generated/tutorial_tension_static/","page":"Tensile test quasi-static","title":"Tensile test quasi-static","text":"Create the job:","category":"page"},{"location":"generated/tutorial_tension_static/","page":"Tensile test quasi-static","title":"Tensile test quasi-static","text":"job = Job(body, dr; path=\"results/tension_static\")","category":"page"},{"location":"generated/tutorial_tension_static/","page":"Tensile test quasi-static","title":"Tensile test quasi-static","text":"submit(job)","category":"page"},{"location":"generated/tutorial_tension_static/","page":"Tensile test quasi-static","title":"Tensile test quasi-static","text":"    <video controls loop=\"true\">\n        <source src=\"https://github.com/user-attachments/assets/b6b2ba41-1ed3-497f-b496-44655d4be696\" />\n    </video>","category":"page"},{"location":"generated/tutorial_wave_interface/#Wave-propagation-across-material-interface","page":"Wave propagation across material interface","title":"Wave propagation across material interface","text":"","category":"section"},{"location":"generated/tutorial_wave_interface/","page":"Wave propagation across material interface","title":"Wave propagation across material interface","text":"Based on the wave propagation tutorial, this tutorial features a displacement wave crossing a material interface, as investigated in [PDW24]. This means that a bar containing two sections with different material properties is regarded.","category":"page"},{"location":"generated/tutorial_wave_interface/","page":"Wave propagation across material interface","title":"Wave propagation across material interface","text":"First import the Peridynamics.jl package:","category":"page"},{"location":"generated/tutorial_wave_interface/","page":"Wave propagation across material interface","title":"Wave propagation across material interface","text":"using Peridynamics","category":"page"},{"location":"generated/tutorial_wave_interface/","page":"Wave propagation across material interface","title":"Wave propagation across material interface","text":"Then the geometric parameters are set, which are the same as in the wave propagation tutorial. These are the length lx, width and height lyz of the cuboid as well as the number of points in the width npyz, which determines the point spacing Δx.","category":"page"},{"location":"generated/tutorial_wave_interface/","page":"Wave propagation across material interface","title":"Wave propagation across material interface","text":"lx = 0.2\nlyz = 0.002\nnpyz = 4\nΔx = lyz / npyz","category":"page"},{"location":"generated/tutorial_wave_interface/","page":"Wave propagation across material interface","title":"Wave propagation across material interface","text":"With these parameters we now create a body, here using the non-ordinary state-based correspondence formulation.","category":"page"},{"location":"generated/tutorial_wave_interface/","page":"Wave propagation across material interface","title":"Wave propagation across material interface","text":"pos, vol = uniform_box(lx, lyz, lyz, Δx)\nbody = Body(CMaterial(), pos, vol)","category":"page"},{"location":"generated/tutorial_wave_interface/","page":"Wave propagation across material interface","title":"Wave propagation across material interface","text":"Then the material parameters for one half of the body are assigned to the whole body first.","category":"page"},{"location":"generated/tutorial_wave_interface/","page":"Wave propagation across material interface","title":"Wave propagation across material interface","text":"material!(body, horizon=3.015Δx, rho=7850.0, E=210e9, nu=0.25)","category":"page"},{"location":"generated/tutorial_wave_interface/","page":"Wave propagation across material interface","title":"Wave propagation across material interface","text":"Now a point set containing the other half of all points is created.","category":"page"},{"location":"generated/tutorial_wave_interface/","page":"Wave propagation across material interface","title":"Wave propagation across material interface","text":"point_set!(x -> x < 0, body, :set1)","category":"page"},{"location":"generated/tutorial_wave_interface/","page":"Wave propagation across material interface","title":"Wave propagation across material interface","text":"(Image: ) The parameters for this point set are then overwritten with their new parameters.","category":"page"},{"location":"generated/tutorial_wave_interface/","page":"Wave propagation across material interface","title":"Wave propagation across material interface","text":"material!(body, :set1, horizon=3.015Δx, rho=7850.0, E=105e9, nu=0.25)","category":"page"},{"location":"generated/tutorial_wave_interface/","page":"Wave propagation across material interface","title":"Wave propagation across material interface","text":"Except for the Young's modulus, these are the same in both sections:","category":"page"},{"location":"generated/tutorial_wave_interface/","page":"Wave propagation across material interface","title":"Wave propagation across material interface","text":"material parameter value\nHorizon $ δ $ 3015 cdot Δx\nDensity ρ $ 7850\\,\\mathrm{kg}\\,\\mathrm{m}^{-3}$\nYoung's modulus E_I $ 105 \\, \\mathrm{GPa}$\nYoung's modulus E_II $ 210 \\, \\mathrm{GPa}$\nPoisson's ratio ν 025","category":"page"},{"location":"generated/tutorial_wave_interface/","page":"Wave propagation across material interface","title":"Wave propagation across material interface","text":"Again, failure is not allowed in the whole body since no fracture parameters are specified.","category":"page"},{"location":"generated/tutorial_wave_interface/","page":"Wave propagation across material interface","title":"Wave propagation across material interface","text":"To employ the boundary conditions creating a displacement wave, the point set :left is created:","category":"page"},{"location":"generated/tutorial_wave_interface/","page":"Wave propagation across material interface","title":"Wave propagation across material interface","text":"point_set!(x -> x < -lx / 2 + 1.2Δx, body, :left)","category":"page"},{"location":"generated/tutorial_wave_interface/","page":"Wave propagation across material interface","title":"Wave propagation across material interface","text":"As in the wave propagation tutorial, the applied velocity boundary condition is","category":"page"},{"location":"generated/tutorial_wave_interface/","page":"Wave propagation across material interface","title":"Wave propagation across material interface","text":"    v_x (t) =\n    begincases\n        v_mathrmmax cdot sin(2pi cdot fractT) qquad\n         forall  0 leq t leq T \n        0 textelse\n    endcases","category":"page"},{"location":"generated/tutorial_wave_interface/","page":"Wave propagation across material interface","title":"Wave propagation across material interface","text":"(Image: )","category":"page"},{"location":"generated/tutorial_wave_interface/","page":"Wave propagation across material interface","title":"Wave propagation across material interface","text":"T, vmax = 1.0e-5, 2.0\nvelocity_bc!(t -> t < T ? vmax * sin(2π / T * t) : 0.0, body, :left, :x)","category":"page"},{"location":"generated/tutorial_wave_interface/","page":"Wave propagation across material interface","title":"Wave propagation across material interface","text":"The Velocity Verlet algorithm is used as time integration method and 2000 time steps are calculated:","category":"page"},{"location":"generated/tutorial_wave_interface/","page":"Wave propagation across material interface","title":"Wave propagation across material interface","text":"vv = VelocityVerlet(steps=2000)","category":"page"},{"location":"generated/tutorial_wave_interface/","page":"Wave propagation across material interface","title":"Wave propagation across material interface","text":"Finally the job is defined and submitted.","category":"page"},{"location":"generated/tutorial_wave_interface/","page":"Wave propagation across material interface","title":"Wave propagation across material interface","text":"job = Job(body, vv; path=\"results/xwave_interface\")\nsubmit(job)","category":"page"},{"location":"generated/tutorial_wave_interface/","page":"Wave propagation across material interface","title":"Wave propagation across material interface","text":"    <video controls loop=\"true\">\n        <source src=\"https://github.com/user-attachments/assets/45513e03-fde0-44ad-ac90-ca181d59933c\" />\n    </video>","category":"page"},{"location":"generated/tutorial_logo/#tutorial_logo","page":"The old Peridynamics.jl logo","title":"The old Peridynamics.jl logo","text":"","category":"section"},{"location":"generated/tutorial_logo/","page":"The old Peridynamics.jl logo","title":"The old Peridynamics.jl logo","text":"    <video controls loop=\"true\">\n        <source src=\"https://github.com/user-attachments/assets/0761ba02-f69a-4f3a-b5c5-0f219548070f\" />\n    </video>","category":"page"},{"location":"generated/tutorial_logo/","page":"The old Peridynamics.jl logo","title":"The old Peridynamics.jl logo","text":"(Visualization made with ParaView)","category":"page"},{"location":"generated/tutorial_logo/","page":"The old Peridynamics.jl logo","title":"The old Peridynamics.jl logo","text":"The Julia logo crashing into a plate and braking it into many pieces.","category":"page"},{"location":"generated/tutorial_logo/","page":"The old Peridynamics.jl logo","title":"The old Peridynamics.jl logo","text":"First, we have to load the Peridynamics.jl package.","category":"page"},{"location":"generated/tutorial_logo/","page":"The old Peridynamics.jl logo","title":"The old Peridynamics.jl logo","text":"using Peridynamics","category":"page"},{"location":"generated/tutorial_logo/#Plate","page":"The old Peridynamics.jl logo","title":"Plate","text":"","category":"section"},{"location":"generated/tutorial_logo/","page":"The old Peridynamics.jl logo","title":"The old Peridynamics.jl logo","text":"Now we create the plate in the background by specifying the dimensions and the point spacing.","category":"page"},{"location":"generated/tutorial_logo/","page":"The old Peridynamics.jl logo","title":"The old Peridynamics.jl logo","text":"lxy = 0.1\nlz = 0.01\nΔX₀ₚ = lxy / 50\nposₚ, volₚ = uniform_box(lxy, lxy, lz, ΔX₀ₚ)\nplate = Body(BBMaterial{EnergySurfaceCorrection}(), posₚ, volₚ)","category":"page"},{"location":"generated/tutorial_logo/","page":"The old Peridynamics.jl logo","title":"The old Peridynamics.jl logo","text":"Then we define the material properties for the plate.","category":"page"},{"location":"generated/tutorial_logo/","page":"The old Peridynamics.jl logo","title":"The old Peridynamics.jl logo","text":"Horizon delta = 3015 Delta x_p\nDensity rho = 2000mathrmkgmathrmm^-3\nYoungs modulus E = 30 times 10^9  mathrmPa\nGriffith's parameter G_c = 10  mathrmN  mathrmm^-1","category":"page"},{"location":"generated/tutorial_logo/","page":"The old Peridynamics.jl logo","title":"The old Peridynamics.jl logo","text":"material!(plate; horizon=3.015ΔX₀ₚ, E=30e9, rho=2000, Gc=10)","category":"page"},{"location":"generated/tutorial_logo/#Julia-logo-spheres","page":"The old Peridynamics.jl logo","title":"Julia-logo spheres","text":"","category":"section"},{"location":"generated/tutorial_logo/","page":"The old Peridynamics.jl logo","title":"The old Peridynamics.jl logo","text":"A spherical body is created, where only the points inside a specified radius are preserved to create the spheres of the logo. These points are then copied three times and moved to the correct position to represent the logo.","category":"page"},{"location":"generated/tutorial_logo/","page":"The old Peridynamics.jl logo","title":"The old Peridynamics.jl logo","text":"Ø = 0.03\nΔX₀ₛ = Ø / 20\ncz = Ø / 2 + lz / 2 + 1.1 * ΔX₀ₛ\nr_logo = Ø / 2 + 0.2 * Ø\nsxy, cxy = r_logo * sin(30π / 180), r_logo * cos(30π / 180)\nposₛ₁, volₛ₁ = uniform_sphere(Ø, ΔX₀ₛ; center=(0, r_logo, cz))\nposₛ₂, volₛ₂ = uniform_sphere(Ø, ΔX₀ₛ; center=(cxy, -sxy, cz))\nposₛ₃, volₛ₃ = uniform_sphere(Ø, ΔX₀ₛ; center=(-cxy, -sxy, cz))\nsphere₁ = Body(BBMaterial(), posₛ₁, volₛ₁)\nsphere₂ = Body(BBMaterial(), posₛ₂, volₛ₂)\nsphere₃ = Body(BBMaterial(), posₛ₃, volₛ₃)","category":"page"},{"location":"generated/tutorial_logo/","page":"The old Peridynamics.jl logo","title":"The old Peridynamics.jl logo","text":"Material properties for the spheres are specified.","category":"page"},{"location":"generated/tutorial_logo/","page":"The old Peridynamics.jl logo","title":"The old Peridynamics.jl logo","text":"Horizon delta = 3015 Delta x_s\nDensity rho = 7850mathrmkgmathrmm^-3\nYoungs modulus E = 210 times 10^9  mathrmPa\nGriffith's parameter G_c = 1000  mathrmN  mathrmm^-1","category":"page"},{"location":"generated/tutorial_logo/","page":"The old Peridynamics.jl logo","title":"The old Peridynamics.jl logo","text":"All material points of the spheres have a initial velocity of -20 mathrmm  mathrms^-1 in z-direction.","category":"page"},{"location":"generated/tutorial_logo/","page":"The old Peridynamics.jl logo","title":"The old Peridynamics.jl logo","text":"for sphere in (sphere₁, sphere₂, sphere₃)\n    material!(sphere; horizon=3.015ΔX₀ₛ, E=210e9, rho=7850, Gc=1000)\n    velocity_ic!(sphere, :all_points, :z, -20)\nend","category":"page"},{"location":"generated/tutorial_logo/","page":"The old Peridynamics.jl logo","title":"The old Peridynamics.jl logo","text":"Multibody Setup? For the contact analysis, all bodies need to be specified in a MultibodySetup.","category":"page"},{"location":"generated/tutorial_logo/","page":"The old Peridynamics.jl logo","title":"The old Peridynamics.jl logo","text":"ms = MultibodySetup(:plate => plate, :sphere1 => sphere₁, :sphere2 => sphere₂,\n                    :sphere3 => sphere₃)","category":"page"},{"location":"generated/tutorial_logo/","page":"The old Peridynamics.jl logo","title":"The old Peridynamics.jl logo","text":"Contact between the plate and the three spheres needs to be specified.","category":"page"},{"location":"generated/tutorial_logo/","page":"The old Peridynamics.jl logo","title":"The old Peridynamics.jl logo","text":"contact!(ms, :plate, :sphere1; radius=ΔX₀ₚ)\ncontact!(ms, :plate, :sphere2; radius=ΔX₀ₚ)\ncontact!(ms, :plate, :sphere3; radius=ΔX₀ₚ)","category":"page"},{"location":"generated/tutorial_logo/","page":"The old Peridynamics.jl logo","title":"The old Peridynamics.jl logo","text":"For this simulation, 3000 time steps with explicit time integration and the Velocity Verlet algorithm are used.","category":"page"},{"location":"generated/tutorial_logo/","page":"The old Peridynamics.jl logo","title":"The old Peridynamics.jl logo","text":"vv = VelocityVerlet(steps=3000)","category":"page"},{"location":"generated/tutorial_logo/","page":"The old Peridynamics.jl logo","title":"The old Peridynamics.jl logo","text":"Now we create a directory for the results and create a Job.","category":"page"},{"location":"generated/tutorial_logo/","page":"The old Peridynamics.jl logo","title":"The old Peridynamics.jl logo","text":"job = Job(ms, vv; path=\"results/logo\")","category":"page"},{"location":"generated/tutorial_logo/","page":"The old Peridynamics.jl logo","title":"The old Peridynamics.jl logo","text":"To complete everything, the Job is submitted for simulation.","category":"page"},{"location":"generated/tutorial_logo/","page":"The old Peridynamics.jl logo","title":"The old Peridynamics.jl logo","text":"submit(job)","category":"page"},{"location":"expl_general_pd/#expl_pd_basics","page":"Basics of peridynamics theory","title":"Basics of peridynamics theory","text":"","category":"section"},{"location":"expl_general_pd/","page":"Basics of peridynamics theory","title":"Basics of peridynamics theory","text":"Peridynamics is a nonlocal continuum mechanics formulation, which was introduced by Silling [Sil00]. It has gained increased popularity as an approach for modeling fracture. The deformation of the solid is described by integro-differential equations that are also fulfilled for discontinuities, making it very capable of modeling crack propagation and fragmentation with large displacements. Much peridynamics research has been done in recent years, summarized in various review papers and books [DPL19, JMOO19, MO14].","category":"page"},{"location":"expl_general_pd/","page":"Basics of peridynamics theory","title":"Basics of peridynamics theory","text":"<img src=\"https://github.com/kaipartmann/Peridynamics.jl/assets/68582683/728da1f0-4750-4ab6-a430-9b206e475577\" width=\"300\"/>","category":"page"},{"location":"expl_general_pd/","page":"Basics of peridynamics theory","title":"Basics of peridynamics theory","text":"Typically, in peridynamics the continuum is discretized by material points. Points interact only with other points inside of their specified neighborhood or point family mathcalH, which is defined as the set of points inside a sphere with the radius delta, also named the horizon. The interaction of the point boldsymbolX with its neighbor boldsymbolX is called bond and defined as","category":"page"},{"location":"expl_general_pd/","page":"Basics of peridynamics theory","title":"Basics of peridynamics theory","text":"boldsymbolDelta X = boldsymbolX - boldsymbolX  ","category":"page"},{"location":"expl_general_pd/","page":"Basics of peridynamics theory","title":"Basics of peridynamics theory","text":"The equation of motion reads","category":"page"},{"location":"expl_general_pd/","page":"Basics of peridynamics theory","title":"Basics of peridynamics theory","text":"varrho  boldsymbolddotu(boldsymbolXt) = boldsymbolb^mathrmint(boldsymbolXt) + boldsymbolb^mathrmext(boldsymbolXt)  ","category":"page"},{"location":"expl_general_pd/","page":"Basics of peridynamics theory","title":"Basics of peridynamics theory","text":"with the mass density varrho, the point acceleration vector boldsymbolddotu, and the point force density vectors boldsymbolb^mathrmint and boldsymbolb^mathrmext. Various material formulations of peridynamics exist for the calculation of the internal force density boldsymbolb^mathrmint, and all of them are based on the nonlocal interactions between material points.","category":"page"},{"location":"expl_general_pd/","page":"Basics of peridynamics theory","title":"Basics of peridynamics theory","text":"The general internal force density for state-based peridynamics is defined as","category":"page"},{"location":"expl_general_pd/","page":"Basics of peridynamics theory","title":"Basics of peridynamics theory","text":"boldsymbolb^mathrmint (boldsymbolXt) = int_mathcalH boldsymbolt - boldsymbolt  mathrmdV  ","category":"page"},{"location":"expl_general_pd/","page":"Basics of peridynamics theory","title":"Basics of peridynamics theory","text":"with the force vector states boldsymbolt=boldsymbolt(boldsymbolDelta X t) and boldsymbolt=boldsymbolt(-boldsymbolDelta X t). In the first original bond-based formulation of peridynamics, the force vector states boldsymbolt and  boldsymbolt have the same value and opposite direction. This implies intrinsic limitation to only one material parameter and in consequence to restrictions on the Poisson's ratio [SEW+07, TS20]. To overcome these restrictions, state-based peridynamics was established. In the ordinary state-based peridynamics, the deformation states of neighboring points also influence the internal force density [SEW+07]. This leads to force vector states which are still collinear but not of same value anymore.","category":"page"},{"location":"expl_general_pd/","page":"Basics of peridynamics theory","title":"Basics of peridynamics theory","text":"Further developments are summarized as non-ordinary state-based peridynamics. A recent development in this regard is continuum-kinematics-inspired peridynamics [JMS19]. Another peridynamic formulation is the local continuum consistent correspondence formulation of non-ordinary state-based peridynamics, where an elastic model from the classical local material theory can be used to calculate the internal force density.","category":"page"},{"location":"expl_bondbased/#expl_bb","page":"Bond-based peridynamics","title":"Bond-based peridynamics","text":"","category":"section"},{"location":"expl_bondbased/","page":"Bond-based peridynamics","title":"Bond-based peridynamics","text":"The initial version of peridynamics is the bond-based (BB) formulation. [Sil00]","category":"page"},{"location":"expl_bondbased/","page":"Bond-based peridynamics","title":"Bond-based peridynamics","text":"Here, a pairwise force function boldsymbolf is defined and calculated for each bond of two material points, which depends on the strain of the bond and is aligned in its direction: ","category":"page"},{"location":"expl_bondbased/","page":"Bond-based peridynamics","title":"Bond-based peridynamics","text":" boldsymbolf = c  varepsilon^ij  boldsymboln  ","category":"page"},{"location":"expl_bondbased/","page":"Bond-based peridynamics","title":"Bond-based peridynamics","text":"Here the micro-modulus constant [SA05]","category":"page"},{"location":"expl_bondbased/","page":"Bond-based peridynamics","title":"Bond-based peridynamics","text":"c = frac18  kappapi  delta^4 ","category":"page"},{"location":"expl_bondbased/","page":"Bond-based peridynamics","title":"Bond-based peridynamics","text":"and the strain of the bond [SB05]","category":"page"},{"location":"expl_bondbased/","page":"Bond-based peridynamics","title":"Bond-based peridynamics","text":"varepsilon^ij = fracl^ij-L^ijL^ij","category":"page"},{"location":"expl_bondbased/","page":"Bond-based peridynamics","title":"Bond-based peridynamics","text":"with bond lengths L^ij =leftboldsymbolDelta X^ijright and l^ij =leftboldsymbolDelta x^ijright are used.","category":"page"},{"location":"expl_bondbased/","page":"Bond-based peridynamics","title":"Bond-based peridynamics","text":"The direction vector","category":"page"},{"location":"expl_bondbased/","page":"Bond-based peridynamics","title":"Bond-based peridynamics","text":"boldsymboln = fracboldsymbolDelta x^ijl^ij","category":"page"},{"location":"expl_bondbased/","page":"Bond-based peridynamics","title":"Bond-based peridynamics","text":"is oriented in the direction of the bond. ","category":"page"},{"location":"expl_bondbased/","page":"Bond-based peridynamics","title":"Bond-based peridynamics","text":"To get the resulting body forces, now the force function is integrated over the whole body:","category":"page"},{"location":"expl_bondbased/","page":"Bond-based peridynamics","title":"Bond-based peridynamics","text":"boldsymbolb^mathrminti = boldsymbolb^mathrmint (boldsymbolX ^ i  t) = int_mathcalH_i boldsymbolf  mathrmdV^j  ","category":"page"},{"location":"expl_bondbased/","page":"Bond-based peridynamics","title":"Bond-based peridynamics","text":"Size Symbol Unit\nPairwise force function boldsymbolf leftfracmathrmkgmathrmm^5mathrms^2right\nMicro-modulus constant [SA05] c leftfracmathrmkgmathrmm^5mathrms^2right\nBond strain varepsilon^ij -\nBond in mathcalB_0 boldsymbolDelta X^ij mathrmm\nBond in mathcalB_t boldsymbolDelta x^ij mathrmm\nBond length in mathcalB_0 L^ij mathrmm\nBond length in mathcalB_t l^ij mathrmm\nDirection vector boldsymboln -\nVolume of point j V^j leftmathrmm^3right\nInternal force density boldsymbolb^mathrminti leftfracmathrmkgmathrmm^2mathrms^2right","category":"page"},{"location":"howto_mpi/#Simulations-with-MPI","page":"Simulations with MPI","title":"Simulations with MPI","text":"","category":"section"},{"location":"howto_mpi/","page":"Simulations with MPI","title":"Simulations with MPI","text":"The package is designed so that the same core functions are used and only a small backend handles the differences between MPI or multithreading. This means, the development goal was:","category":"page"},{"location":"howto_mpi/","page":"Simulations with MPI","title":"Simulations with MPI","text":"Code that runs with multithreading should also work with MPI without changes!","category":"page"},{"location":"howto_mpi/","page":"Simulations with MPI","title":"Simulations with MPI","text":"However, currently not all features are supported with MPI. A table with an overview is shown below.","category":"page"},{"location":"howto_mpi/#Currently-supported-features:","page":"Simulations with MPI","title":"Currently supported features:","text":"","category":"section"},{"location":"howto_mpi/","page":"Simulations with MPI","title":"Simulations with MPI","text":"Job type MPI\nJob(::Body, ::VelocityVerlet) ✅\nJob(::Body, ::DynamicRelaxation) ✅\nJob(::MultibodySetup, ::VelocityVerlet) ❌","category":"page"},{"location":"howto_mpi/#Setting-up-simulations-for-MPI","page":"Simulations with MPI","title":"Setting up simulations for MPI","text":"","category":"section"},{"location":"howto_mpi/","page":"Simulations with MPI","title":"Simulations with MPI","text":"If a script containing a simulation runs with multithreading and the features are supported with MPI, then this same script can be run with:","category":"page"},{"location":"howto_mpi/","page":"Simulations with MPI","title":"Simulations with MPI","text":"mpiexecjl -n <number of ranks> julia --project path/to/script.jl","category":"page"},{"location":"howto_mpi/","page":"Simulations with MPI","title":"Simulations with MPI","text":"Please refer to the MPI.jl documentation of mpiexecjl for installation and setup instructions.","category":"page"},{"location":"howto_mpi/","page":"Simulations with MPI","title":"Simulations with MPI","text":"Furthermore, there are helper functions that improve the setup of MPI simulations, such as enable_mpi_timers!, @mpiroot, @mpitime, or mpi_isroot.","category":"page"},{"location":"generated/tutorial_cylinder/#tutorial_cylinder","page":"Fragmenting Cylinder","title":"Fragmenting Cylinder","text":"","category":"section"},{"location":"generated/tutorial_cylinder/","page":"Fragmenting Cylinder","title":"Fragmenting Cylinder","text":"A cylinder fragmenting into many pieces, inspired by the  peridigm example.","category":"page"},{"location":"generated/tutorial_cylinder/","page":"Fragmenting Cylinder","title":"Fragmenting Cylinder","text":"We use the point cloud created by peridigm for their corresponding example. You can download the file containing the data from this page on their repository.","category":"page"},{"location":"generated/tutorial_cylinder/","page":"Fragmenting Cylinder","title":"Fragmenting Cylinder","text":"To start, import the package:","category":"page"},{"location":"generated/tutorial_cylinder/","page":"Fragmenting Cylinder","title":"Fragmenting Cylinder","text":"using Peridynamics","category":"page"},{"location":"generated/tutorial_cylinder/","page":"Fragmenting Cylinder","title":"Fragmenting Cylinder","text":"First a function is written that can read our .txt-file containing the data of the point cloud and convert it into the position and volume, which we need to define our Body. For this we need the package DelimitedFiles.jl.","category":"page"},{"location":"generated/tutorial_cylinder/","page":"Fragmenting Cylinder","title":"Fragmenting Cylinder","text":"using DelimitedFiles\nfunction fragmenting_cylinder_geometry(input_mesh_file::AbstractString)\n    input_raw = readdlm(input_mesh_file)\n    position = copy(input_raw[:, 1:3]')\n    volume = copy(input_raw[:, 5])\n    return position, volume\nend","category":"page"},{"location":"generated/tutorial_cylinder/","page":"Fragmenting Cylinder","title":"Fragmenting Cylinder","text":"Now we specify the storage path of the file.","category":"page"},{"location":"generated/tutorial_cylinder/","page":"Fragmenting Cylinder","title":"Fragmenting Cylinder","text":"input_mesh_file = joinpath(@__DIR__, \"..\", \"assets\", \"fragmenting_cylinder.txt\")","category":"page"},{"location":"generated/tutorial_cylinder/","page":"Fragmenting Cylinder","title":"Fragmenting Cylinder","text":"To get the information we need, we use our function defined above.","category":"page"},{"location":"generated/tutorial_cylinder/","page":"Fragmenting Cylinder","title":"Fragmenting Cylinder","text":"position, volume = fragmenting_cylinder_geometry(input_mesh_file)","category":"page"},{"location":"generated/tutorial_cylinder/","page":"Fragmenting Cylinder","title":"Fragmenting Cylinder","text":"Using this data, we can create a Body which represents the cylinder.","category":"page"},{"location":"generated/tutorial_cylinder/","page":"Fragmenting Cylinder","title":"Fragmenting Cylinder","text":"body = Body(BBMaterial(), position, volume)","category":"page"},{"location":"generated/tutorial_cylinder/","page":"Fragmenting Cylinder","title":"Fragmenting Cylinder","text":"We specify the material parameters of the cylinder.","category":"page"},{"location":"generated/tutorial_cylinder/","page":"Fragmenting Cylinder","title":"Fragmenting Cylinder","text":"material!(body, horizon=0.00417462, rho=7800, E=195e9, epsilon_c=0.02)","category":"page"},{"location":"generated/tutorial_cylinder/","page":"Fragmenting Cylinder","title":"Fragmenting Cylinder","text":"Then some initial velocity conditions in x-, y- and z-direction are employed to provoke the fracture of the cylinder.","category":"page"},{"location":"generated/tutorial_cylinder/","page":"Fragmenting Cylinder","title":"Fragmenting Cylinder","text":"velocity_ic!(p -> (200-50*((p[3]/0.05)-1)^2)*cos(atan(p[2],p[1])), body, :all_points, :x)\nvelocity_ic!(p -> (200-50*((p[3]/0.05)-1)^2)*sin(atan(p[2],p[1])), body, :all_points, :y)\nvelocity_ic!(p -> 100*((p[3]/0.05)-1), body, :all_points, :z)","category":"page"},{"location":"generated/tutorial_cylinder/","page":"Fragmenting Cylinder","title":"Fragmenting Cylinder","text":"We employ the Velocity Verlet algorithm for a total time span of 2.5e-4 seconds.","category":"page"},{"location":"generated/tutorial_cylinder/","page":"Fragmenting Cylinder","title":"Fragmenting Cylinder","text":"vv = VelocityVerlet(time=2.5e-4)","category":"page"},{"location":"generated/tutorial_cylinder/","page":"Fragmenting Cylinder","title":"Fragmenting Cylinder","text":"Finally the job is created","category":"page"},{"location":"generated/tutorial_cylinder/","page":"Fragmenting Cylinder","title":"Fragmenting Cylinder","text":"job = Job(body, vv; path=\"results/fragmenting_cylinder\", freq=10)","category":"page"},{"location":"generated/tutorial_cylinder/","page":"Fragmenting Cylinder","title":"Fragmenting Cylinder","text":"and subsequently submitted.","category":"page"},{"location":"generated/tutorial_cylinder/","page":"Fragmenting Cylinder","title":"Fragmenting Cylinder","text":"submit(job)","category":"page"},{"location":"generated/tutorial_cylinder/","page":"Fragmenting Cylinder","title":"Fragmenting Cylinder","text":"    <video controls loop=\"true\">\n        <source src=\"https://github.com/user-attachments/assets/91a274dc-7e45-4a21-9283-414b86199e48\" />\n    </video>","category":"page"},{"location":"","page":"Home","title":"Home","text":"<p align=\"center\">\n  <img src=\"assets/logo.png\" width=\"300\" />\n  <br>\n  <picture>\n    <source media=\"(prefers-color-scheme: dark)\" srcset=\"https://github.com/kaipartmann/Peridynamics.jl/assets/68582683/817c7bd4-9c02-4cc4-ac66-998c0f5e95e2\">\n    <source media=\"(prefers-color-scheme: light)\" srcset=\"https://github.com/kaipartmann/Peridynamics.jl/assets/68582683/70c24007-5aa9-460f-9a97-c67b1df32750\">\n    <img alt=\"The Peridynamics.jl logo\" src=\"https://github.com/kaipartmann/Peridynamics.jl/assets/68582683/70c24007-5aa9-460f-9a97-c67b1df32750\" width=\"400\">\n  </picture>\n</p>","category":"page"},{"location":"","page":"Home","title":"Home","text":"A high-level Julia package for parallel peridynamics simulations","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"To install Peridynamics.jl, follow these steps:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Install Julia from the official Julia website if you haven't already.\nLaunch Julia and open the Julia REPL.\nEnter the package manager by pressing ] in the REPL.\nIn the package manager, type:\nadd Peridynamics\nPress Backspace or Ctrl + C to exit the package manager.","category":"page"},{"location":"#How-to-guides","page":"Home","title":"How-to guides","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Simulations with MPI\nVisualize results with ParaView","category":"page"},{"location":"#Tutorials","page":"Home","title":"Tutorials","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"<div class=\"tutorial-grid\">","category":"page"},{"location":"","page":"Home","title":"Home","text":"<div class=\"tutorial-element\">\n   <a href=\"https://kaipartmann.github.io/Peridynamics.jl/stable/generated/tutorial_tension_static/\">\n      <figcaption>Tensile test quasi-static</figcaption><br><img src=\"https://github.com/kaipartmann/Peridynamics.jl/assets/68582683/ac69d8aa-526d-436a-aa0c-820a1f42bcca\" style=\"width: 90% !important;\"/>\n   </a>\n</div>","category":"page"},{"location":"","page":"Home","title":"Home","text":"<div class=\"tutorial-element\">\n   <a href=\"https://kaipartmann.github.io/Peridynamics.jl/stable/generated/tutorial_tension_dynfrac/\">\n      <figcaption>Tensile test dynamic</figcaption><br><img src=\"https://github.com/kaipartmann/Peridynamics.jl/assets/68582683/dda2b7b3-d44b-41a9-b133-6d1b548df1c1\" style=\"width: 90% !important;\"/>\n   </a>\n</div>","category":"page"},{"location":"","page":"Home","title":"Home","text":"<div class=\"tutorial-element\">\n   <a href=\"https://kaipartmann.github.io/Peridynamics.jl/stable/generated/tutorial_tension_precrack/\">\n      <figcaption>Tension with predefined crack</figcaption><br><img src=\"https://github.com/kaipartmann/Peridynamics.jl/assets/68582683/9f627d2d-44b5-43a3-94cd-9d34894fd142\" style=\"width: 90% !important;\"/>\n   </a>\n</div>","category":"page"},{"location":"","page":"Home","title":"Home","text":"<div class=\"tutorial-element\">\n   <a href=\"https://kaipartmann.github.io/Peridynamics.jl/stable/generated/tutorial_logo/\">\n      <figcaption>The old logo</figcaption><br><img src=\"https://github.com/kaipartmann/Peridynamics.jl/assets/68582683/5439e112-9088-49a3-bb01-aff541adc0f8\" style=\"width: 90% !important;\"/>\n   </a>\n</div>","category":"page"},{"location":"","page":"Home","title":"Home","text":"<div class=\"tutorial-element\">\n   <a href=\"https://kaipartmann.github.io/Peridynamics.jl/stable/generated/tutorial_kalthoff-winkler_dynfrac/\">\n      <figcaption>Kalthoff Winkler</figcaption><br><img src=\"https://github.com/kaipartmann/Peridynamics.jl/assets/68582683/6dc362ef-4997-4327-9bc1-41350fac2dc1\" style=\"width: 90% !important;\"/>\n   </a>\n</div>","category":"page"},{"location":"","page":"Home","title":"Home","text":"<div class=\"tutorial-element\">\n   <a href=\"https://kaipartmann.github.io/Peridynamics.jl/stable/generated/tutorial_cylinder/\">\n      <figcaption>Fragmenting cylinder</figcaption><br><img src=\"https://github.com/user-attachments/assets/58e11123-6143-4e13-8642-7e30c9e6c86d\" style=\"width: 90% !important;\"/>\n   </a>\n</div>","category":"page"},{"location":"","page":"Home","title":"Home","text":"<div class=\"tutorial-element\">\n   <a href=\"https://kaipartmann.github.io/Peridynamics.jl/stable/generated/tutorial_wave_in_bar/\">\n      <figcaption>Wave propagation</figcaption><br><img src=\"https://github.com/user-attachments/assets/7fa65fd4-38d8-46cb-833f-990417211d17\" style=\"width: 90% !important;\"/>\n   </a>\n</div>","category":"page"},{"location":"","page":"Home","title":"Home","text":"<div class=\"tutorial-element\">\n   <a href=\"https://kaipartmann.github.io/Peridynamics.jl/stable/generated/tutorial_wave_interface/\">\n      <figcaption>Wave propagation across interface</figcaption><br><img src=\"https://github.com/user-attachments/assets/082f635f-caf2-40db-938e-e4a98e2f3915\" style=\"width: 90% !important;\"/>\n   </a>\n</div>","category":"page"},{"location":"","page":"Home","title":"Home","text":"<div class=\"tutorial-element\">\n   <a href=\"https://kaipartmann.github.io/Peridynamics.jl/stable/generated/tutorial_brazilian_test/\">\n      <figcaption>Brazilian test</figcaption><br><img src=\"https://github.com/user-attachments/assets/2f78a983-98d5-42eb-bc32-4fb270238ceb\" style=\"width: 90% !important;\"/>\n   </a>\n</div>","category":"page"},{"location":"","page":"Home","title":"Home","text":"</div>","category":"page"},{"location":"#Authors","page":"Home","title":"Authors","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"<ul>\n<li><a href=\"https://orcid.org/0000-0002-5238-4355\">Kai Partmann (University of Siegen) <img alt=\"ORCID logo\" src=\"https://info.orcid.org/wp-content/uploads/2019/11/orcid_16x16.png\" width=\"16\" height=\"16\" /></a></li>\n<li><a href=\"https://orcid.org/0009-0004-9195-0112\">Manuel Dienst (University of Siegen) <img alt=\"ORCID logo\" src=\"https://info.orcid.org/wp-content/uploads/2019/11/orcid_16x16.png\" width=\"16\" height=\"16\" /></a></li>\n<li><a href=\"https://orcid.org/0000-0002-2213-8401\">Kerstin Weinberg (University of Siegen) <img alt=\"ORCID logo\" src=\"https://info.orcid.org/wp-content/uploads/2019/11/orcid_16x16.png\" width=\"16\" height=\"16\" /></a></li>\n</ul>","category":"page"},{"location":"#Acknowledgements","page":"Home","title":"Acknowledgements","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"<img src=https://github.com/kaipartmann/Peridynamics.jl/assets/68582683/0d14a65b-4e05-4408-8107-59ac9c1477d2 width=500>","category":"page"},{"location":"","page":"Home","title":"Home","text":"The authors gratefully acknowledge the support of the Deutsche Forschungsgemeinschaft (DFG) under the project WE2525-14/1.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The support of Carsten Bauer and Xin Wu from PC2 with the design of the internal structure regarding parallel performance is gratefully acknowledged.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The authors gratefully acknowledge the computing time provided to them on the high-performance computer Noctua 2 at the NHR Center PC2. These are funded by the Federal Ministry of Education and Research and the state governments participating on the basis of the resolutions of the GWK for the national highperformance computing at universities (www.nhr-verein.de/unsere-partner).","category":"page"},{"location":"generated/tutorial_wave_in_bar/#tut_wave","page":"Wave propagation in a thin bar","title":"Wave propagation in a thin bar","text":"","category":"section"},{"location":"generated/tutorial_wave_in_bar/","page":"Wave propagation in a thin bar","title":"Wave propagation in a thin bar","text":"In this tutorial, a cuboid bar is created. A velocity pulse in the form of one period of a sine wave is applied to create a displacement wave that propagates through the bar. The behaviour of this wave was investigated in [PDW24].","category":"page"},{"location":"generated/tutorial_wave_in_bar/","page":"Wave propagation in a thin bar","title":"Wave propagation in a thin bar","text":"First import the Peridynamics.jl package:","category":"page"},{"location":"generated/tutorial_wave_in_bar/","page":"Wave propagation in a thin bar","title":"Wave propagation in a thin bar","text":"using Peridynamics","category":"page"},{"location":"generated/tutorial_wave_in_bar/","page":"Wave propagation in a thin bar","title":"Wave propagation in a thin bar","text":"To get started, some parameters used for this simulation are defined. These are the length of the bar lx, the width and height lyz and the number of points in the width npyz.","category":"page"},{"location":"generated/tutorial_wave_in_bar/","page":"Wave propagation in a thin bar","title":"Wave propagation in a thin bar","text":"lx = 0.2\nlyz = 0.002\nnpyz = 4","category":"page"},{"location":"generated/tutorial_wave_in_bar/","page":"Wave propagation in a thin bar","title":"Wave propagation in a thin bar","text":"With these parameters the point spacing Δx can be calculated:","category":"page"},{"location":"generated/tutorial_wave_in_bar/","page":"Wave propagation in a thin bar","title":"Wave propagation in a thin bar","text":"Δx = lyz / npyz","category":"page"},{"location":"generated/tutorial_wave_in_bar/","page":"Wave propagation in a thin bar","title":"Wave propagation in a thin bar","text":"A cuboid body according to the ordinary state-based model with the specified dimensions and point spacing is then created:","category":"page"},{"location":"generated/tutorial_wave_in_bar/","page":"Wave propagation in a thin bar","title":"Wave propagation in a thin bar","text":"pos, vol = uniform_box(lx, lyz, lyz, Δx)\nbody = Body(OSBMaterial(), pos, vol)","category":"page"},{"location":"generated/tutorial_wave_in_bar/","page":"Wave propagation in a thin bar","title":"Wave propagation in a thin bar","text":"Following material parameters are specified:","category":"page"},{"location":"generated/tutorial_wave_in_bar/","page":"Wave propagation in a thin bar","title":"Wave propagation in a thin bar","text":"material parameter value\nHorizon $ δ $ 3015 cdot Δx\nDensity ρ $ 7850\\,\\mathrm{kg}\\,\\mathrm{m}^{-3}$\nYoung's modulus E $ 210 \\, \\mathrm{GPa}$\nPoisson's ratio ν 025","category":"page"},{"location":"generated/tutorial_wave_in_bar/","page":"Wave propagation in a thin bar","title":"Wave propagation in a thin bar","text":"material!(body, horizon=3.015Δx, rho=7850.0, E=210e9, nu=0.25)","category":"page"},{"location":"generated/tutorial_wave_in_bar/","page":"Wave propagation in a thin bar","title":"Wave propagation in a thin bar","text":"Failure is prohibited throughout the body since no fracture parameters are defined. Point set :left including the first row of points in x-direction is created:","category":"page"},{"location":"generated/tutorial_wave_in_bar/","page":"Wave propagation in a thin bar","title":"Wave propagation in a thin bar","text":"point_set!(x -> x < -lx / 2 + 1.2Δx, body, :left)","category":"page"},{"location":"generated/tutorial_wave_in_bar/","page":"Wave propagation in a thin bar","title":"Wave propagation in a thin bar","text":"The velocity boundary condition of the form","category":"page"},{"location":"generated/tutorial_wave_in_bar/","page":"Wave propagation in a thin bar","title":"Wave propagation in a thin bar","text":"    v_x (t) =\n    begincases\n        v_mathrmmax cdot sin(2pi cdot fractT) qquad\n         forall  0 leq t leq T \n        0 textelse\n    endcases","category":"page"},{"location":"generated/tutorial_wave_in_bar/","page":"Wave propagation in a thin bar","title":"Wave propagation in a thin bar","text":"(Image: ) is applied to point set :left. The parameters used for this excitation are period length T and amplitude vmax.","category":"page"},{"location":"generated/tutorial_wave_in_bar/","page":"Wave propagation in a thin bar","title":"Wave propagation in a thin bar","text":"T, vmax = 1.0e-5, 2.0\nvelocity_bc!(t -> t < T ? vmax * sin(2π / T * t) : 0.0, body, :left, :x)","category":"page"},{"location":"generated/tutorial_wave_in_bar/","page":"Wave propagation in a thin bar","title":"Wave propagation in a thin bar","text":"The Velocity Verlet algorithm is used as time integration method and 2000 time steps are calculated:","category":"page"},{"location":"generated/tutorial_wave_in_bar/","page":"Wave propagation in a thin bar","title":"Wave propagation in a thin bar","text":"vv = VelocityVerlet(steps=2000)","category":"page"},{"location":"generated/tutorial_wave_in_bar/","page":"Wave propagation in a thin bar","title":"Wave propagation in a thin bar","text":"The job is now defined with the specified settings and parameters.","category":"page"},{"location":"generated/tutorial_wave_in_bar/","page":"Wave propagation in a thin bar","title":"Wave propagation in a thin bar","text":"job = Job(body, vv; path=\"results/xwave\")","category":"page"},{"location":"generated/tutorial_wave_in_bar/","page":"Wave propagation in a thin bar","title":"Wave propagation in a thin bar","text":"The last step is submitting the job to start the simulation.","category":"page"},{"location":"generated/tutorial_wave_in_bar/","page":"Wave propagation in a thin bar","title":"Wave propagation in a thin bar","text":"submit(job)","category":"page"},{"location":"generated/tutorial_wave_in_bar/","page":"Wave propagation in a thin bar","title":"Wave propagation in a thin bar","text":"    <video controls loop=\"true\">\n        <source src=\"https://github.com/user-attachments/assets/b9839787-f265-43f4-9d57-a33375ad9610\" />\n    </video>","category":"page"}]
}
