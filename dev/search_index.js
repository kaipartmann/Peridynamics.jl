var documenterSearchIndex = {"docs":
[{"location":"private_api_reference/#Private-API","page":"Private API","title":"Private API","text":"Pages = [\"private_api_reference.md\"]","category":"section"},{"location":"private_api_reference/#Types","page":"Private API","title":"Types","text":"","category":"section"},{"location":"private_api_reference/#Functions","page":"Private API","title":"Functions","text":"","category":"section"},{"location":"private_api_reference/#Macros","page":"Private API","title":"Macros","text":"","category":"section"},{"location":"private_api_reference/#Experimental-Features","page":"Private API","title":"Experimental Features","text":"","category":"section"},{"location":"private_api_reference/#Peridynamics.InterfaceError","page":"Private API","title":"Peridynamics.InterfaceError","text":"InterfaceError\n\nA type for a customized error that is thrown when a material model is not implemented correctly.\n\nFields\n\ntype::DataType: Type that is used.\nfunc::String: Function that is used.\n\n\n\n\n\n","category":"type"},{"location":"private_api_reference/#Peridynamics.NaNError","page":"Private API","title":"Peridynamics.NaNError","text":"NaNError\n\nA type for a customized error that is thrown when NaN values are detected in the internal force density field after the force density evaluation.\n\nFields\n\ntime::Float64: Simulation time when NaNs were detected.\nstep::Int: Simulation step when NaNs were detected.\n\n\n\n\n\n","category":"type"},{"location":"private_api_reference/#Peridynamics.HaloExchange","page":"Private API","title":"Peridynamics.HaloExchange","text":"HaloExchange\n\nA type used for communication between body chunks. This type is used with both MPI and multithreaded simulations. Note that the tag is only used with MPI and has the value 0 in multithreaded simulations.\n\nFields\n\ntag::Int: Tag used for the MPI sending and receiving commands.\nsrc_chunk_id::Int: Index of the chunk that sends information.\ndest_chunk_id::Int: Index of the chunk that receives information.\nsrc_idxs::Vector{Int}: Indices of the points in the source chunk that send information.\ndest_idxs::Vector{Int}: Indices of the points in the destination chunk that receive   information.\n\n\n\n\n\n","category":"type"},{"location":"private_api_reference/#Peridynamics.JobOptions","page":"Private API","title":"Peridynamics.JobOptions","text":"JobOptions{F,V}\n\nA type that contains the options of a job.\n\nType Parameters\n\nF: Type for fields of simulation.\nV: Type for basename of vtk-files.\n\nFields\n\nexport_allowed::Bool: Specify if data is exported for the job.\nroot::String: Path of the folder where all data is saved.\nvtk::String: Path of the folder where vtk-files are saved.\nlogfile::String: Complete path of the logfile.\nfreq::Int: Frequency of exported time steps.\nfields::F: Exported fields of the job.\nvtk_filebase::V: Basename of exported vtk-files.\n\n\n\n\n\n","category":"type"},{"location":"private_api_reference/#Peridynamics.MPIHaloInfo","page":"Private API","title":"Peridynamics.MPIHaloInfo","text":"MPIHaloInfo\n\nA type providing information about the halo points of body chunks.\n\nFields\n\npoint_ids::Dict{Int,Vector{Int}}: Indices of local and halo points of each chunk.\nhalos_points::Dict{Int,Vector{Int}}: Indices of halo points of each chunk.\nlocalizers::Dict{Int,Dict{Int,Int}}: Localizes global indices to local indices in the   corresponding chunks.\nhidxs_by_src::Dict{Int,Dict{Int,Vector{Int}}}: Dict specifying for each chunk the   indices of halo points but depending on the chunk they belong to.\n\n\n\n\n\n","category":"type"},{"location":"private_api_reference/#Peridynamics.MPIBodyDataHandler","page":"Private API","title":"Peridynamics.MPIBodyDataHandler","text":"MPIBodyDataHandler\n\nA type for handling information and communication for a body chunk in MPI.\n\nType Parameters\n\nSys: Type of system of the body.\nM: Type of the material model.\nP: Material parameter type.\nS: Storage type of the system.\nBufs: Type for buffers.\n\nFields\n\nchunk::BodyChunk{Sys,M,P,S}: Body chunk of the body.\nn_halo_fields::Int: Number of chunks in communication with this chunk due to existing   halo points.\nlth_exs_send::Vector{HaloExchange}: Local-to-halo-exchanges of the body chunk that   send information.\nlth_exs_recv::Vector{HaloExchange}: Local-to-halo-exchanges of the body chunk that   receive information.\nhtl_exs_send::Vector{HaloExchange}: Halo-to-local-exchanges of the body chunk that   send information.\nhtl_exs_recv::Vector{HaloExchange}: Halo-to-local-exchanges of the body chunk that   receive information.\nlth_send_bufs::Vector{Bufs}: Buffers for local-to-halo-exchanges that send information.\nlth_recv_bufs::Vector{Bufs}: Buffers for local-to-halo-exchanges that receive   information.\nhtl_send_bufs::Vector{Bufs}: Buffers for halo-to-local-exchanges that send information.\nhtl_recv_bufs::Vector{Bufs}: Buffers for halo-to-local-exchanges that receive   information.\nfield_to_buf::Dict{Symbol,Int}: Dict specifying the index in the buffer of each field   of the simulation.\nlth_reqs::Vector{Vector{MPI.Request}}: Pre-allocated buffer for requests for   local-to-halo-exchanges.\nhtl_reqs::Vector{Vector{MPI.Request}}: Pre-allocated buffer for requests for   halo-to-local-exchanges.\n\n\n\n\n\n","category":"type"},{"location":"private_api_reference/#Peridynamics.SingleParamChunk","page":"Private API","title":"Peridynamics.SingleParamChunk","text":"SingleParamChunk\n\nType for a body chunk of a body with only one material parameter set.\n\n\n\n\n\n","category":"type"},{"location":"private_api_reference/#Peridynamics.MultiParamChunk","page":"Private API","title":"Peridynamics.MultiParamChunk","text":"MultiParamChunk\n\nType for a body chunk of a body with multiple material parameter sets.\n\n\n\n\n\n","category":"type"},{"location":"private_api_reference/#Peridynamics.ParameterHandler","page":"Private API","title":"Peridynamics.ParameterHandler","text":"ParameterHandler\n\nA type used to manage multiple point parameters defined for the same body. It is used to assign different point parameters to the points of a body.\n\nType Parameters\n\nP<:AbstractPointParameters: Point parameter type.\n\nFields\n\nparameters::Vector{P}: All parameter sets defined in the simulation.\npoint_mapping::Vector{Int}: Vector assigning the related parameter set to each   material point.\n\n\n\n\n\n","category":"type"},{"location":"private_api_reference/#Peridynamics.ThreadsBodyDataHandler","page":"Private API","title":"Peridynamics.ThreadsBodyDataHandler","text":"ThreadsBodyDataHandler\n\nA type for handling all data of a body in multithreading simulations.\n\nType Parameters\n\nSys: Type of system of the body.\nM: Type of the material model.\nP: Material parameter type.\nS: Storage type of the system.\n\nFields\n\nn_chunks::Int: Number of chunks of the body.\nchunks::Vector{BodyChunk{Sys,M,P,S}}: All body chunks of the body.\nlth_exs::Vector{Vector{HaloExchange}}: All local-to-halo-exchanges of each body chunk   of the body.\nhtl_exs::Vector{Vector{HaloExchange}}: All halo-to-local-exchanges of each body chunk   of the body.\n\n\n\n\n\n","category":"type"},{"location":"private_api_reference/#Peridynamics.ThreadsMultibodyDataHandler","page":"Private API","title":"Peridynamics.ThreadsMultibodyDataHandler","text":"ThreadsMultibodyDataHandler\n\nA type for handling all data of multiple bodies in multithreading simulations.\n\nType Parameters\n\nBDH: Body data handler type.\nPC: Position cache type.\nVC: Volume cache type.\n\nFields\n\nn_bodies::Int: Number of bodies in the simulation.\nbody_dhs::BDH: Tuple containing all body data handlers.\nbody_names::Vector{Symbol}: Names of the bodies.\nbody_idxs::Dict{Symbol,Int}: Names of bodies assigned to their indices.\nsrf_contacts::Vector{ShortRangeForceContact}: All short range force contacts of this   simulation.\nposition_caches::PC: Positions of all points of all bodies (should be of type   Vector{Matrix{Float64}}).\nvolume_caches::VC: Volumes of all points of all bodies (should be of type   Vector{Vector{Float64}}).\n\n\n\n\n\n","category":"type"},{"location":"private_api_reference/#Peridynamics.BodyChunk","page":"Private API","title":"Peridynamics.BodyChunk","text":"BodyChunk{System, Material, Params, Storage}\n\nA type that contains all data of a body chunk. For parallel simulations, the body is divided into multiple chunks. Each BodyChunk instance contains all necessary information for the simulation on this specific chunk. This type is used for multithreading and MPI.\n\nType Parameters\n\nSystem<:AbstractSystem: Type of the system.\nMaterial<:AbstractMaterial: Type of the material model of the system.\nParams<:AbstractParameterSetup: Material parameters of the points in the body chunk.\nStorage<:AbstractStorage: Storage of all information that changes during the simulation.\n\nFields\n\nbody_name::Symbol: Name of the body in multibody simulations.\nsystem::System: System with all information that is known before the simulation.\nmat::Material: Material model of the system.\nparamsetup::Params: Material parameters of the points in the body chunk.\nstorage::Storage: Storage of all information that changes during the simulation.\npsets::Dict{Symbol,Vector{Int}}: Point sets of the chunk with local indices.\nsdbcs::Vector{SingleDimBC}: Single dimension boundary conditions.\npdsdbcs::Vector{PosDepSingleDimBC}: Position dependent single dimension boundary   conditions.\ncells::Vector{MeshCell{VTKCellType,Tuple{Int64}}}: Cells for vtk export.\n\n\n\n\n\n","category":"type"},{"location":"private_api_reference/#Peridynamics.Bond","page":"Private API","title":"Peridynamics.Bond","text":"Bond\n\nType that describes a bond of two points in a peridynamics body.\n\nFields\n\nneighbor::Int: The index of the neighbor point with which the bond is formed.\nlength::Float64: The length of the bond.\nfail_permit::Bool: Describes whether failure is allowed or not for this bond.\n\n\n\n\n\n","category":"type"},{"location":"private_api_reference/#Peridynamics.BondSystem","page":"Private API","title":"Peridynamics.BondSystem","text":"BondSystem{Correction}\n\nA type for a system for all peridynamic formulations that work with just bonds of two points.\n\nType Parameters\n\nCorrection<:AbstractCorrection: Applied surface correction.\n\nFields\n\nposition::Matrix{Float64}: Positions of all points of the system.\nvolume::Vector{Float64}: Volumes of the points of the system.\nbonds::Vector{Bond}: Vector containing all bonds of the bond system.\nn_neighbors::Vector{Int}: Number of neighbors for each point of the system.\nbond_ids::Vector{UnitRange{Int}}: Range of the bonds vector containing bonds of   considered point.\ncorrection::Correction: Applied surface correction.\nchunk_handler::ChunkHandler: Type to handle the chunks for the simulation.   See ChunkHandler.\n\n\n\n\n\n","category":"type"},{"location":"private_api_reference/#Peridynamics.ChunkHandler","page":"Private API","title":"Peridynamics.ChunkHandler","text":"ChunkHandler\n\nA type to handle a body chunk and its communication to other chunks.\n\nFields\n\nn_loc_points::Int: Number of local points that belong to the body chunk.\npoint_ids::Vector{Int}: Indices of all local and halo points of the chunk.\nloc_points::UnitRange{Int}: Indices of local points of the chunk.\nhalo_points::Vector{Int}: Indices of halo points of the chunk.\nhidxs_by_src::Dict{Int,UnitRange{Int}}: Dict specifying the indices of halo Points   depending on the body chunk they belong to. So body_chunk => indices, with indices   being the indices of the halo points in point_ids.\nlocalizer::Dict{Int,Int}: Localizes global indices to local indices in this chunk.\n\n\n\n\n\n","category":"type"},{"location":"private_api_reference/#Peridynamics.PointDecomposition","page":"Private API","title":"Peridynamics.PointDecomposition","text":"PointDecomposition\n\nA type that describes how a body is divided into multiple body chunks.\n\nFields\n\nn_chunks::Int: Number of body chunks.\ndecomp::Vector{UnitRange{Int}}: Indices of the points belonging to each chunk.\npoint_src::Dict{Int,Int}: Dict that assigns all point indices to the chunk they belong   to.\n\n\n\n\n\n","category":"type"},{"location":"private_api_reference/#Peridynamics.TwoNeighborInteraction","page":"Private API","title":"Peridynamics.TwoNeighborInteraction","text":"TwoNeighborInteraction\n\nType for two-neighbor interactions.\n\nFields\n\noni_j::Int: One-neighbor interaction of considered point with point j.\noni_k::Int: One-neighbor interaction of considered point with point k.\nsurface::Float64: Surface spread by this two-neighbor interaction.\n\n\n\n\n\n","category":"type"},{"location":"private_api_reference/#Peridynamics.ThreeNeighborInteraction","page":"Private API","title":"Peridynamics.ThreeNeighborInteraction","text":"ThreeNeighborInteraction\n\nType for three-neighbor interactions.\n\nFields\n\noni_j::Int: One-neighbor interaction of considered point with point j.\noni_k::Int: One-neighbor interaction of considered point with point k.\noni_l::Int: One-neighbor interaction of considered point with point l.\nvolume::Float64: Volume spread by this three-neighbor interaction.\n\n\n\n\n\n","category":"type"},{"location":"private_api_reference/#Peridynamics.InteractionSystem","page":"Private API","title":"Peridynamics.InteractionSystem","text":"InteractionSystem\n\nA peridynamic system type that is mainly designed for continuum-kinematics-inspired peridynamics [JMS19].\n\nFields\n\nposition::Matrix{Float64}: Positions of all points of the system.\none_nis::Vector{Bond}: Vector containing all one-neighbor interactions (bonds) of the   system.\ntwo_nis::Vector{TwoNeighborInteraction}: Vector containing all two-neighbor   interactions of the system.\nthree_nis::Vector{ThreeNeighborInteraction}: Vector containing all three-neighbor   interactions of the system.\nvolume::Vector{Float64}: Volumes of the points of the system.\nvolume_one_nis::Vector{Float64}: Effective volumes of one-neighbor interactions.\nvolume_two_nis::Vector{Float64}: Effective volumes of two-neighbor interactions.\nvolume_three_nis::Vector{Float64}: Effective volumes of three-neighbor interactions.\nn_one_nis::Vector{Int}: Number of one-neighbor interactions for each point of the   system.\nn_two_nis::Vector{Int}: Number of two-neighbor interactions for each point of the   system.\nn_three_nis::Vector{Int}: Number of three-neighbor interactions for each point of the   system.\none_ni_idxs::Vector{UnitRange{Int}}: Range of the one-neighbor interactions vector   containing interactions of considered point.\ntwo_ni_idxs::Vector{UnitRange{Int}}: Range of the two-neighbor interactions vector   containing interactions of considered point.\nthree_ni_idxs::Vector{UnitRange{Int}}: Range of the three-neighbor interactions vector   containing interactions of considered point.\nchunk_handler::ChunkHandler: Type to handle the chunks for the simulation.   See ChunkHandler.\n\n\n\n\n\n","category":"type"},{"location":"private_api_reference/#Peridynamics.PointSetsPreCrack","page":"Private API","title":"Peridynamics.PointSetsPreCrack","text":"PointSetsPreCrack\n\nType describing a predefined crack in a peridynamic body.\n\nFields\n\nset_a::Symbol: Point set containing points on one side of the crack.\nset_b::Symbol: Point set with points on other side of the crack.\nfilter_bonds::Bool: If true, the involved bonds are filtered out so no damage is   present at the beginning of the simulation. Else, all involved bonds are marked broken   from the beginning.\n\n\n\n\n\n","category":"type"},{"location":"private_api_reference/#Peridynamics.StandardPointParameters","page":"Private API","title":"Peridynamics.StandardPointParameters","text":"StandardPointParameters\n\nType containing the material parameters for a standard peridynamics model using the bond-based, ordinary state-based or non-ordinary state-based correspondence formulation of peridynamics.\n\nFields\n\nδ::Float64: Horizon.\nrho::Float64: Density.\nE::Float64: Young's modulus.\nnu::Float64: Poisson's ratio.\nG::Float64: Shear modulus.\nK::Float64: Bulk modulus.\nλ::Float64: 1st Lamé parameter.\nμ::Float64: 2nd Lamé parameter.\nGc::Float64: Critical energy release rate.\nεc::Float64: Critical strain.\nbc::Float64: Bond constant.\n\n\n\n\n\n","category":"type"},{"location":"private_api_reference/#Peridynamics.SingleDimBC","page":"Private API","title":"Peridynamics.SingleDimBC","text":"SingleDimBC{F}\n\nType for a boundary condition in a single dimension for a peridynamic simulation.\n\nType Parameters\n\nF<:Function: Time dependent function which describes the boundary condition.\n\nFields\n\nfun::F: Time dependent function which describes the boundary condition.\nfield::Symbol: Field of the condition (e.g. velocity, force density).\npoint_set::Symbol: Point set on which the condition is applied.\ndim::UInt8: Dimension in which the condition is applied.\n\n\n\n\n\n","category":"type"},{"location":"private_api_reference/#Peridynamics.PosSingleDimBC","page":"Private API","title":"Peridynamics.PosSingleDimBC","text":"PosSingleDimBC{F}\n\nType for a position dependent boundary condition in a single dimension for a peridynamic simulation.\n\nType Parameters\n\nF<:Function: A position dependent function which describes the boundary   condition, not time dependent.\n\nFields\n\nfun::F: Position dependent function which describes the boundary condition.\nfield::Symbol: Field of the condition (e.g. velocity, force density).\npoint_set::Symbol: Point set on which the condition is applied.\ndim::UInt8: Dimension in which the condition is applied.\n\n\n\n\n\n","category":"type"},{"location":"private_api_reference/#Peridynamics.PosDepSingleDimBC","page":"Private API","title":"Peridynamics.PosDepSingleDimBC","text":"PosDepSingleDimBC{F}\n\nType for a position dependent boundary condition in a single dimension for a peridynamic simulation.\n\nType Parameters\n\nF<:Function: Position and time dependent function which describes the boundary   condition.\n\nFields\n\nfun::F: Position and time dependent function which describes the boundary condition.\nfield::Symbol: Field of the condition (e.g. velocity, force density).\npoint_set::Symbol: Point set on which the condition is applied.\ndim::UInt8: Dimension in which the condition is applied.\n\n\n\n\n\n","category":"type"},{"location":"private_api_reference/#Peridynamics.CKIPointParameters","page":"Private API","title":"Peridynamics.CKIPointParameters","text":"CKIPointParameters\n\nType containing the material parameters for a continuum-kinematics-inspired peridynamics model.\n\nFields\n\nδ::Float64: Horizon.\nrho::Float64: Density.\nE::Float64: Young's modulus.\nnu::Float64: Poisson's ratio.\nG::Float64: Shear modulus.\nK::Float64: Bulk modulus.\nλ::Float64: 1st Lamé parameter.\nμ::Float64: 2nd Lamé parameter.\nGc::Float64: Critical energy release rate.\nεc::Float64: Critical strain.\nC1::Float64: Material constant for one-neighbor interactions.\nC2::Float64: Material constant for two-neighbor interactions.\nC3::Float64: Material constant for three-neighbor interactions.\n\n\n\n\n\n","category":"type"},{"location":"private_api_reference/#Peridynamics.BACPointParameters","page":"Private API","title":"Peridynamics.BACPointParameters","text":"BACPointParameters\n\nType containing the material parameters for a peridynamics model using the bond-associated correspondence formulation of Chen and Spencer.\n\nFields\n\nδ::Float64: Horizon.\nδb::Float64: Bond-associated horizon.\nrho::Float64: Density.\nE::Float64: Young's modulus.\nnu::Float64: Poisson's ratio.\nG::Float64: Shear modulus.\nK::Float64: Bulk modulus.\nλ::Float64: 1st Lamé parameter.\nμ::Float64: 2nd Lamé parameter.\nGc::Float64: Critical energy release rate.\nεc::Float64: Critical strain.\nbc::Float64: Bond constant.\n\n\n\n\n\n","category":"type"},{"location":"private_api_reference/#Peridynamics.SingleDimIC","page":"Private API","title":"Peridynamics.SingleDimIC","text":"SingleDimIC\n\nType for an initial condition in a single dimension for a peridynamic simulation.\n\nFields\n\nvalue::Float64: Value of the condition.\nfield::Symbol: Field of the condition (e.g. velocity, force density).\npoint_set::Symbol: Point set on which the condition is applied.\ndim::UInt8: Dimension in which the condition is applied.\n\n\n\n\n\n","category":"type"},{"location":"private_api_reference/#Peridynamics.PosDepSingleDimIC","page":"Private API","title":"Peridynamics.PosDepSingleDimIC","text":"PosDepSingleDimIC{F}\n\nType for a position dependent initial condition in a single dimension for a peridynamic simulation.\n\nType Parameters\n\nF<:Function: Position dependent function which describes the initial condition.\n\nFields\n\nfun::F: Position dependent function which describes the initial condition.\nfield::Symbol: Field of the condition (e.g. velocity, force density).\npoint_set::Symbol: Point set on which the condition is applied.\ndim::UInt8: Dimension in which the condition is applied.\n\n\n\n\n\n","category":"type"},{"location":"private_api_reference/#Peridynamics.ShortRangeForceContact","page":"Private API","title":"Peridynamics.ShortRangeForceContact","text":"ShortRangeForceContact\n\nA type for contact simulations with the short range forces algorithm.\n\nType Parameters\n\nN: Neighborhood search object used by PointNeighbors.jl.\n\nFields\n\nbody_id_a::Symbol: Index of a body of the contact.\nbody_id_b::Symbol: Index of a body of the contact.\nradius::Float64: Search radius for contact.\npenalty_factor::Float64: Penalty factor for the contact simulation.\nnhs::N: Neighborhood search object used by PointNeighbors.jl.\n\n\n\n\n\n","category":"type"},{"location":"private_api_reference/#Peridynamics.failure_permit!","page":"Private API","title":"Peridynamics.failure_permit!","text":"failure_permit!(body, set_name, fail_permit)\n\nSet the failure permission for points of the set set_name of a body.\n\nArguments\n\nbody::AbstractBody: Body where the failure permission will be set.\nset_name::Symbol: The name of a point set of this body.\nfail_permit::Bool: If true, failure is allowed, and if false then no bonds of this   point are allowed to break during the simulation.\n\ndanger: Overwriting failure permission with `material!` and `failure_permit!`\nThe function material! calls failure_permit!, so if it is used afterwards, previously set failure permissions might be overwritten!\n\nThrows\n\nError if the body does not contain a set with set_name.\n\n\n\n\n\n","category":"function"},{"location":"private_api_reference/#Peridynamics.get_frac_params","page":"Private API","title":"Peridynamics.get_frac_params","text":"get_frac_params(::AbstractDamageModel, p::Dict{Symbol,Any}, δ::Float64, K::Float64)\n\nRead or calculate the necessary fracture parameters for the specified damage model from the dictionary created with material!. This function has to be defined when creating a new damage model. Otherwise, a default method returns a empty named tuple (; ).\n\n\n\n\n\n","category":"function"},{"location":"private_api_reference/#Peridynamics.set_failure_permissions!","page":"Private API","title":"Peridynamics.set_failure_permissions!","text":"set_failure_permissions!(body, set_name, params)\n\nGrant or prohibit failure permission depending on the submitted fracture parameters by calling failure_permit!.\n\nIf fracture parameters are found, failure is allowed. If no fracture parameters are found, failure is not allowed.\n\n\n\n\n\n","category":"function"},{"location":"private_api_reference/#Peridynamics.has_fracture","page":"Private API","title":"Peridynamics.has_fracture","text":"has_fracture(mat, params)\n\nReturn true if at least one fracture parameter is set !=0 in params and the system therefore is supposed to have failure allowed or return false if not.\n\n\n\n\n\n","category":"function"},{"location":"private_api_reference/#Peridynamics.check_pos_and_vol","page":"Private API","title":"Peridynamics.check_pos_and_vol","text":"check_pos_and_vol(n_points, position, volume)\n\nCheck if the positions and volumes for the points are correctly specified in the fields of a Body.\n\n\n\n\n\n","category":"function"},{"location":"private_api_reference/#Peridynamics.pre_submission_check","page":"Private API","title":"Peridynamics.pre_submission_check","text":"pre_submission_check(body::Body; body_in_multibody_setup::Bool=false)\npre_submission_check(ms::AbstractMultibodySetup)\n\nCheck if necessary material parameters and conditions are defined when defining a Job.\n\n\n\n\n\n","category":"function"},{"location":"private_api_reference/#Peridynamics.get_paramsetup","page":"Private API","title":"Peridynamics.get_paramsetup","text":"get_paramsetup(body::AbstractBody, ::AbstractChunkHandler, ::SingleParamChunk)\nget_paramsetup(body::AbstractBody, ch::AbstractChunkHandler, ::MultiParamChunk)\n\nReturn the parameters of a BodyChunk if only one parameter set is defined for the corresponding Body or the parameter handler if multiple parameter sets are defined.\n\n\n\n\n\n","category":"function"},{"location":"private_api_reference/#Peridynamics.get_params","page":"Private API","title":"Peridynamics.get_params","text":"get_params(paramhandler::ParameterHandler, point_id::Int)\nget_params(params::AbstractPointParameters, ::Int)\nget_params(chunk::BodyChunk, point_id::Int)\n\nReturn parameters of a specific point with index point_id of a Body with parameters params or parameter handler paramhandler or of the body chunk.\n\n\n\n\n\n","category":"function"},{"location":"private_api_reference/#Peridynamics.check_if_sets_intersect","page":"Private API","title":"Peridynamics.check_if_sets_intersect","text":"check_if_sets_intersect(point_sets, key_a, key_b)\n\nThrow error if two sets chosen for precrack! have common points.\n\n\n\n\n\n","category":"function"},{"location":"private_api_reference/#Peridynamics.check_if_set_is_defined","page":"Private API","title":"Peridynamics.check_if_set_is_defined","text":"check_if_set_is_defined(point_sets, set_name)\n\nThrow an error if no point set set_name is found in the dictionary point_sets.\n\n\n\n\n\n","category":"function"},{"location":"private_api_reference/#Peridynamics.find_points","page":"Private API","title":"Peridynamics.find_points","text":"find_points(f, position)\n\nFind all points whose positions meet function f.\n\nThe function f accepts only one positional argument and will be used in a findall call. Depending on the argument name, a different input will be processed. See point_set!.\n\n\n\n\n\n","category":"function"},{"location":"private_api_reference/#Peridynamics.apply_precracks!","page":"Private API","title":"Peridynamics.apply_precracks!","text":"apply_precracks!(chunk, body)\n\nApply all predefined cracks for chunk by calling apply_precrack! for each crack.\n\n\n\n\n\n","category":"function"},{"location":"private_api_reference/#Peridynamics.apply_precrack!","page":"Private API","title":"Peridynamics.apply_precrack!","text":"apply_precrack!(chunk, body, crack)\n\nApply the predefined crack of the body for the considered chunk by breaking the concerned bonds.\n\n\n\n\n\n","category":"function"},{"location":"private_api_reference/#Peridynamics.point_sets_intersect","page":"Private API","title":"Peridynamics.point_sets_intersect","text":"point_sets_intersect(point_sets, key_a, key_b)\n\nReturn true if point sets key_a and key_b out of the dictionary point_sets have at least one common point, return false if they do not.\n\n\n\n\n\n","category":"function"},{"location":"private_api_reference/#Peridynamics.invreg","page":"Private API","title":"Peridynamics.invreg","text":"invreg(M::StaticMatrix{N,N,T}, λ::Real, β::Real) where {N,T}\n\nComputes the regularized pseudo-inverse of a square static matrix M using a combination of Tikhonov regularization in the SVD domain and truncated singular value regularization.\n\nArguments\n\nM::StaticMatrix{N,N,T}: The square N×N static matrix with element type T to be   inverted.\nλ::Real: Relative Tikhonov regularization parameter (dimensionless, non-negative).   Controls the smoothing strength applied as   lambda_texteff = lambda sigma_max, where sigma_max is the   largest singular value of M.\nβ::Real: Relative SVD truncation parameter (dimensionless, non-negative). Defines the   cutoff threshold as beta_texteff = beta sigma_max for excluding   small singular values.\n\nReturns\n\nMinv::StaticMatrix{N,N,T}: The regularized pseudo-inverse of the input matrix M.\n\nRegularization Techniques\n\nThe function applies two complementary regularization strategies:\n\nSVD-based Tikhonov Regularization: For each singular value sigma_i, the inverse  is computed as sigma_i(sigma_i^2 + lambda_texteff^2), which smoothly  dampens the contribution of small singular values without completely removing them.\nTruncated SVD: Singular values below the threshold beta_texteff are  completely excluded by setting their contribution to zero, preventing numerical  instability from near-zero singular values.\n\nnote: Scale-invariant regularization\nBoth lambda and beta are internally scaled by the largest singular value sigma_max, making them relative regularization strengths independent of the matrix scale. This makes parameter selection more robust and transferable across different problems with varying magnitudes.\n\nParameter Selection Guidelines\n\nλ (Tikhonov parameter):\nWell-conditioned matrices: lambda = 0 (no Tikhonov regularization, recommended   default)\nMild regularization: lambda in 0 10^-12 (scale-invariant gentle   smoothing)\nModerate regularization: lambda in 10^-12 10^-4 (for moderately   ill-conditioned problems)\nNote: Values lambda  10^-4 may introduce noticeable bias in the solution\nβ (truncation parameter): Primary regularization mechanism, less sensitive than   lambda.\nWell-conditioned matrices: beta in sqrtepsilon 10^-6 (remove   numerical noise, recommended default)\nModerately ill-conditioned: beta in 10^-6 10^-4 (moderate truncation)\nSeverely ill-conditioned: beta in 10^-4 10^-2 (aggressive truncation)\n\n\n\n\n\n","category":"function"},{"location":"private_api_reference/#Peridynamics.update_sim_success_from_log!","page":"Private API","title":"Peridynamics.update_sim_success_from_log!","text":"update_sim_success_from_log!(study::Study)\n\nRead the study.logfile and update study.sim_success flags according to the last recorded status for each job. This allows resuming processing or submission after an interrupted run.\n\n\n\n\n\n","category":"function"},{"location":"private_api_reference/#Peridynamics.@storage","page":"Private API","title":"Peridynamics.@storage","text":"@storage material storage\n@storage material solver storage\n\nA macro for automatic creation of a storage type. The macro then maps a specified material type with the storage structure. When no solver is specified, this storage is always used independently of the solver type. Specifying a solver allows the usage of customized storages for a solver.\n\nThe following macros can be used before field definitions inside the storage struct:\n\n@pointfield: Specifies a point field (data that each point has). Most of the time a   Matrix (column i is a vectorial quantity of the local point i) or a Vector   (entry i is a scalar value of local point i).\n@lthfield: Specifies a point field with local-to-halo exchange during the simulation   (creates a buffer and automatically updates this field when running the local-to-halo   update functions).\n@htlfield: Specifies a point field with halo-to-local exchange during the simulation,   similar to @lthfield.\n\nExample\n\nExample definition of the storage for the bond-based material:\n\n@storage BBMaterial struct BBStorage <: AbstractStorage\n    @lthfield position::Matrix{Float64}\n    @pointfield displacement::Matrix{Float64}\n    @pointfield velocity::Matrix{Float64}\n    @pointfield velocity_half::Matrix{Float64}\n    @pointfield velocity_half_old::Matrix{Float64}\n    @pointfield acceleration::Matrix{Float64}\n    @pointfield b_int::Matrix{Float64}\n    @pointfield b_int_old::Matrix{Float64}\n    @pointfield b_ext::Matrix{Float64}\n    @pointfield density_matrix::Matrix{Float64}\n    @pointfield damage::Vector{Float64}\n    bond_active::Vector{Bool}\n    @pointfield n_active_bonds::Vector{Int}\nend\n\n\n\n\n\n","category":"macro"},{"location":"private_api_reference/#Peridynamics.@autoinfiltrate","page":"Private API","title":"Peridynamics.@autoinfiltrate","text":"@autoinfiltrate\n@autoinfiltrate condition::Bool\n\nInvoke the @infiltrate macro of the package Infiltrator.jl to create a breakpoint for ad-hoc interactive debugging in the REPL. If the optional argument condition is given, the breakpoint is only enabled if condition evaluates to true.\n\nAs opposed to using Infiltrator.@infiltrate directly, this macro does not require Infiltrator.jl to be added as a dependency to Peridynamics.jl. As a bonus, the macro will also attempt to load the Infiltrator module if it has not yet been loaded manually.\n\nNote: For this macro to work, the Infiltrator.jl package needs to be installed in your current Julia environment stack.\n\nSee also: Infiltrator.jl\n\n\n\n\n\n","category":"macro"},{"location":"private_api_reference/#Peridynamics.velocity_databc!","page":"Private API","title":"Peridynamics.velocity_databc!","text":"velocity_databc!(body, data, set_name, dims)\n\ndanger: Experimental feature\nPlease note that this is an experimental feature. It is not part of the public API of Peridynamics.jl, and thus can be altered (or removed) at any time without it being considered a breaking change. Also, the feature may be incomplete and/or contain bugs. Please use with caution.\n\nSpecifies velocity boundary conditions for points of the set set_name in body. The value of the boundary condition is assigned by reading the corresponding positions in the matrix data. Multiple dimensions can be handled at once.\n\nwarning: Compatibility feature with other packages\nThis method / feature is used for compatibility with other packages developing with Peridynamics.jl. It is likely to change in the future, since the functionality of updating the values of the matrix during the simulation is not yet implemented. Consequently, at this stage, it is only available as a private API to facilitate future modifications and ensure easier implementation of changes.\n\nArguments\n\nbody::AbstractBody: Body the condition is specified on.\ndata::Matrix: A matrix of size length(dims) x n_points that contains the values of   the boundary condition for each point in the body. But only the conditions of points   contained in the set set_name are applied during the simulation! It should be noted,   that the value of the data matrix is constant and currently cannot be updated during   the simulation. The data matrix is not checked for NaN values, since this is handled   in the apply_bc! function. If it contains NaN values, then these values are ignored.\nset_name::Symbol: The name of a point set of this body. The condition applies only to   the points in this set, even if the data matrix contains values for all points in the   body.\ndims::Vector{Union{Integer,Symbol}}: Vector containing the directions of the condition   that should be applied, either specified as Symbol or integer.\nx-direction: :x or 1\ny-direction: :y or 2\nz-direction: :z or 3\nIt should not contain more than 3 elements, and the elements should be unique. The order   of the elements does not matter, however it must match the values in the data matrix.   So if the first column of the data matrix contains the values for the x-direction,   then the first element of dims should be 1 or :x, and so on.\n\nThrows\n\nErrors if the body does not contain a set with set_name.\nErrors if the directions are not correctly specified.\nErrors if the dimensions of the data matrix are incorrect.\n\n\n\n\n\n","category":"function"},{"location":"private_api_reference/#Peridynamics.forcedensity_databc!","page":"Private API","title":"Peridynamics.forcedensity_databc!","text":"forcedensity_databc!(body, data, set_name, dims)\n\ndanger: Experimental feature\nPlease note that this is an experimental feature. It is not part of the public API of Peridynamics.jl, and thus can be altered (or removed) at any time without it being considered a breaking change. Also, the feature may be incomplete and/or contain bugs. Please use with caution.\n\nSpecifies forcedensity boundary conditions for points of the set set_name in body. The value of the boundary condition is assigned by reading the corresponding positions in the matrix data. Multiple dimensions can be handled at once.\n\nwarning: Compatibility feature with other packages\nThis method / feature is used for compatibility with other packages developing with Peridynamics.jl. It is likely to change in the future, since the functionality of updating the values of the matrix during the simulation is not yet implemented. Consequently, at this stage, it is only available as a private API to facilitate future modifications and ensure easier implementation of changes.\n\nArguments\n\nbody::AbstractBody: Body the condition is specified on.\ndata::Matrix: A matrix of size length(dims) x n_points that contains the values of   the boundary condition for each point in the body. But only the conditions of points   contained in the set set_name are applied during the simulation! It should be noted,   that the value of the data matrix is constant and currently cannot be updated during   the simulation. The data matrix is not checked for NaN values, since this is handled   in the apply_bc! function. If it contains NaN values, then these values are ignored.\nset_name::Symbol: The name of a point set of this body. The condition applies only to   the points in this set, even if the data matrix contains values for all points in the   body.\ndims::Vector{Union{Integer,Symbol}}: Vector containing the directions of the condition   that should be applied, either specified as Symbol or integer.\nx-direction: :x or 1\ny-direction: :y or 2\nz-direction: :z or 3\nIt should not contain more than 3 elements, and the elements should be unique. The order   of the elements does not matter, however it must match the values in the data matrix.   So if the first column of the data matrix contains the values for the x-direction,   then the first element of dims should be 1 or :x, and so on.\n\nThrows\n\nErrors if the body does not contain a set with set_name.\nErrors if the directions are not correctly specified.\nErrors if the dimensions of the data matrix are incorrect.\n\n\n\n\n\n","category":"function"},{"location":"expl_references/#References","page":"References","title":"References","text":"P. Diehl, S. Prudhomme and M. Lévesque. A Review of Benchmark Experiments for the Validation of Peridynamics Models. Journal of Peridynamics and Nonlocal Modeling 1, 14–35 (2019).\n\n\n\nA. Javili, A. McBride and P. Steinmann. Continuum-kinematics-inspired peridynamics. Mechanical problems. Journal of the Mechanics and Physics of Solids 131 (2019).\n\n\n\nA. Javili, R. Morasata, E. Oterkus and S. Oterkus. Peridynamics review. Mathematics and Mechanics of Solids 24, 3714–3739 (2019).\n\n\n\nQ. Le and F. Bobaru. Surface corrections for peridynamic models in elasticity and fracture. Computational Mechanics 61, 1–20 (2018).\n\n\n\nE. Madenci and E. Oterkus. Peridynamic Theory and Its Applications (Springer New York, New York, 2014).\n\n\n\nK. Partmann, M. Dienst and K. Weinberg. Peridynamic computations of wave propagation and reflection at material interfaces. Archive of Applied Mechanics (2024).\n\n\n\nS. A. Silling. Reformulation of elasticity theory for discontinuities and long-range forces. Journal of the Mechanics and Physics of Solids 48, 175–209 (2000).\n\n\n\nS. A. Silling, M. Epton, O. Weckner, J. Xu and E. Askari. Peridynamic States and Constitutive Modeling. Journal of Elasticity 88, 151–184 (2007). Accessed on Oct 15, 2020.\n\n\n\nS. Silling and E. Askari. A meshfree method based on the peridynamic model of solid mechanics. Computers & Structures 83, 1526–1535 (2005).\n\n\n\nS. Silling and F. Bobaru. Peridynamic modeling of membranes and fibers. International Journal of Non-Linear Mechanics 40, 395–409 (2005). Special Issue in Honour of C.O. Horgan.\n\n\n\nJ. Trageser and P. Seleson. Bond-Based Peridynamics: a Tale of Two Poisson's Ratios. Journal of Peridynamics and Nonlocal Modeling 2, 278–288 (2020).\n\n\n\n","category":"section"},{"location":"howto_visualization/#visualization","page":"Visualization with ParaView","title":"Visualization with ParaView","text":"The following section explains a few visualization basics with ParaView (ParaView 5.10.1 on macOS Monterey).","category":"section"},{"location":"howto_visualization/#Basics","page":"Visualization with ParaView","title":"Basics","text":"","category":"section"},{"location":"howto_visualization/#1.-Load-the-results","page":"Visualization with ParaView","title":"1. Load the results","text":"Load the resulting .vtu files into ParaView with File rightarrow Open.\n\n<img src=\"https://github.com/kaipartmann/Peridynamics.jl/assets/68582683/a5cfb0f2-db8a-4c3b-9f9e-6fc1c66b3716\" width=\"600\" />","category":"section"},{"location":"howto_visualization/#2.-Select-the-time-array","page":"Visualization with ParaView","title":"2. Select the time array","text":"Select the time array and all the parameters you want to analyze and then Apply.\n\n<img src=\"https://github.com/kaipartmann/Peridynamics.jl/assets/68582683/32246ca6-548d-4883-87e0-c9fb88baffd4\" width=\"1000\" />","category":"section"},{"location":"howto_visualization/#3.-Representation-and-coloring","page":"Visualization with ParaView","title":"3. Representation and coloring","text":"Change the representation to Points and then choose the coloring parameter.\n\n<img src=\"https://github.com/kaipartmann/Peridynamics.jl/assets/68582683/78c618e8-0a3b-455c-a1f7-707079714479\" width=\"1000\" />","category":"section"},{"location":"howto_visualization/#4.-Point-styling","page":"Visualization with ParaView","title":"4. Point styling","text":"Activate the setting to render points as spheres and set an appropriate point size.\n\n<img src=\"https://github.com/kaipartmann/Peridynamics.jl/assets/68582683/484cdf0a-16ac-4c64-b2b4-9ad96ca6c817\" width=\"1000\" />","category":"section"},{"location":"howto_visualization/#5.-Legend-styling","page":"Visualization with ParaView","title":"5. Legend styling","text":"By default, the legend limits are set for the current range of the coloring parameter. In this example, for the initial time step all damage values are zero so strange legend limits appear.\n\n<img src=\"https://github.com/kaipartmann/Peridynamics.jl/assets/68582683/7a38a834-1157-469b-9b79-3c3b24388c39\" width=\"1000\" />","category":"section"},{"location":"howto_visualization/#6.-Save-animation","page":"Visualization with ParaView","title":"6. Save animation","text":"To generate a animation, use File rightarrow Save Animation... and follow the instructions.","category":"section"},{"location":"howto_visualization/#Additional-Learning-Resources","page":"Visualization with ParaView","title":"Additional Learning Resources","text":"ParaView has a great documentation and a lot of resources for learning. For example, see:\n\nParaView Documentation\nParaView User's Guide","category":"section"},{"location":"dev_materials/#Materials","page":"Materials","title":"Materials","text":"warning: Draft & Work in Progress\nThis documentation is a draft and work in progress. It will be extended and improved in the future.\n\nThe selected material specifies, which peridynamic formulation is employed in calculations.","category":"section"},{"location":"dev_materials/#Implemented-material-models","page":"Materials","title":"Implemented material models","text":"BBMaterial: Bond-based peridynamics.\nDHBBMaterial: Dual-horizon bond-based peridynamics.\nOSBMaterial: Ordinary state-based peridynamics, also called linear peridynamic solid (LPS).\nCMaterial: Correspondence formulation.\nCRMaterial: Correspondence formulation with stress rotation for objectivity enforcement.\nRKCMaterial: Reproducing kernel peridynamics with bond-associated higher-order integration.\nRKCRMaterial: Reproducing kernel peridynamics with bond-associated higher-order integration with stress rotation for objectivity enforcement.\nBACMaterial: Bond-associated correspondence formulation of Chen and Spencer.\nCKIMaterial: Continuum-kinematics-inspired peridynamics.","category":"section"},{"location":"dev_materials/#Custom-materials","page":"Materials","title":"Custom materials","text":"Custom materials can be defined for existing systems. Therefore the <XYZ>Material type has to be a subtype of an Abstract<SystemName>Material, which automatically sets methods for this type. Further it is necessary to: \n\nlink a point parameter type with @params.\nlink and create a storage with @storage.\ndefine the force_density_point! function.","category":"section"},{"location":"expl_nosbased/#expl_nosb","page":"Non-ordinary state-based peridynamics","title":"Non-ordinary state-based peridynamics","text":"Non-ordinary state-based formulations have been developed to extend state-based peridynamics. Hereafter, the correspondence formulation of non-ordinary state based peridynamics is considered, which uses an elastic model from the classical theory. [SEW+07]\n\nFirst, the symmetric shape tensor is calculated:\n\nboldsymbolK^i = boldsymbolK(boldsymbolX^i) = int_mathcalH_i omega  boldsymbolDelta X^ij otimes boldsymbolDelta X^ij  mathrmdV^j  \n\nHere, omega is an influence function to weigh points differently. The deformation gradient is thus approximated as [SEW+07]\n\nboldsymbolF^i = boldsymbolF(boldsymbolX^it) = left(int_mathcalH_i omega  boldsymbolDelta x^ij otimes boldsymbolDelta X^ij  mathrmdV^jright) left(boldsymbolK^iright)^-1  \n\nUsing the deformation gradient, now the first Piola-Kirchhoff stress tensor can be determined with the Helmholtz energy density Psi:\n\nboldsymbolP^i = boldsymbolP(boldsymbolX^it) = fracpartial Psipartial boldsymbolF^i  = boldsymbolF boldsymbolS  \n\nUsing the calculated variables, the force vector state can now be determined by [SEW+07]\n\nboldsymbolt^i = omega boldsymbolP^i  left(boldsymbolK^iright)^-1 boldsymbolDelta X^ij  \n\nSize Symbol Unit\nBond in mathcalB_0 boldsymbolDelta X^ij mathrmm\nBond in mathcalB_t boldsymbolDelta x^ij mathrmm\nInfluence function omega -\nVolume of point j V^j leftmathrmm^3right\nSymmetric shape tensor boldsymbolK^i leftmathrmm^5right\nDeformation gradient boldsymbolF^i -\nHelmholtz energy density Psi leftfracmathrmkgmathrmmmathrms^2right\nPiola-Kirchhoff stress tensor boldsymbolP^i leftfracmathrmkgmathrmmmathrms^2right\nForce vector state boldsymbolt^i leftfracmathrmkgmathrmm^5mathrms^2right","category":"section"},{"location":"public_api_reference/#Public-API","page":"Public API","title":"Public API","text":"Pages = [\"public_api_reference.md\"]","category":"section"},{"location":"public_api_reference/#Material-models","page":"Public API","title":"Material models","text":"","category":"section"},{"location":"public_api_reference/#System-or-material-related-types","page":"Public API","title":"System or material related types","text":"","category":"section"},{"location":"public_api_reference/#Discretization","page":"Public API","title":"Discretization","text":"","category":"section"},{"location":"public_api_reference/#Preprocessing-and-simulation-setup","page":"Public API","title":"Preprocessing & simulation setup","text":"","category":"section"},{"location":"public_api_reference/#Solving","page":"Public API","title":"Solving","text":"","category":"section"},{"location":"public_api_reference/#Postprocessing","page":"Public API","title":"Postprocessing","text":"","category":"section"},{"location":"public_api_reference/#Peridynamics.BBMaterial","page":"Public API","title":"Peridynamics.BBMaterial","text":"BBMaterial()\nBBMaterial{Correction}()\n\nA material type used to assign the material of a Body with the standard bond-based formulation of peridynamics.\n\nKeywords\n\ndmgmodel::AbstractDamageModel: Damage model defining the fracture behavior.   (default: CriticalStretch())\n\nPossible correction methods are:\n\nNoCorrection: No correction is applied. (default)\nEnergySurfaceCorrection: The energy based surface correction method of   Le and Bobaru (2018) is applied.\n\nExamples\n\njulia> mat = BBMaterial()\nBBMaterial{NoCorrection}()\n\njulia> mat = BBMaterial{EnergySurfaceCorrection}()\nBBMaterial{EnergySurfaceCorrection}()\n\n\n\nBBMaterial{Correction}\n\nMaterial type for the bond-based peridynamics formulation.\n\nType Parameters\n\nCorrection: A correction algorithm type. See the constructor docs for more informations.\nDM: A damage model type.\n\nAllowed material parameters\n\nWhen using material! on a Body with BBMaterial, then the following parameters are allowed: Material parameters:\n\nhorizon::Float64: Radius of point interactions.\nrho::Float64: Density.\n\nElastic parameters\n\nE::Float64: Young's modulus.\nG::Float64: Shear modulus.\nK::Float64: Bulk modulus.\nlambda::Float64: 1st Lamé parameter.\nmu::Float64: 2nd Lamé parameter.\n\nFracture parameters:\n\nGc::Float64: Critical energy release rate.\nepsilon_c::Float64: Critical strain.\n\nnote: Poisson's ratio and bond-based peridynamics\nIn bond-based peridynamics, the Poisson's ratio is limited to 1/4 for 3D simulations. Therefore, only one additional elastic parameter is required. Optionally, the specification of a second keyword is allowed, if the parameter combination results in nu = 1/4.\n\nAllowed export fields\n\nWhen specifying the fields keyword of Job for a Body with BBMaterial, the following fields are allowed:\n\nposition::Matrix{Float64}: Position of each point.\ndisplacement::Matrix{Float64}: Displacement of each point.\nvelocity::Matrix{Float64}: Velocity of each point.\nvelocity_half::Matrix{Float64}: Velocity parameter for Verlet time solver.\nacceleration::Matrix{Float64}: Acceleration of each point.\nb_int::Matrix{Float64}: Internal force density of each point.\nb_ext::Matrix{Float64}: External force density of each point.\ndamage::Vector{Float64}: Damage of each point.\nn_active_bonds::Vector{Int}: Number of intact bonds of each point.\nstrain_energy_density::Vector{Float64}: Strain energy density of each point.\n\n\n\n\n\n","category":"type"},{"location":"public_api_reference/#Peridynamics.DHBBMaterial","page":"Public API","title":"Peridynamics.DHBBMaterial","text":"DHBBMaterial()\nDHBBMaterial{Correction}()\n\nA material type used to assign the material of a Body with the dual-horizon bond-based formulation of peridynamics.\n\nKeywords\n\ndmgmodel::AbstractDamageModel: Damage model defining the fracture behavior.   (default: CriticalStretch())\n\nPossible correction methods are:\n\nNoCorrection: No correction is applied. (default)\nEnergySurfaceCorrection: The energy based surface correction method of   Le and Bobaru (2018) is applied.\n\nExamples\n\njulia> mat = DHBBMaterial()\nDHBBMaterial{NoCorrection}()\n\njulia> mat = DHBBMaterial{EnergySurfaceCorrection}()\nDHBBMaterial{EnergySurfaceCorrection}()\n\n\n\nDHBBMaterial{Correction}\n\nMaterial type for the dual-horizon bond-based peridynamics formulation.\n\nType Parameters\n\nCorrection: A correction algorithm type. See the constructor docs for more informations.\nDM: A damage model type.\n\nAllowed material parameters\n\nWhen using material! on a Body with DHBBMaterial, then the following parameters are allowed: Material parameters:\n\nhorizon::Float64: Radius of point interactions.\nrho::Float64: Density.\n\nElastic parameters:\n\nE::Float64: Young's modulus.\nG::Float64: Shear modulus.\nK::Float64: Bulk modulus.\nlambda::Float64: 1st Lamé parameter.\nmu::Float64: 2nd Lamé parameter.\n\nFracture parameters:\n\nGc::Float64: Critical energy release rate.\nepsilon_c::Float64: Critical strain.\n\nnote: Poisson's ratio and bond-based peridynamics\nIn bond-based peridynamics, the Poisson's ratio is limited to 1/4 for 3D simulations. Therefore, only one additional elastic parameter is required. Optionally, the specification of a second keyword is allowed, if the parameter combination results in nu = 1/4.\n\nAllowed export fields\n\nWhen specifying the fields keyword of Job for a Body with DHBBMaterial, the following fields are allowed:\n\nposition::Matrix{Float64}: Position of each point.\ndisplacement::Matrix{Float64}: Displacement of each point.\nvelocity::Matrix{Float64}: Velocity of each point.\nvelocity_half::Matrix{Float64}: Velocity parameter for Verlet time solver.\nacceleration::Matrix{Float64}: Acceleration of each point.\nb_int::Matrix{Float64}: Internal force density of each point.\nb_ext::Matrix{Float64}: External force density of each point.\ndamage::Vector{Float64}: Damage of each point.\nn_active_bonds::Vector{Int}: Number of intact bonds of each point.\nstrain_energy_density::Vector{Float64}: Strain energy density of each point.\n\n\n\n\n\n","category":"type"},{"location":"public_api_reference/#Peridynamics.GBBMaterial","page":"Public API","title":"Peridynamics.GBBMaterial","text":"GBBMaterial()\nGBBMaterial{Correction}()\n\nA material type used to assign the material of a Body with the generalized bond-based formulation of peridynamics.\n\nKeywords\n\ndmgmodel::AbstractDamageModel: Damage model defining the fracture behavior.   (default: CriticalStretch())\n\nPossible correction methods are:\n\nNoCorrection: No correction is applied. (default)\nEnergySurfaceCorrection: The energy based surface correction method of   Le and Bobaru (2018) is applied.\n\nExamples\n\njulia> mat = GBBMaterial()\nGBBMaterial{NoCorrection}()\n\njulia> mat = GBBMaterial{EnergySurfaceCorrection}()\nGBBMaterial{EnergySurfaceCorrection}()\n\n\n\nGBBMaterial{Correction}\n\nMaterial type for the dual-horizon bond-based peridynamics formulation.\n\nType Parameters\n\nCorrection: A correction algorithm type. See the constructor docs for more informations.\nDM: A damage model type.\n\nAllowed material parameters\n\nWhen using material! on a Body with GBBMaterial, then the following parameters are allowed: Material parameters:\n\nhorizon::Float64: Radius of point interactions.\nrho::Float64: Density.\n\nElastic parameters:\n\nE::Float64: Young's modulus.\nG::Float64: Shear modulus.\nK::Float64: Bulk modulus.\nlambda::Float64: 1st Lamé parameter.\nmu::Float64: 2nd Lamé parameter.\n\nFracture parameters:\n\nGc::Float64: Critical energy release rate.\nepsilon_c::Float64: Critical strain.\n\nnote: Poisson's ratio and bond-based peridynamics\nIn bond-based peridynamics, the Poisson's ratio is limited to 1/4 for 3D simulations. Therefore, only one additional elastic parameter is required. Optionally, the specification of a second keyword is allowed, if the parameter combination results in nu = 1/4.\n\nAllowed export fields\n\nWhen specifying the fields keyword of Job for a Body with GBBMaterial, the following fields are allowed:\n\nposition::Matrix{Float64}: Position of each point.\ndisplacement::Matrix{Float64}: Displacement of each point.\nvelocity::Matrix{Float64}: Velocity of each point.\nvelocity_half::Matrix{Float64}: Velocity parameter for Verlet time solver.\nacceleration::Matrix{Float64}: Acceleration of each point.\nb_int::Matrix{Float64}: Internal force density of each point.\nb_ext::Matrix{Float64}: External force density of each point.\ndamage::Vector{Float64}: Damage of each point.\nn_active_bonds::Vector{Int}: Number of intact bonds of each point.\nstrain_energy_density::Vector{Float64}: Strain energy density of each point.\n\n\n\n\n\n","category":"type"},{"location":"public_api_reference/#Peridynamics.OSBMaterial","page":"Public API","title":"Peridynamics.OSBMaterial","text":"OSBMaterial(; kernel, dmgmodel)\nOSBMaterial{Correction}(; kernel, dmgmodel)\n\nA material type used to assign the material of a Body with the ordinary state-based formulation of peridynamics.\n\nPossible correction methods are:\n\nNoCorrection: No correction is applied. (default)\nEnergySurfaceCorrection: The energy based surface correction method of   Le and Bobaru (2018) is applied.\n\nKeywords\n\nkernel::Function: Kernel function used for weighting the interactions between points. \n  (default: linear_kernel)\ndmgmodel::AbstractDamageModel: Damage model defining the damage behavior. \n  (default: CriticalStretch())\n\nExamples\n\njulia> mat = OSBMaterial()\nOSBMaterial{NoCorrection}(dmgmodel=CriticalStretch())\n\njulia> mat = OSBMaterial{EnergySurfaceCorrection}()\nOSBMaterial{EnergySurfaceCorrection}(dmgmodel=CriticalStretch())\n\n\n\nOSBMaterial{Correction,K,DM}\n\nMaterial type for the ordinary state-based peridynamics formulation.\n\nType Parameters\n\nCorrection: A correction algorithm type. See the constructor docs for more informations.\nK: A kernel function type. See the constructor docs for more informations.\nDM: A damage model type. See the constructor docs for more informations.\n\nFields\n\nkernel::Function: Kernel function used for weighting the interactions between points.\ndmgmodel::AbstractDamageModel: Damage model defining the damage behavior. See the   constructor docs for more informations.\n\nAllowed material parameters\n\nWhen using material! on a Body with OSBMaterial, then the following parameters are allowed: Material parameters:\n\nhorizon::Float64: Radius of point interactions.\nrho::Float64: Density.\n\nElastic parameters:\n\nE::Float64: Young's modulus.\nnu::Float64: Poisson's ratio.\nG::Float64: Shear modulus.\nK::Float64: Bulk modulus.\nlambda::Float64: 1st Lamé parameter.\nmu::Float64: 2nd Lamé parameter.\n\nFracture parameters:\n\nGc::Float64: Critical energy release rate.\nepsilon_c::Float64: Critical strain.\n\nnote: Elastic parameters\nNote that exactly two elastic parameters are required to specify a material. Please choose two out of the six allowed elastic parameters.\n\nAllowed export fields\n\nWhen specifying the fields keyword of Job for a Body with OSBMaterial, the following fields are allowed:\n\nposition::Matrix{Float64}: Position of each point.\ndisplacement::Matrix{Float64}: Displacement of each point.\nvelocity::Matrix{Float64}: Velocity of each point.\nvelocity_half::Matrix{Float64}: Velocity parameter for Verlet time solver.\nacceleration::Matrix{Float64}: Acceleration of each point.\nb_int::Matrix{Float64}: Internal force density of each point.\nb_ext::Matrix{Float64}: External force density of each point.\ndamage::Vector{Float64}: Damage of each point.\nn_active_bonds::Vector{Int}: Number of intact bonds of each point.\nstrain_energy_density::Vector{Float64}: Strain energy density of each point.\n\n\n\n\n\n","category":"type"},{"location":"public_api_reference/#Peridynamics.CMaterial","page":"Public API","title":"Peridynamics.CMaterial","text":"CMaterial(; kernel, model, zem, dmgmodel, maxdmg)\n\nA material type used to assign the material of a Body with the local continuum consistent (correspondence) formulation of non-ordinary state-based peridynamics.\n\nKeywords\n\nkernel::Function: Kernel function used for weighting the interactions between points. \n  (default: linear_kernel) \n  The following kernels can be used:\nconst_one_kernel\nlinear_kernel\ncubic_b_spline_kernel\nmodel::AbstractConstitutiveModel: Constitutive model defining the material behavior. \n  (default: SaintVenantKirchhoff()) \n  The following models can be used:\nSaintVenantKirchhoff\nLinearElastic\nNeoHooke\nNeoHookePenalty\nzem::AbstractZEMStabilization: Algorithm of zero-energy mode stabilization. \n  (default: ZEMSilling) \n  The following algorithms can be used:\nZEMSilling\nZEMWan\ndmgmodel::AbstractDamageModel: Damage model defining the damage behavior. \n  (default: CriticalStretch)\nmaxdmg::Float64: Maximum value of damage a point is allowed to obtain. If this value is   exceeded, all bonds of that point are broken because the deformation gradient would then   possibly contain NaN values. \n  (default: 0.85)\n\nnote: Stability of fracture simulations\nThis formulation is known to be not suitable for fracture simulations without stabilization of the zero-energy modes. Therefore be careful when doing fracture simulations and try out different parameters for maxdmg and zem.\n\nExamples\n\njulia> mat = CMaterial()\nCMaterial{SaintVenantKirchhoff, ZEMSilling, typeof(linear_kernel), CriticalStretch}(maxdmg=0.85)\n\n\n\nCMaterial{CM,ZEM,K,DM}\n\nMaterial type for the local continuum consistent (correspondence) formulation of non-ordinary state-based peridynamics.\n\nType Parameters\n\nCM: A constitutive model type. See the constructor docs for more informations.\nZEM: A zero-energy mode stabilization type. See the constructor docs for more        informations.\nK: A kernel function type. See the constructor docs for more informations.\nDM: A damage model type. See the constructor docs for more informations.\n\nFields\n\nkernel::Function: Kernel function used for weighting the interactions between points.   See the constructor docs for more informations.\nmodel::AbstractConstitutiveModel: Constitutive model defining the material behavior. See   the constructor docs for more informations.\nzem::AbstractZEMStabilization: Zero-energy mode stabilization. See the constructor docs   for more informations.\ndmgmodel::AbstractDamageModel: Damage model defining the damage behavior. See the   constructor docs for more informations.\nmaxdmg::Float64: Maximum value of damage a point is allowed to obtain. See the   constructor docs for more informations.\n\nAllowed material parameters\n\nWhen using material! on a Body with CMaterial, then the following parameters are allowed: Material parameters:\n\nhorizon::Float64: Radius of point interactions.\nrho::Float64: Density.\n\nElastic parameters:\n\nE::Float64: Young's modulus.\nnu::Float64: Poisson's ratio.\nG::Float64: Shear modulus.\nK::Float64: Bulk modulus.\nlambda::Float64: 1st Lamé parameter.\nmu::Float64: 2nd Lamé parameter.\n\nFracture parameters:\n\nGc::Float64: Critical energy release rate.\nepsilon_c::Float64: Critical strain.\n\nnote: Elastic parameters\nNote that exactly two elastic parameters are required to specify a material. Please choose two out of the six allowed elastic parameters.\n\nAllowed export fields\n\nWhen specifying the fields keyword of Job for a Body with CMaterial, the following fields are allowed:\n\nposition::Matrix{Float64}: Position of each point.\ndisplacement::Matrix{Float64}: Displacement of each point.\nvelocity::Matrix{Float64}: Velocity of each point.\nvelocity_half::Matrix{Float64}: Velocity parameter for Verlet time solver.\nacceleration::Matrix{Float64}: Acceleration of each point.\nb_int::Matrix{Float64}: Internal force density of each point.\nb_ext::Matrix{Float64}: External force density of each point.\ndamage::Vector{Float64}: Damage of each point.\nn_active_bonds::Vector{Int}: Number of intact bonds of each point.\ncauchy_stress::Matrix{Float64}: Cauchy stress tensor of each point.\nvon_mises_stress::Vector{Float64}: Von Mises stress of each point.\nhydrostatic_stress::Vector{Float64}: Hydrostatic stress of each point.\nstrain_energy_density::Vector{Float64}: Strain energy density of each point.\n\n\n\n\n\n","category":"type"},{"location":"public_api_reference/#Peridynamics.CRMaterial","page":"Public API","title":"Peridynamics.CRMaterial","text":"CRMaterial(; kernel, model, zem, dmgmodel, maxdmg)\n\nThe same as the CMaterial but with rotation of the stress tensor for large deformation simulations, therefore not all models are supported.\n\nSupported models:\n\nSaintVenantKirchhoff\nLinearElastic\n\nPlease take a look at the CMaterial docs for more information about the material!\n\n\n\n\n\n","category":"type"},{"location":"public_api_reference/#Peridynamics.BACMaterial","page":"Public API","title":"Peridynamics.BACMaterial","text":"BACMaterial(; kernel, model, dmgmodel, maxdmg)\n\nA material type used to assign the material of a Body with the bond-associated correspondence formulation of Chen and Spencer (2019).\n\nKeywords\n\nkernel::Function: Kernel function used for weighting the interactions between points.   (default: linear_kernel)\nmodel::AbstractConstitutiveModel: Constitutive model defining the material behavior.   (default: SaintVenantKirchhoff())\ndmgmodel::AbstractDamageModel: Damage model defining the fracture behavior.   (default: CriticalStretch())\nmaxdmg::Float64: Maximum value of damage a point is allowed to obtain. If this value is   exceeded, all bonds of that point are broken because the deformation gradient would then   possibly contain NaN values.   (default: 0.85)\n\nExamples\n\njulia> mat = BACMaterial()\nBACMaterial{SaintVenantKirchhoff, typeof(linear_kernel), CriticalStretch}()\n\n\n\nBACMaterial{CM,K,DM}\n\nMaterial type for the bond-associated correspondence formulation of Chen and Spencer (2019).\n\nType Parameters\n\nCM: A constitutive model type. See the constructor docs for more informations.\nK: A kernel function type. See the constructor docs for more informations.\nDM: A damage model type.\n\nFields\n\nkernel::Function: Kernel function used for weighting the interactions between points.\nmodel::AbstractConstitutiveModel: Constitutive model defining the material behavior.\ndmgmodel::AbstractDamageModel: Damage model defining the fracture behavior.\nmaxdmg::Float64: Maximum value of damage a point is allowed to obtain. See the   constructor docs for more informations.\n\nAllowed material parameters\n\nWhen using material! on a Body with BACMaterial, then the following parameters are allowed:\n\nhorizon::Float64: Radius of point interactions.\nrho::Float64: Density.\nE::Float64: Young's modulus.\nnu::Float64: Poisson's ratio.\nGc::Float64: Critical energy release rate.\nepsilon_c::Float64: Critical strain.\n\nAllowed export fields\n\nWhen specifying the fields keyword of Job for a Body with BACMaterial, the following fields are allowed:\n\nposition::Matrix{Float64}: Position of each point.\ndisplacement::Matrix{Float64}: Displacement of each point.\nvelocity::Matrix{Float64}: Velocity of each point.\nvelocity_half::Matrix{Float64}: Velocity parameter for Verlet time solver.\nacceleration::Matrix{Float64}: Acceleration of each point.\nb_int::Matrix{Float64}: Internal force density of each point.\nb_ext::Matrix{Float64}: External force density of each point.\ndamage::Vector{Float64}: Damage of each point.\nn_active_bonds::Vector{Int}: Number of intact bonds of each point.\n\n\n\n\n\n","category":"type"},{"location":"public_api_reference/#Peridynamics.CKIMaterial","page":"Public API","title":"Peridynamics.CKIMaterial","text":"CKIMaterial(; dmgmodel)\n\nA material type used to assign the material of a Body with the continuum-kinematics-inspired peridynamics formulation.\n\nKeywords\n\ndmgmodel::AbstractDamageModel: Damage model defining the damage behavior. \n  (default: CriticalStretch())\n\nExamples\n\njulia> mat = CKIMaterial()\nCKIMaterial(dmgmodel=CriticalStretch())\n\n\n\nCKIMaterial{DM}\n\nMaterial type for the continuum-kinematics-inspired peridynamics framework.\n\nType Parameters\n\nDM: A damage model type. See the constructor docs for more informations.\n\nFields\n\ndmgmodel::AbstractDamageModel: Damage model defining the damage behavior. See the   constructor docs for more informations.\n\nAllowed material parameters\n\nWhen using material! on a Body with CKIMaterial, then the following parameters are allowed: Material parameters:\n\nhorizon::Float64: Radius of point interactions.\nrho::Float64: Density.\n\nElastic parameters:\n\nE::Float64: Young's modulus.\nnu::Float64: Poisson's ratio.\nG::Float64: Shear modulus.\nK::Float64: Bulk modulus.\nlambda::Float64: 1st Lamé parameter.\nmu::Float64: 2nd Lamé parameter.\n\nFracture parameters:\n\nGc::Float64: Critical energy release rate.\nepsilon_c::Float64: Critical strain.\n\nInteraction parameters:\n\nC1::Float64: One-neighbor interaction parameter. (default: 0.0)\nC2::Float64: Two-neighbor interaction parameter. (default: 0.0)\nC3::Float64: Two-neighbor interaction parameter. (default: 0.0)\n\nwarning: Specification of interaction parameters\nIf any of the interaction parameters is used with material!, the Young's modulus and Poisson's ratio are ignored and only the specified interaction parameters will influence the force density calculated from that interaction.If no interaction parameter is specified, then the Young's modulus and Poisson's ratio are used to calculate these parameters accordingly to Ekiz, Steinmann, and Javili (2022).\n\nnote: Elastic parameters\nNote that exactly two elastic parameters are required to specify a material. Please choose two out of the six allowed elastic parameters.\n\nAllowed export fields\n\nWhen specifying the fields keyword of Job for a Body with CKIMaterial, the following fields are allowed:\n\nposition::Matrix{Float64}: Position of each point.\ndisplacement::Matrix{Float64}: Displacement of each point.\nvelocity::Matrix{Float64}: Velocity of each point.\nvelocity_half::Matrix{Float64}: Velocity parameter for Verlet time solver.\nacceleration::Matrix{Float64}: Acceleration of each point.\nb_int::Matrix{Float64}: Internal force density of each point.\nb_ext::Matrix{Float64}: External force density of each point.\ndamage::Vector{Float64}: Damage of each point.\nn_active_one_nis::Vector{Int}: Number of intact one-neighbor interactions of each point.\nstrain_energy_density::Vector{Float64}: Strain energy density of each point.\n\n\n\n\n\n","category":"type"},{"location":"public_api_reference/#Peridynamics.RKCMaterial","page":"Public API","title":"Peridynamics.RKCMaterial","text":"RKCMaterial(; kernel, model, dmgmodel, monomial, lambda, beta)\n\nA material type used to assign the material of a Body with a reproducing kernel peridynamics (correspondence) formulation with bond-associated quadrature integration at the center of the bonds.\n\nKeywords\n\nkernel::Function: Kernel function used for weighting the interactions between points. \n  (default: const_one_kernel) \n  The following kernels can be used:\nconst_one_kernel\nlinear_kernel\ncubic_b_spline_kernel_norm\ncubic_b_spline_kernel\nmodel::AbstractConstitutiveModel: Constitutive model defining the material behavior. \n  (default: SaintVenantKirchhoff()) \n  The following models can be used:\nSaintVenantKirchhoff\nLinearElastic\nNeoHooke\nNeoHookePenalty\ndmgmodel::AbstractDamageModel: Damage model defining the damage behavior. \n  (default: CriticalStretch)\nmonomial::Symbol: The monomial vector used for the reproducing kernel approximation   of the moment matrix. This kernel is used to calculate the moment matrix and the   gradient weights, which are used to approximate the deformation gradient. \n  (default: :C1) \n  The following kernels can be used:\n:C1: Linear monomial basis vector [x, y, z] with first-order accuracy, equivalent to   the standard correspondence formulation. This is the default kernel.\n:RK1: First-order monomial basis vector [1, x, y, z] with constant term   for enhanced stability in uniform deformation fields.\n:RK2: Second-order monomial basis vector [1, x, y, z, x², y², z²] with   diagonal quadratic terms for improved accuracy in curved deformation fields.\n:PD2: Second-order monomial basis vector [x, y, z, x², xy, xz, y², yz, z²] with   full quadratic terms but without constant term.\nlambda::Real: Relative Tikhonov regularization parameter (dimensionless, non-negative).   Internally scaled by the largest singular value of the moment matrix during inversion   with invreg. For well-conditioned problems, the default value of 0 (no   Tikhonov regularization) is recommended. See invreg for details.\n  (default: 0)\nbeta::Real: Relative SVD truncation parameter (dimensionless, non-negative). Internally   scaled by the largest singular value of the moment matrix during inversion with   invreg. Primary regularization mechanism for singular moment matrices. See   invreg for parameter selection guidelines.\n  (default: sqrt(eps()))\n\nExamples\n\njulia> mat = RKCMaterial()\nRKCMaterial{SaintVenantKirchhoff, typeof(linear_kernel), CriticalStretch}()\n\n\n\nRKCMaterial{CM,K,DM}\n\nMaterial type for a reproducing kernel peridynamics (correspondence) formulation with bond-associated quadrature integration at the center of the bonds.\n\nType Parameters\n\nCM: A constitutive model type. See the constructor docs for more informations.\nK: A kernel function type. See the constructor docs for more informations.\nDM: A damage model type. See the constructor docs for more informations.\n\nFields\n\nkernel::Function: Kernel function used for weighting the interactions between points.   See the constructor docs for more informations.\nmodel::AbstractConstitutiveModel: Constitutive model defining the material behavior. See   the constructor docs for more informations.\ndmgmodel::AbstractDamageModel: Damage model defining the damage behavior. See the   constructor docs for more informations.\nmonomial::Symbol: The monomial vector used for the reproducing kernel approximation. See   the constructor docs for more informations.\nlambda::Float64: Tikhonov regularization parameter. See the constructor docs for more   informations.\nbeta::Float64: SVD truncation parameter. See the constructor docs for more   informations.\n\nAllowed material parameters\n\nWhen using material! on a Body with RKCMaterial, then the following parameters are allowed: Material parameters:\n\nhorizon::Float64: Radius of point interactions\nrho::Float64: Density\n\nElastic parameters:\n\nE::Float64: Young's modulus\nnu::Float64: Poisson's ratio\nG::Float64: Shear modulus\nK::Float64: Bulk modulus\nlambda::Float64: 1st Lamé parameter\nmu::Float64: 2nd Lamé parameter\n\nFracture parameters:\n\nGc::Float64: Critical energy release rate\nepsilon_c::Float64: Critical strain\n\nnote: Elastic parameters\nNote that exactly two elastic parameters are required to specify a material. Please choose two out of the six allowed elastic parameters.\n\nAllowed export fields\n\nWhen specifying the fields keyword of Job for a Body with RKCMaterial, the following fields are allowed:\n\nposition::Matrix{Float64}: Position of each point\ndisplacement::Matrix{Float64}: Displacement of each point\nvelocity::Matrix{Float64}: Velocity of each point\nvelocity_half::Matrix{Float64}: Velocity parameter for Verlet time solver\nacceleration::Matrix{Float64}: Acceleration of each point\nb_int::Matrix{Float64}: Internal force density of each point\nb_ext::Matrix{Float64}: External force density of each point\ndamage::Vector{Float64}: Damage of each point\nn_active_bonds::Vector{Int}: Number of intact bonds of each point\ncauchy_stress::Matrix{Float64}: Cauchy stress tensor of each point\nvon_mises_stress::Vector{Float64}: Von Mises stress of each point\nhydrostatic_stress::Vector{Float64}: Hydrostatic stress of each point.\nstrain_energy_density::Vector{Float64}: Strain energy density of each point.\n\n\n\n\n\n","category":"type"},{"location":"public_api_reference/#Peridynamics.RKCRMaterial","page":"Public API","title":"Peridynamics.RKCRMaterial","text":"RKCRMaterial(; kernel, model, dmgmodel, monomial, lambda, beta)\n\nThe same as the RKCMaterial but with rotation of the stress tensor for large deformation simulations, therefore not all models are supported.\n\nSupported models:\n\nSaintVenantKirchhoff\nLinearElastic\n\nPlease take a look at the RKCMaterial docs for more information about the material, including details about the monomial, lambda, and beta parameters!\n\n\n\n\n\n","category":"type"},{"location":"public_api_reference/#Peridynamics.CriticalStretch","page":"Public API","title":"Peridynamics.CriticalStretch","text":"CriticalStretch\n\nA damage model based on the stretch of the bond. The bond is considered to be broken if the stretch exceeds a critical value. The critical value can be defined via the fracture energy Gc or the critical stretch εc using the material! function. The damage model is defined globally for the whole body as part of the material.\n\n\n\n\n\n","category":"type"},{"location":"public_api_reference/#Peridynamics.NoCorrection","page":"Public API","title":"Peridynamics.NoCorrection","text":"NoCorrection\n\nA correction handler for materials that use the bond system. If NoCorrection is used, then no correction will be applied.\n\nSee also BBMaterial, OSBMaterial for further information on how to use the correction type.\n\n\n\n\n\n","category":"type"},{"location":"public_api_reference/#Peridynamics.EnergySurfaceCorrection","page":"Public API","title":"Peridynamics.EnergySurfaceCorrection","text":"EnergySurfaceCorrection\n\nA correction handler for materials that use the bond system. If EnergySurfaceCorrection is used, then the energy based surface correction method of Le and Bobaru (2018) is used.\n\nSee also BBMaterial, OSBMaterial for further information on how to use the correction type.\n\n\n\n\n\n","category":"type"},{"location":"public_api_reference/#Peridynamics.ZEMSilling","page":"Public API","title":"Peridynamics.ZEMSilling","text":"ZEMSilling(; Cs)\n\nZero-energy mode stabilization algorithm of Silling (2017). This is necessary for the correspondence formulation to stabilize the zero-energy modes. See also CMaterial on how to use this stabilization algorithm.\n\nKeywords\n\nCs::Real: Stabilization factor. (default: 0.5)\n\n\n\n\n\n","category":"type"},{"location":"public_api_reference/#Peridynamics.ZEMWan","page":"Public API","title":"Peridynamics.ZEMWan","text":"ZEMWan()\n\nZero-energy mode stabilization algorithm of Wan et al. (2019), which is an improvement to Silling's algorithm that does not require a stabilization parameter. See also CMaterial on how to use this stabilization algorithm.\n\n\n\n\n\n","category":"type"},{"location":"public_api_reference/#Peridynamics.LinearElastic","page":"Public API","title":"Peridynamics.LinearElastic","text":"LinearElastic\n\nLinear elastic constitutive model that can be specified when using a CMaterial and BACMaterial.\n\nThe strain energy density Psi is given by\n\nPsi = frac12 lambda  mathrmtr(boldsymbolE)^2 + mu  mathrmtr(boldsymbolE cdot boldsymbolE)  \n\nwith the first and second Lamé parameters lambda and mu, and the Green-Lagrange strain tensor boldsymbolE\n\nboldsymbolE = frac12 left( boldsymbolF^top boldsymbolF - boldsymbolI\n                             right)  \n\nThe first Piola-Kirchhoff stress boldsymbolP is given by\n\nbeginaligned\nboldsymbolS = mathbbC  boldsymbolE   \nboldsymbolP = boldsymbolF  boldsymbolS  \nendaligned\n\nwith the deformation gradient boldsymbolF, the elastic stiffness tensor mathbbC, and the second Piola-Kirchhoff stress boldsymbolS.\n\nnote: Note\nThis model is equivalent to the Saint-Venant-Kirchhoff model, but uses a different implementation based on the elastic stiffness tensor.\n\n\n\n\n\n","category":"type"},{"location":"public_api_reference/#Peridynamics.NeoHooke","page":"Public API","title":"Peridynamics.NeoHooke","text":"NeoHooke\n\nCompressible Neo-Hookean hyperelastic constitutive model that can be specified when using a CMaterial and BACMaterial.\n\nThe strain energy density Psi is given by\n\nPsi = frac12 mu left( I_1 - 3 right) - mu log(J) + frac12 lambda log(J)^2  \n\nwith the first invariant I_1 = mathrmtr(boldsymbolC) of the right Cauchy-Green deformation tensor boldsymbolC = boldsymbolF^top boldsymbolF, the Jacobian J = mathrmdet(boldsymbolF), and the first and second Lamé parameters lambda and mu.\n\nThe first Piola-Kirchhoff stress boldsymbolP is given by\n\nbeginaligned\nboldsymbolC = boldsymbolF^top boldsymbolF   \nboldsymbolS = mu left( boldsymbolI - boldsymbolC^-1 right)\n    + lambda log(J) boldsymbolC^-1   \nboldsymbolP = boldsymbolF  boldsymbolS  \nendaligned\n\nwith the deformation gradient boldsymbolF and the second Piola-Kirchhoff stress boldsymbolS.\n\nReference\n\nTreloar, L. R. G. (1943). \"The elasticity of a network of long-chain molecules—II.\" Transactions of the Faraday Society, 39, 241–246. DOI: 10.1039/TF9433900241\n\n\n\n\n\n","category":"type"},{"location":"public_api_reference/#Peridynamics.NeoHookePenalty","page":"Public API","title":"Peridynamics.NeoHookePenalty","text":"NeoHookePenalty\n\nCompressible Neo-Hookean hyperelastic model with a penalty-type volumetric formulation, suitable for modeling rubber-like and biological materials. Can be specified when using a CMaterial and BACMaterial.\n\nThe strain energy density Psi is given by\n\nPsi = frac12 G left( barI_1 - 3 right) + fracK8 left( J^2 + J^-2 - 2 right)  \n\nwith the modified first invariant barI_1 = I_1 J^-23 where I_1 = mathrmtr(boldsymbolC) is the first invariant of the right Cauchy-Green deformation tensor boldsymbolC = boldsymbolF^top boldsymbolF, the Jacobian J = mathrmdet(boldsymbolF), the shear modulus G, and the bulk modulus K.\n\nThe first Piola-Kirchhoff stress boldsymbolP is given by\n\nbeginaligned\nboldsymbolC = boldsymbolF^top boldsymbolF   \nboldsymbolS = G left( boldsymbolI - frac13 mathrmtr(boldsymbolC)\n                           boldsymbolC^-1 right) J^-frac23\n                + fracK4 left( J^2 - J^-2 right) boldsymbolC^-1   \nboldsymbolP = boldsymbolF  boldsymbolS  \nendaligned\n\nwith the deformation gradient boldsymbolF and the second Piola-Kirchhoff stress boldsymbolS.\n\nnote: Penalty-type volumetric formulation\nThis model uses a penalty-type volumetric term Psi_mathrmvol = fracK8(J^2 + J^-2 - 2), which is computationally efficient and widely used in commercial finite element codes for nearly-incompressible materials. The term penalizes volume changes from the reference configuration (J = 1).This differs from other volumetric formulations such as:Standard Neo-Hookean (logarithmic): Psi_mathrmvol = -mu ln J + fraclambda2ln^2 J\nSimo-Miehe (polyconvex): Psi_mathrmvol = fracK4(J^2 - 1 - 2ln J)\n\nError handling\n\nIf the Jacobian J is smaller than the machine precision eps() or a NaN, the strain energy density and first Piola-Kirchhoff stress tensor are defined as zero: Psi = 0 and boldsymbolP = boldsymbol0.\n\n\n\n\n\n","category":"type"},{"location":"public_api_reference/#Peridynamics.SaintVenantKirchhoff","page":"Public API","title":"Peridynamics.SaintVenantKirchhoff","text":"SaintVenantKirchhoff\n\nSaint-Venant-Kirchhoff constitutive model that can be specified when using a CMaterial and BACMaterial.\n\nThe strain energy density Psi is given by\n\nPsi = frac12 lambda  mathrmtr(boldsymbolE)^2 + mu  mathrmtr(boldsymbolE cdot boldsymbolE)  \n\nwith the first and second Lamé parameters lambda and mu, and the Green-Lagrange strain tensor\n\nboldsymbolE = frac12 left( boldsymbolF^top boldsymbolF - boldsymbolI\n                              right)  \n\nThe first Piola-Kirchhoff stress boldsymbolP is given by\n\nbeginaligned\nboldsymbolS = lambda  mathrmtr(boldsymbolE)  boldsymbolI\n                + 2 mu boldsymbolE   \nboldsymbolP = boldsymbolF  boldsymbolS  \nendaligned\n\nwith the deformation gradient boldsymbolF and the second Piola-Kirchhoff stress boldsymbolS.\n\nnote: Note\nThis model is equivalent to the LinearElastic model, both using the same strain energy density function.\n\n\n\n\n\n","category":"type"},{"location":"public_api_reference/#Peridynamics.const_one_kernel","page":"Public API","title":"Peridynamics.const_one_kernel","text":"const_one_kernel(δ, L)\n\nA kernel function omega (also called influence function) used for weighting the bonds in a family. The kernel function is simply defined as a constant value 1:\n\nomega = 1\n\n\n\n\n\n","category":"function"},{"location":"public_api_reference/#Peridynamics.linear_kernel","page":"Public API","title":"Peridynamics.linear_kernel","text":"linear_kernel(δ, L)\n\nA linear kernel function omega (also called influence function) used for weighting the bonds in a family. The kernel function is defined as\n\nomega = fracdeltaL  \n\nwith the horizon delta and the initial bond length L.\n\n\n\n\n\n","category":"function"},{"location":"public_api_reference/#Peridynamics.cubic_b_spline_kernel","page":"Public API","title":"Peridynamics.cubic_b_spline_kernel","text":"cubic_b_spline_kernel(δ, L)\n\nA cubic B-spline kernel function omega used for weighting the bonds in a family. The kernel function is defined as\n\nbeginaligned\nxi = fracLdelta   \nomega = left\n    beginarrayll\n        frac23 - 4 xi^2 + 4 xi^3  quad textif  0  xi leq 05   3pt\n        frac43 - 4 xi + 4 xi^2 - frac43 xi^3  quad textif  05  xi leq 1   3pt\n        0  quad textelse  \n    endarray\n    right\nendaligned\n\nwith the horizon delta and the initial bond length L.\n\n\n\n\n\n","category":"function"},{"location":"public_api_reference/#Peridynamics.cubic_b_spline_kernel_norm","page":"Public API","title":"Peridynamics.cubic_b_spline_kernel_norm","text":"cubic_b_spline_kernel_norm(δ, L)\n\nA cubic B-spline kernel function omega used for weighting the bonds in a family. The kernel function is defined as\n\nbeginaligned\nxi = fracLdelta   \nomega = frac8pi  delta^3 cdot left\n    beginarrayll\n        1 - 6 xi^2 + 6 xi^3  quad textif  0  xi leq 05   3pt\n        2 (1 - xi)^3  quad textif  05  xi leq 1   3pt\n        0  quad textelse  \n    endarray\n    right\nendaligned\n\nwith the horizon delta and the initial bond length L. This kernel is properly normalized to satisfy the condition int_mathcalH(X) omega(Delta X) dV = 1.\n\n\n\n\n\n","category":"function"},{"location":"public_api_reference/#Peridynamics.Body","page":"Public API","title":"Peridynamics.Body","text":"Body(material, position, volume)\nBody(material, inp_file)\n\nConstruct a Body for a peridynamics simulation.\n\nArguments\n\nmaterial::AbstractMaterial: The material which is defined for the whole body.   Available material models:\nBBMaterial: Bond-based peridynamics.\nDHBBMaterial: Dual-horizon bond-based peridynamics.\nGBBMaterial: Generalized bond-based peridynamics.\nOSBMaterial: Ordinary state-based peridynamics, also called linear   peridynamic solid (LPS).\nCMaterial: Correspondence formulation.\nCRMaterial: Correspondence formulation with stress rotation for objectivity   enforcement.\nRKCMaterial: Reproducing kernel peridynamics with bond-associated   higher-order integration.\nRKCRMaterial: Reproducing kernel peridynamics with bond-associated   higher-order integration with stress rotation for objectivity enforcement.\nBACMaterial: Bond-associated correspondence formulation of Chen and Spencer.\nCKIMaterial: Continuum-kinematics-inspired peridynamics.\nposition::AbstractMatrix: A 3×n matrix with the point position of the n points.\nvolume::AbstractVector: A vector with the volume of each point.\ninp_file::AbstractString: An Abaqus input file containing meshes, imported with   read_inp.\n\nThrows\n\nError if the number of points is not larger than zero.\nError if position is not a 3×n matrix and has the same length as volume.\nError if position or volume contain NaN values.\n\nExample\n\njulia> Body(BBMaterial(), rand(3, 10), rand(10))\n10-point Body{BBMaterial{NoCorrection}}:\n  1 point set(s):\n    10-point set `all_points`\n\n\n\nwarning: Internal use only\nPlease note that the fields are intended for internal use only. They are not part of the public API of Peridynamics.jl, and thus can be altered (or removed) at any time without it being considered a breaking change.\n\nBody{Material,PointParameters}\n\nType Parameters\n\nMaterial <: AbstractMaterial: Type of the specified material model.\nPointParameters <: AbstractPointParameters: Type of the point parameters.\n\nFields\n\nmat::Material: The material formulation.\nn_points::Int: The number of points that in the body.\nposition::Matrix{Float64}: A 3×n_points matrix with the position of the points.\nvolume::Vector{Float64}: A vector with the volume of each point.\nfail_permit::Vector{Bool}: A vector that describes if failure is allowed for each point.\npoint_sets::Dict{Symbol,Vector{Int}}: A dictionary containing point sets.\npoint_params::Vector{PointParameters}: A vector containing all different point parameter   instances of the body. Each point can have its own PointParameters instance.\nparams_map::Vector{Int}: A vector that maps each point index to a parameter instance in   point_params.\nsingle_dim_bcs::Vector{SingleDimBC}: A vector with boundary conditions on a single   dimension.\nposdep_single_dim_bcs::Vector{PosDepSingleDimBC}: A vector with position dependent   boundary conditions on a single dimension.\nsingle_dim_ics::Vector{SingleDimIC}: A vector with initial conditions on a single   dimension.\nposdep_single_dim_ics::Vector{PosDepSingleDimIC}: A vector with position dependent   initial conditions on a single dimension.\ndata_bcs::Vector{DataBC}: A vector with data boundary conditions.\npoint_sets_precracks::Vector{PointSetsPreCrack}: A vector with predefined point set   cracks.\n\n\n\n\n\n","category":"type"},{"location":"public_api_reference/#Peridynamics.MultibodySetup","page":"Public API","title":"Peridynamics.MultibodySetup","text":"MultibodySetup(body_pairs...)\n\nSetup for a peridynamic simulation with multiple bodies.\n\nArguments\n\nbody_pairs::Pair{Symbol,<:AbstractBody}: Pairs of :body_name => body_object.   The name of the body has to be specified as a Symbol.\n\nThrows\n\nError if less than 2 bodies are defined.\n\nExamples\n\njulia> sphere = Body(BBMaterial(), pos_sphere, vol_sphere)\n280-point Body{BBMaterial{NoCorrection}}:\n  1 point set(s):\n    280-point set `all_points`\n\njulia> plate = Body(BBMaterial(), pos_plate, vol_plate)\n25600-point Body{BBMaterial{NoCorrection}}:\n  1 point set(s):\n    25600-point set `all_points`\n\njulia> ms = MultibodySetup(:sphere => sphere, :plate => plate)\n25880-point MultibodySetup:\n  280-point Body{BBMaterial{NoCorrection}} with name `sphere`\n  25600-point Body{BBMaterial{NoCorrection}} with name `plate`\n\n\n\nwarning: Internal use only\nPlease note that the fields are intended for internal use only. They are not part of the public API of Peridynamics.jl, and thus can be altered (or removed) at any time without it being considered a breaking change.\n\nMultibodySetup{Bodies}\n\nType Parameters\n\nBodies <: Tuple: All types of the different bodies in the multibody setup.\n\nFields\n\nbodies::Bodies: A Tuple containing all the bodies.\nbody_names::Vector{Symbol}: All body names.\nbody_idxs::Dict{Symbol,Int}: A Dict to get the body index with the body name.\nsrf_contacts::Vector{ShortRangeForceContact}: All short range force contacts.\n\n\n\n\n\n","category":"type"},{"location":"public_api_reference/#Peridynamics.point_set!","page":"Public API","title":"Peridynamics.point_set!","text":"point_set!(body, set_name, points)\npoint_set!(fun, body, set_name)\n\nAdd a point set to a Body. The points of the set can be either specified directly with the points::AbstractVector argument, or as the result of the filter function fun. By default, a body already contains a point set with the name :all_points, containg a set with all points.\n\nArguments\n\nbody::AbstractBody: Body where the set will be added.\nset_name::Symbol: Name of the point set.\npoints::AbstractVector: Some vector containing the point indices of the set.   The indices have to be in bounds with the position and volume of body.\nfun::Function: Function for filtering points. This function accepts only one positional   argument and will be used in a findall call. Depending on the argument name,   a different input will be processed:\nx: The function will receive the x-coordinate of each point in position of body:\npoints = findall(fun, @view(position[1, :]))\ny: The function will receive the y-coordinate of each point in position of body:\npoints = findall(fun, @view(position[2, :]))\nz: The function will receive the z-coordinate of each point in position of body:\npoints = findall(fun, @view(position[3, :]))\np: The function will receive the a vector containing each dimension of each point in position of body:\npoints = findall(fun, eachcol(position))\n\nThrows\n\nError if a point set with the same set_name already exists.\nError if points are not in bounds with position and volume of the body.\n\nExamples\n\nAdd a point set to body with all points that have a x-corrdinate larger than zero:\n\njulia> point_set!(x -> x > 0, body, :larger_than_zero)\n\njulia> point_sets(body)\nDict{Symbol, Vector{Int64}} with 2 entries:\n  :larger_than_zero => [6, 7, 8, 9, 10, 16, 17, 18, 19, 20  …  9…\n  :all_points       => [1, 2, 3, 4, 5, 6, 7, 8, 9, 10  …  991, 9…\n\nAdd a point set to body with all points that are positioned inside a sphere with radius r around the center. Note that the do-syntax can be used, as fun is the first argument of point_set!:\n\njulia> point_set!(body, :inside_sphere) do p\n           sqrt(p[1]^2 + p[2]^2 + p[3]^2) ≤ r\n       end\n\njulia> point_sets(body)\nDict{Symbol, Vector{Int64}} with 2 entries:\n  :larger_than_zero => [6, 7, 8, 9, 10, 16, 17, 18, 19, 20  …  9…\n  :inside_sphere    => [1, 2, 3, 4, 5, 6, 7, 8, 9, 10  …  991, 9…\n\n\n\n\n\n","category":"function"},{"location":"public_api_reference/#Peridynamics.point_sets","page":"Public API","title":"Peridynamics.point_sets","text":"point_sets(body)\n\nReturn all point sets of body.\n\nArguments\n\nbody::AbstractBody: Body.\n\nExample\n\njulia> body = Body(BBMaterial(), rand(3,100), rand(100))\n100-point Body{BBMaterial{NoCorrection}}:\n  100-point set `all_points`\n\njulia> point_set!(body, :set_a, 1:10) # first ten points\n\njulia> Peridynamics.point_sets(body)\nDict{Symbol, Vector{Int64}} with 2 entries:\n  :all_points => [1, 2, 3, 4, 5, 6, 7, 8, 9, 10  …  91, 92, 93, 94, 95, 96, 97, 98, 9…\n  :set_a      => [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n\n\n\n\n\n","category":"function"},{"location":"public_api_reference/#Peridynamics.no_failure!","page":"Public API","title":"Peridynamics.no_failure!","text":"no_failure!(body::AbstractBody, set_name::Symbol)\nno_failure!(body::AbstractBody)\n\nDisallow failure for all points of the point set set_name of the body. If no set_name is specified, failure is prohibited for the whole body.\n\nArguments\n\nbody::AbstractBody: Body for which failure is prohibited.\nset_name::Symbol: The name of a point set of this body.\n\ndanger: Overwriting failure permission with `material!` and `no_failure!`\nThe function material! sets failure permissions due to the provided input parameters, so if it is used afterwards, previously set failure prohibitions might be overwritten!\n\nThrows\n\nError if the body does not contain a set with set_name.\n\nExamples\n\njulia> no_failure!(body)\n\njulia> body\n1000-point Body{BBMaterial{NoCorrection}}:\n  1 point set(s):\n    1000-point set `all_points`\n  1000 points with failure prohibited\n\n\n\n\n\n","category":"function"},{"location":"public_api_reference/#Peridynamics.material!","page":"Public API","title":"Peridynamics.material!","text":"material!(body, set_name; kwargs...)\nmaterial!(body; kwargs...)\n\nAssign material point parameters to points of body. If no set_name is specified, then the parameters will be set for all points of the body.\n\nArguments\n\nbody::AbstractBody: Body.\nset_name::Symbol: The name of a point set of this body.\n\nKeywords\n\nAllowed keywords depend on the selected material model. Please look at the documentation of the material you specified when creating the body. The default material keywords are:\n\nMaterial parameters:\n\nhorizon::Float64: Radius of point interactions.\nrho::Float64: Density.\n\nElastic parameters:\n\nE::Float64: Young's modulus.\nnu::Float64: Poisson's ratio.\nG::Float64: Shear modulus.\nK::Float64: Bulk modulus.\nlambda::Float64: 1st Lamé parameter.\nmu::Float64: 2nd Lamé parameter.\n\nFracture parameters:\n\nGc::Float64: Critical energy release rate.\nepsilon_c::Float64: Critical strain.\n\nnote: Elastic parameters\nNote that exactly two elastic parameters are required to specify a material.\n\nnote: Fracture parameters\nTo enable fracture in a simulation, define one of the allowed fracture parameters. If none are defined, fracture is disabled.\n\nThrows\n\nError if a kwarg is not eligible for specification with the body material.\n\nExample\n\njulia> material!(body; horizon=3.0, E=2.1e5, rho=8e-6, Gc=2.7)\n\njulia> body\n1000-point Body{BBMaterial{NoCorrection}}:\n  1 point set(s):\n    1000-point set `all_points`\n  1 point parameter(s):\n    Parameters BBMaterial: δ=3.0, E=210000.0, nu=0.25, rho=8.0e-6, Gc=2.7\n\n\n\n\n\n","category":"function"},{"location":"public_api_reference/#Peridynamics.velocity_bc!","page":"Public API","title":"Peridynamics.velocity_bc!","text":"velocity_bc!(fun, body, set_name, dim)\n\nSpecify velocity boundary condition for points of the set set_name in body. The value of the boundary condition is calculated with the function fun at every time step.\n\nArguments\n\nfun::Function: Condition function for the calculation of a value, should return a   Float64. If the condition function returns a NaN, then this value is ignored, which   can be used to turn conditions off after a specified period of time. This function   accepts one ore two positional arguments and is aware of the argument names.   Possible arguments and names:\nfun(t): The function will receive the current time t at every time step.   This makes it possible to specify conditions that change over time.\nfun(p, t): This function will be processed for every point of set_name and   receives the reference position of a point as SVector{3} and the current time t   at every time step. This makes it possible to specify conditions that   also depend on the position of a point.\nbody::AbstractBody: Body the condition is specified on.\nset_name::Symbol: The name of a point set of this body.\ndim::Union{Integer,Symbol}: Direction of the condition, either specified as Symbol or   integer.\nx-direction: :x or 1\ny-direction: :y or 2\nz-direction: :z or 3\n\nThrows\n\nError if the body does not contain a set with set_name.\nError if the direction is not correctly specified.\nError if function is not suitable as condition function and has the wrong arguments.\n\nExample\n\njulia> velocity_bc!(t -> 2.0, body, :all_points, 1)\n\njulia> velocity_bc!((p,t) -> p[1] * t, body, :all_points, :y)\n\njulia> velocity_bc!(t -> t > 0.00001 ? 1.0 : NaN, body, :all_points, :z)\n\njulia> body\n1000-point Body{BBMaterial{NoCorrection}}:\n  1 point set(s):\n    1000-point set `all_points`\n  3 boundary condition(s):\n    BC on velocity: point_set=all_points, dim=1\n    BC on velocity: point_set=all_points, dim=3\n    Pos.-dep. BC on velocity: point_set=all_points, dim=2\n\n\n\n\n\n","category":"function"},{"location":"public_api_reference/#Peridynamics.velocity_ic!","page":"Public API","title":"Peridynamics.velocity_ic!","text":"velocity_ic!(body, set_name, dim, value)\nvelocity_ic!(fun, body, set_name, dim)\n\nSpecify velocity initial condition for points of the set set_name in body. The value of the initial condition is specified before time integration. If a function fun is specified, then the value is with that function.\n\nArguments\n\nbody::AbstractBody: Body the condition is specified on.\nset_name::Symbol: The name of a point set of this body.\ndim::Union{Integer,Symbol}: Direction of the condition, either specified as Symbol or   integer.\nx-direction: :x or 1\ny-direction: :y or 2\nz-direction: :z or 3\nvalue::Real: Value that is specified before time integration.\nfun::Function: Condition function for the calculation of a value, should return a   Float64. If the condition function returns a NaN, then this value is ignored, which   can be used to turn off the condition for a specified position. This function   accepts one ore two positional arguments and is aware of the argument names.   Possible arguments and names:\nfun(p): The function will receive the reference position p of a point as   SVector{3}.\n\nThrows\n\nError if the body does not contain a set with set_name.\nError if the direction is not correctly specified.\nError if function is not suitable as condition function and has the wrong arguments.\n\nExample\n\njulia> velocity_ic!(body, :all_points, :x, -100.0)\n\njulia> body\n1000-point Body{BBMaterial{NoCorrection}}:\n  1 point set(s):\n    1000-point set `all_points`\n  1 initial condition(s):\n    IC on velocity: point_set=all_points, dim=1\n\n\n\n\n\n","category":"function"},{"location":"public_api_reference/#Peridynamics.forcedensity_bc!","page":"Public API","title":"Peridynamics.forcedensity_bc!","text":"forcedensity_bc!(fun, body, set, dim)\n\nSpecify force density boundary condition for points of the set set_name in body. The value of the boundary condition is calculated with the function fun at every time step.\n\nArguments\n\nfun::Function: Condition function for the calculation of a value, should return a   Float64. If the condition function returns a NaN, then this value is ignored, which   can be used to turn conditions off after a specified period of time. This function   accepts one ore two positional arguments and is aware of the argument names.   Possible arguments and names:\nfun(t): The function will receive the current time t at every time step.   This makes it possible to specify conditions that change over time.\nfun(p, t): This function will be processed for every point of set_name and   receives the reference position of a point as SVector{3} and the current time t   at every time step. This makes it possible to specify conditions that   also depend on the position of a point.\nbody::AbstractBody: Body the condition is specified on.\nset_name::Symbol: The name of a point set of this body.\ndim::Union{Integer,Symbol}: Direction of the condition, either specified as Symbol or   integer.\nx-direction: :x or 1\ny-direction: :y or 2\nz-direction: :z or 3\n\nThrows\n\nError if the body does not contain a set with set_name.\nError if the direction is not correctly specified.\nError if function is not suitable as condition function and has the wrong arguments.\n\nExample\n\njulia> forcedensity_bc!(t -> 8000.0, body, :all_points, :x)\n\njulia> forcedensity_bc!((p,t) -> p[1] * t, body, :all_points, :y)\n\njulia> forcedensity_bc!(t -> t > 0.00001 ? 8000.0 : NaN, body, :all_points, :z)\n\njulia> body\n1000-point Body{BBMaterial{NoCorrection}}:\n  1 point set(s):\n    1000-point set `all_points`\n  3 boundary condition(s):\n    BC on force density: point_set=all_points, dim=1\n    BC on force density: point_set=all_points, dim=3\n    Pos.-dep. BC on force density: point_set=all_points, dim=2\n\n\n\n\n\n","category":"function"},{"location":"public_api_reference/#Peridynamics.displacement_bc!","page":"Public API","title":"Peridynamics.displacement_bc!","text":"displacement_bc!(f::Function, body::Body, points::Vector{Int}, dim::Int)\n\nwarning: Compatibility limited\nThis boundary condition type only works with the NewtonKrylov solver for now.\n\nApply a displacement boundary condition to specified points in a given dimension. A factor β is calculated as n / n_steps, where n is the current step number and n_steps is the total number of steps. Then the return value of the function f is multiplicated with β at each time step. This means that the displacement will be applied gradually over the course of the simulation.\n\nArguments:\n\nfun::Function: Condition function for the calculation of a value, should return a   Float64. If the condition function returns a NaN, then this value is ignored, which   can be used to turn conditions off. This function accepts only one argument and is aware   of the argument names. Possible arguments and names:\nfun(p): This function will be processed for every point of set_name and   receives the reference position of a point as SVector{3} at every time step.   This makes it possible to specify conditions that depend on the position of a point.\nbody::AbstractBody: Body the condition is specified on.\nset_name::Symbol: The name of a point set of this body.\ndim::Union{Integer,Symbol}: Direction of the condition, either specified as Symbol or   integer.\nx-direction: :x or 1\ny-direction: :y or 2\nz-direction: :z or 3\n\nReturns:\n\nnothing: No return value. The boundary condition is added to the body.\n\nExample:\n\n# Apply constant prescribed displacement\npoints = [1, 2, 3, 4, 5]\ndisplacement_bc!(p -> 0.1, body, points, 1)\n\n# Apply prescribed displacement based on position\ndisplacement_bc!(p -> 0.01 * p[1], body, points, 2)\n\n\n\n\n\n","category":"function"},{"location":"public_api_reference/#Peridynamics.precrack!","page":"Public API","title":"Peridynamics.precrack!","text":"precrack!(body, set_a, set_b; update_dmg=true)\n\nCreate a crack between two point sets by prohibiting interaction between points of different point sets. The points in set_a are not allowed to interact with points in set_b.\n\nArguments\n\nbody::AbstractBody: Body.\nset_a::Symbol: The name of a point set of this body.\nset_b::Symbol: The name of a point set of this body.\n\nKeywords\n\nupdate_dmg::Bool: If true, the material points involved in the predefined crack are   initially damaged. If false, the bonds involved are deleted and the material points   involved with the predefined crack are not damaged in the reference results.   (default: true)\n\nThrows\n\nError if the body does not contain sets with name set_a and set_b.\nError if the point sets intersect and a point is included in both sets.\n\nExample\n\njulia> point_set!(body, :a, 1:2)\n\njulia> point_set!(body, :b, 3:4)\n\njulia> precrack!(body, :a, :b)\n\njulia> body\n1000-point Body{BBMaterial{NoCorrection}}:\n  3 point set(s):\n    1000-point set `all_points`\n    2-point set `a`\n    2-point set `b`\n  1 predefined crack(s)\n\n\n\n\n\n","category":"function"},{"location":"public_api_reference/#Peridynamics.contact!","page":"Public API","title":"Peridynamics.contact!","text":"contact!(multibody_setup, name_body_a, name_body_b; kwargs...)\n\nDefine a short range force contact between body name_body_a and name_body_b in the MultibodySetup multibody_setup.\n\nArguments\n\nmultibody_setup::MultibodySetup: MultibodySetup.\nname_body_a::Symbol: The name of a body in this multibody setup.\nname_body_b::Symbol: The name of a body in this multibody setup.\n\nKeywords\n\nradius::Float64: Contact search radius. If a the distance of a point in body   name_body_a and a point in body name_body_b is lower than this radius, a contact   force is calculated. This radius should be in the order of the point spacing of a   point cloud.\npenalty_factor::Float64: Penalty factor for the short range force contact algorithm.   (default: 1e12)\n\nThrows\n\nError if multibody_setup does not contain bodies with name name_body_a and   name_body_b.\nError if the keyword radius is not specified or radius ≤ 0.\nError if penalty_factor ≤ 0.\n\nExamples\n\njulia> ms = MultibodySetup(:a => body_a, :b => body_b)\n2000-point MultibodySetup:\n  1000-point Body{BBMaterial{NoCorrection}} with name `b`\n  1000-point Body{BBMaterial{NoCorrection}} with name `b`\n\njulia> contact!(ms, :a, :b; radius=0.001)\n\njulia> ms\n2000-point MultibodySetup:\n  1000-point Body{BBMaterial{NoCorrection}} with name `b`\n  1000-point Body{BBMaterial{NoCorrection}} with name `b`\n  2 short range force contact(s)\n\n\n\n\n\n","category":"function"},{"location":"public_api_reference/#Peridynamics.uniform_box","page":"Public API","title":"Peridynamics.uniform_box","text":"uniform_box(lx, ly, lz, ΔX0; kwargs...)\n\nCreate a grid of uniformly distributed points in a cuboid with lengths lx, ly and lz and point spacing ΔX0.\n\nArguments\n\nlx::Real: Length in x-dimension.\nly::Real: Length in y-dimension.\nlz::Real: Length in z-dimension.\nΔX0::Real: Spacing of the points.\n\nKeywords\n\ncenter: The coordinates of the center of the cuboid. The center coordinates are added           to all point coordinates. Default: (0, 0, 0)\n\nReturns\n\nposition::Matrix{Float64}: A 3×n_points matrix with the position of the points.\nvolume::Vector{Float64}: A vector with the volume of each point.\n\nExamples\n\njulia> position, volume = uniform_box(10, 10, 10, 2);\n\njulia> position\n3×125 Matrix{Float64}:\n -4.0  -2.0   0.0   2.0   4.0  -4.0  -2.0  …  0.0  2.0  4.0  -4.0  -2.0  0.0  2.0  4.0\n -4.0  -4.0  -4.0  -4.0  -4.0  -2.0  -2.0     2.0  2.0  2.0   4.0   4.0  4.0  4.0  4.0\n -4.0  -4.0  -4.0  -4.0  -4.0  -4.0  -4.0     4.0  4.0  4.0   4.0   4.0  4.0  4.0  4.0\n\njulia> volume\n125-element Vector{Int64}:\n 8\n 8\n 8\n 8\n ⋮\n 8\n 8\n 8\n 8\n\n\n\n\n\n","category":"function"},{"location":"public_api_reference/#Peridynamics.uniform_sphere","page":"Public API","title":"Peridynamics.uniform_sphere","text":"uniform_sphere(diameter, ΔX0; kwargs...)\n\nCreate a grid of uniformly distributed points in a sphere with a specific diameter and the point spacing ΔX0. Due to the uniform point spacings, edges on the surface of the sphere can occur.\n\nArguments\n\ndiameter::Real: Diameter of the sphere.\nΔX0::Real: Spacing of the points.\n\nKeywords\n\ncenter: The coordinates of the center of the sphere. The center coordinates are added           to all point coordinates. Default: (0, 0, 0)\n\nReturns\n\nposition::Matrix{Float64}: A 3×n_points matrix with the position of the points.\nvolume::Vector{Float64}: A vector with the volume of each point.\n\nExamples\n\njulia> position, volume = uniform_sphere(10, 2);\n\njulia> position\n3×81 Matrix{Float64}:\n -2.0   0.0   2.0  -2.0   0.0   2.0  -2.0  …   0.0   2.0  -2.0  0.0  2.0  -2.0  0.0  2.0\n -2.0  -2.0  -2.0   0.0   0.0   0.0   2.0     -2.0  -2.0   0.0  0.0  0.0   2.0  2.0  2.0\n -4.0  -4.0  -4.0  -4.0  -4.0  -4.0  -4.0      4.0   4.0   4.0  4.0  4.0   4.0  4.0  4.0\n\njulia> volume\n81-element Vector{Int64}:\n 8\n 8\n 8\n 8\n 8\n ⋮\n 8\n 8\n 8\n 8\n 8\n\n\n\n\n\n","category":"function"},{"location":"public_api_reference/#Peridynamics.uniform_cylinder","page":"Public API","title":"Peridynamics.uniform_cylinder","text":"uniform_cylinder(diameter::Real, height::Real, ΔX0::Real; kwargs...)\n\nCreate a grid of uniformly distributed points in a cylindrical shape with a specific height in z-dimension, a diameter and the point spacing ΔX0. Due to the uniform point spacings, edges on the surface of the cylinder can occur.\n\nArguments\n\ndiameter::Real: Diameter of the cylinder.\nheight::Real: Height of the cylinder.\nΔX0::Real: Spacing of the points.\n\nKeywords\n\ncenter: The coordinates of the center of the cylinder. The center coordinates are added           to all point coordinates. Default: (0, 0, 0)\n\nReturns\n\nposition::Matrix{Float64}: A 3×n_points matrix with the position of the points.\nvolume::Vector{Float64}: A vector with the volume of each point.\n\nExamples\n\njulia> position, volume = uniform_cylinder(5, 10, 2);\n\njulia> position\n3×20 Matrix{Float64}:\n -1.0   1.0  -1.0   1.0  -1.0   1.0  -1.0  …   1.0  -1.0  1.0  -1.0   1.0  -1.0  1.0\n -1.0  -1.0   1.0   1.0  -1.0  -1.0   1.0     -1.0   1.0  1.0  -1.0  -1.0   1.0  1.0\n -4.0  -4.0  -4.0  -4.0  -2.0  -2.0  -2.0      2.0   2.0  2.0   4.0   4.0   4.0  4.0\n\njulia> volume\n20-element Vector{Int64}:\n 8\n 8\n 8\n 8\n 8\n ⋮\n 8\n 8\n 8\n 8\n 8\n\n\n\n\n\n","category":"function"},{"location":"public_api_reference/#Peridynamics.round_sphere","page":"Public API","title":"Peridynamics.round_sphere","text":"round_sphere(diameter, ΔX0; kwargs...)\n\nCreate a grid of points distributed in a smooth sphere without edges on the surface with a specific diameter and the point spacing ΔX0. Internally, some parts of TrixiParticles.jl were copied and adapted for this function.\n\nArguments\n\ndiameter::Real: Diameter of the sphere.\nΔX0::Real: Spacing of the points.\n\nKeywords\n\ncenter: The coordinates of the center of the sphere. The center coordinates are added           to all point coordinates. Default: (0, 0, 0)\n\nReturns\n\nposition::Matrix{Float64}: A 3×n_points matrix with the position of the points.\nvolume::Vector{Float64}: A vector with the volume of each point.\n\nExamples\n\njulia> position, volume = round_sphere(10, 2);\n\njulia> position\n3×63 Matrix{Float64}:\n 0.0  1.74586  0.539501  -1.41243  -1.41243  …  -1.95518   -0.48289   1.35303   0.0\n 0.0  0.0      1.66041    1.02619  -1.02619     -0.941566  -2.11568  -1.69664   0.0\n 2.0  0.97569  0.97569    0.97569   0.97569     -3.36017   -3.36017  -3.36017  -4.0\n\njulia> volume\n63-element Vector{Float64}:\n 8.311091676163475\n 8.311091676163475\n 8.311091676163475\n 8.311091676163475\n 8.311091676163475\n ⋮\n 8.311091676163475\n 8.311091676163475\n 8.311091676163475\n 8.311091676163475\n\n\n\n\n\n","category":"function"},{"location":"public_api_reference/#Peridynamics.round_cylinder","page":"Public API","title":"Peridynamics.round_cylinder","text":"round_cylinder(diameter::Real, height::Real, ΔX0::Real; kwargs...)\n\nCreate a grid of  points distributed in a cylindrical shape with a specific height in z-dimension, a diameter and the point spacing ΔX0. Due to a concentric point distribution in the x-y-plane, there are no sharp edges that appear on the surface of the cylinder.\n\nArguments\n\ndiameter::Real: Diameter of the cylinder.\nheight::Real: Height of the cylinder.\nΔX0::Real: Spacing of the points.\n\nKeywords\n\ncenter: The coordinates of the center of the cylinder. The center coordinates are added           to all point coordinates. Default: (0, 0, 0)\n\nReturns\n\nposition::Matrix{Float64}: A 3×n_points matrix with the position of the points.\nvolume::Vector{Float64}: A vector with the volume of each point.\n\nExamples\n\njulia> position, volume = round_cylinder(5, 10, 2);\n\njulia> position\n3×30 Matrix{Float64}:\n  1.5   0.463525  -1.21353   -1.21353   …  -1.21353   -1.21353    0.463525\n  0.0   1.42658    0.881678  -0.881678      0.881678  -0.881678  -1.42658\n -5.0  -5.0       -5.0       -5.0           5.0        5.0        5.0\n\njulia> volume\n30-element Vector{Int64}:\n 13.089969389957473\n 13.089969389957473\n 13.089969389957473\n 13.089969389957473\n 13.089969389957473\n  ⋮\n 13.089969389957473\n 13.089969389957473\n 13.089969389957473\n 13.089969389957473\n\n\n\n\n\n","category":"function"},{"location":"public_api_reference/#Peridynamics.trunc_pyramid","page":"Public API","title":"Peridynamics.trunc_pyramid","text":"    trunc_pyramid(L, d0, dL, nd; center=(0,0,0))\n\nCreate a grid of points distributed in a truncated pyramid shape (frustum) with points arranged in square cross-sections. Internally the function generates layers for x ∈ [0, L] and then recenters the x-coordinates by subtracting L/2, so the resulting x-range is [-L/2, L/2] before applying the center offset. The center vector is added to all point coordinates, therefore the middle of the longitudinal axis of the frustum ends up at center.\n\nThe square side length varies linearly from d0 at the left end (internal x = 0, final x = -L/2 + center_x) to dL at the right end (internal x = L, final x = +L/2 + center_x). Each cross-section (layer) contains nd × nd points placed on a regular square grid; the layer thickness is determined by the local spacing Δx = d / nd where d is the side length of that layer, and point volumes are set to Δx^3 for the corresponding layer.\n\nArguments\n\nL::Real: Length of the pyramid in the x-direction (unshifted internal   coordinate goes from 0 to L).\nd0::Real: Side length of the square cross-section at the internal left end   x = 0 (final x = -L/2 + center_x).\ndL::Real: Side length of the square cross-section at the internal right end   x = L (final x = +L/2 + center_x).\nnd::Integer: Number of points per side in each square cross-section.\n\nKeywords\n\ncenter: The coordinates of the center of the pyramid. The center coordinates are added   to all generated point coordinates. Default: (0, 0, 0).\n\nReturns\n\nposition::Matrix{Float64}: A 3×n_points matrix with the coordinates of   all generated points.\nvolume::Vector{Float64}: A vector with the volume assigned to each point.   Volumes are set per-layer to the cube of the local spacing (i.e. Δx^3).\n\nExamples\n\njulia> # centered at origin (default): left end at x = -L/2, right end at x = +L/2\njulia> position, volume = trunc_pyramid(10.0, 4.0, 2.0, 4);\n\njulia> # place the pyramid so its center (middle of the longitudinal axis) is at x = 5.0\njulia> position, volume = trunc_pyramid(10.0, 4.0, 2.0, 4; center=(5.0,0.0,0.0));\n\n\n\n\n\n","category":"function"},{"location":"public_api_reference/#Peridynamics.n_points","page":"Public API","title":"Peridynamics.n_points","text":"n_points(body)\n\nReturn the total number of points in a body.\n\nArguments\n\nbody::Body: Body.\n\nReturns\n\nn_points::Int: The number of points in the body.\n\nExamples\n\njulia> body = Body(BBMaterial(), pos, vol)\n1000-point Body{BBMaterial{NoCorrection}}:\n  1 point set(s):\n    1000-point set `all_points`\n\njulia> n_points(body)\n1000\n\n\n\nn_points(multibody_setup)\n\nReturn the total number of points in a multibody setup.\n\nArguments\n\nmultibody_setup::MultibodySetup: MultibodySetup.\n\nReturns\n\nn_points::Int: The sum of all points from all bodies in the multibody setup.\n\nExamples\n\njulia> ms = MultibodySetup(:a => body_a, :b => body_b)\n2000-point MultibodySetup:\n  1000-point Body{BBMaterial{NoCorrection}} with name `a`\n  1000-point Body{BBMaterial{NoCorrection}} with name `b`\n\njulia> n_points(ms)\n2000\n\n\n\n\n\n","category":"function"},{"location":"public_api_reference/#Peridynamics.AbaqusMeshConverter.read_inp","page":"Public API","title":"Peridynamics.AbaqusMeshConverter.read_inp","text":"read_inp(file::String)\n\nRead Abaqus .inp-file and convert meshes to a point cloud with the help of the AbaqusReader.jl package. Every element is converted to a point. The center of the element becomes the position of the point and the element volume becomes the point volume. Element sets defined in Abaqus are converted to corresponding point sets.\n\nCurrently supported mesh elements: [:Tet4, :Hex8]\n\nArguments\n\nfile::String: Path to Abaqus .inp-file.\n\nReturns\n\nposition::Matrix{Float64}: Point position (midpoint of every element).\nvolume::Vector{Float64}: Point volume (volume of every element).\npoint_sets: Element sets defined in the .inp-file.\n\n\n\n\n\n","category":"function"},{"location":"public_api_reference/#Peridynamics.mpi_isroot","page":"Public API","title":"Peridynamics.mpi_isroot","text":"mpi_isroot()\n\nHelper function that returns a bool indicating if a process is the MPI root process. It can be safely used even for multithreading simulations, as it is always true if the package is started in a normal Julia environment which is not started by MPI.\n\n\n\n\n\n","category":"function"},{"location":"public_api_reference/#Peridynamics.mpi_barrier","page":"Public API","title":"Peridynamics.mpi_barrier","text":"mpi_barrier()\n\nSynchronize all MPI ranks at a barrier point. This is a no-op when not running with MPI. Use this to ensure all ranks reach the same point before continuing execution.\n\nWhen running with MPI, this function causes all ranks to wait until every rank has called it, providing a synchronization point in the program. This is useful when you need to ensure that all ranks have completed a certain phase before proceeding to the next.\n\nExample\n\n# Wait here before all ranks continue\nmpi_barrier()\n\nSee also: mpi_isroot, @mpiroot, process_each_export\n\n\n\n\n\n","category":"function"},{"location":"public_api_reference/#Peridynamics.force_mpi_run!","page":"Public API","title":"Peridynamics.force_mpi_run!","text":"force_mpi_run!()\n\nHelper function to force the usage of the MPI backend. After this function is called, all following simulations will use MPI.\n\n\n\n\n\n","category":"function"},{"location":"public_api_reference/#Peridynamics.force_threads_run!","page":"Public API","title":"Peridynamics.force_threads_run!","text":"force_threads_run!()\n\nHelper function to force the usage of the multithreading backend. After this function is called, all following simulations will use multithreading.\n\n\n\n\n\n","category":"function"},{"location":"public_api_reference/#Peridynamics.enable_mpi_timers!","page":"Public API","title":"Peridynamics.enable_mpi_timers!","text":"enable_mpi_timers!()\n\nHelper function to enable timers defined with the TimerOutputs for simulations with the MPI backend. The results of the timers then will be exported into the specified path of a Job. By default, not timers will be used with MPI simulations. It can be safely used with multithreading.\n\nSee also disable_mpi_timers!.\n\n\n\n\n\n","category":"function"},{"location":"public_api_reference/#Peridynamics.disable_mpi_timers!","page":"Public API","title":"Peridynamics.disable_mpi_timers!","text":"disable_mpi_timers!()\n\nHelper function to disable timers defined with the TimerOutputs for simulations with the MPI backend. It is mainly used to reset the behaviour after a call of enable_mpi_timers!. It can be safely used with multithreading.\n\n\n\n\n\n","category":"function"},{"location":"public_api_reference/#Peridynamics.enable_mpi_progress_bars!","page":"Public API","title":"Peridynamics.enable_mpi_progress_bars!","text":"enable_mpi_progress_bars!()\n\nHelper function to enable progress bars with MPI simulations on a personal computer. After this function is called, progress bars are beeing shown with MPI simulations like with multithreading simulations. This behavior can be reset to default with reset_mpi_progress_bars!.\n\nwarning: Progress bars and output files\nProgress bars are by default disabled with MPI simulations, because they can really mess up with the output files produced by a HPC system. Therefore, a warning is shown as a reminder to reset this behaviour before submitting a job to a cluster!\n\n\n\n\n\n","category":"function"},{"location":"public_api_reference/#Peridynamics.reset_mpi_progress_bars!","page":"Public API","title":"Peridynamics.reset_mpi_progress_bars!","text":"reset_mpi_progress_bars!()\n\nAfter this function is called, progress bars are again disabled on MPI simulations (standard setting). This will reset the behavior after a call of enable_mpi_progress_bars!.\n\n\n\n\n\n","category":"function"},{"location":"public_api_reference/#Peridynamics.@mpitime","page":"Public API","title":"Peridynamics.@mpitime","text":"@mpitime expression\n\nTime the expression if the mpi rank is zero. Lowers to:\n\nif mpi_isroot()\n    @time expression\nelse\n    expression\nend\n\nSee also: mpi_isroot.\n\n\n\n\n\n","category":"macro"},{"location":"public_api_reference/#Peridynamics.@mpiroot","page":"Public API","title":"Peridynamics.@mpiroot","text":"@mpiroot [option] expression\n\nRun the code if the mpi rank is zero. Lowers to something similar as:\n\nif mpi_isroot()\n    expression\nend\n\nOptions\n\n:wait: All MPI ranks will wait until the root rank finishes evaluating expression.\n\nSee also: mpi_isroot.\n\n\n\n\n\n","category":"macro"},{"location":"public_api_reference/#Peridynamics.VelocityVerlet","page":"Public API","title":"Peridynamics.VelocityVerlet","text":"VelocityVerlet(; kwargs...)\n\nTime integration solver for the Velocity Verlet algorithm. Specify either the number of steps or the time the simulation should cover.\n\nKeywords\n\ntime::Real: The total time the simulation will cover. If this keyword is specified, the   keyword steps is no longer allowed. (optional)\nsteps::Int: Number of calculated time steps. If this keyword is specified, the keyword   time is no longer allowed. (optional)\nstepsize::Real: Manually specify the size of the time step. (optional)\nsafety_factor::Real: Safety factor for step size to ensure stability. (default: 0.7)\n\nwarning: Specification of the time step\nKeep in mind that manually specifying the critical time step is dangerous! If the specified time step is too high and the CFL condition no longer holds, the simulation will give wrong results and maybe crash!\n\nThrows\n\nError if both time and steps are specified as keywords.\nError if neither time nor steps are specified as keywords.\nError if safety_factor < 0 or safety_factor > 1.\n\nExample\n\njulia> VelocityVerlet(steps=2000)\nVelocityVerlet:\n  n_steps        2000\n  safety_factor  0.7\n\njulia> VelocityVerlet(time=0.001)\nVelocityVerlet:\n  end_time       0.001\n  safety_factor  0.7\n\njulia> VelocityVerlet(steps=2000, stepsize=0.0001)\n┌ Warning: stepsize specified! Please be sure that the CFD-condition holds!\n└ @ Peridynamics ~/Code/Peridynamics.jl/src/time_solvers/velocity_verlet.jl:66\nVelocityVerlet:\n  n_steps        2000\n  Δt             0.0001\n  safety_factor  0.7\n\n\n\n\n\n","category":"type"},{"location":"public_api_reference/#Peridynamics.DynamicRelaxation","page":"Public API","title":"Peridynamics.DynamicRelaxation","text":"DynamicRelaxation(; kwargs...)\n\nTime integration solver for the adaptive dynamic relaxation algorithm used for quasi-static simulations.\n\nKeywords\n\nsteps::Int: Number of calculated time steps. If this keyword is specified, the keyword   time is no longer allowed.\nstepsize::Real: Manually specify the size of the time step. (default: 1.0)\ndamping_factor::Real: Damping factor to increase the value in the mass matrix.   (default: 1.0)\n\nThrows\n\nError if steps < 0.\nError if stepsize < 0.\nError if damping_factor < 0.\n\nExample\n\njulia> DynamicRelaxation(steps=1000)\nDynamicRelaxation:\n  n_steps  1000\n  Δt       1\n  Λ        1\n\njulia> DynamicRelaxation(steps=1000, damping_factor=2)\nDynamicRelaxation:\n  n_steps  1000\n  Δt       1\n  Λ        2\n\n\n\n\n\n","category":"type"},{"location":"public_api_reference/#Peridynamics.NewtonKrylov","page":"Public API","title":"Peridynamics.NewtonKrylov","text":"NewtonKrylov(; kwargs...)\n\nAn implicit time integration solver for quasi-static peridynamic simulations using the Jacobian-Free Newton-Krylov (JFNK) method.\n\nThe solver uses a matrix-free approach where the Jacobian-vector product is computed via central finite differences: J*v ≈ (F(u + ε*v) - F(u - ε*v)) / (2ε). This eliminates the need to store the full Jacobian matrix, reducing memory from O(n²) to O(n), enabling simulations with large numbers of points.\n\nThe perturbation ε is computed adaptively using the standard JFNK heuristic for central differences: ε = scale * cbrt(ε_mach) * (||u|| + 1) / ||v||, where ε_mach is machine epsilon. This balances truncation error O(ε²) with roundoff error O(ε_mach/ε).\n\nGMRES is used as the Krylov solver for the resulting linear system at each iteration, with an optional diagonal preconditioner computed by probing the Jacobian.\n\nKeywords:\n\ntime::Real: Total simulation time. Cannot be used together with steps.\nsteps::Int: Number of time steps. Cannot be used together with time.\nstepsize::Real: Manual time step size (default: 1.0).\nmaxiter::Int: Maximum number of iterations per step (default: 100).\ntol::Real: Tolerance for convergence (default: 1e-4).\nperturbation_scale::Real: Scale factor for the adaptive perturbation heuristic   (default: 1.0). Increase if finite difference approximation is noisy.\ngmres_maxiter::Int: Maximum number of iterations for GMRES (default: 200).\ngmres_reltol::Real: Relative tolerance for GMRES (default: 1e-4).\ngmres_abstol::Real: Absolute tolerance for GMRES (default: 1e-8).\ngmres_restart::Int: Number of iterations between restarts for GMRES (default: 50).\n\nExample:\n\nsolver = NewtonKrylov(steps=100, stepsize=1e-4, maxiter=50, tol=1e-6)\n\n\n\n\n\n","category":"type"},{"location":"public_api_reference/#Peridynamics.Job","page":"Public API","title":"Peridynamics.Job","text":"Job(spatial_setup, time_solver; kwargs...)\n\nA type that contains all the information necessary for a peridynamic simulation. You can submit a Job to start the simulation.\n\nArguments\n\nspatial_setup: A Body or MultibodySetup.\ntime_solver: VelocityVerlet or DynamicRelaxation.\n\nKeywords\n\npath::String: Path to store results. If it does not exist yet it will be created during   the simulation. (optional)\nfreq::Int: Output frequency of result files. A output file will be written every   freq-th time step. (default: 10)\nfields: Fields that should be exported to output files. Allowed keywords depend on the   selected material model. Please look at the documentation of the material you specified   when creating the body. (default: (:displacement, :damage))\nIf spatial_setup is a Body, the fields keyword can be of the form:\nfields::Symbol: A symbol specifying a single output field.\nfields::NTuple{N,Symbol} where N: A Tuple specifying multiple output fields.\nfields::Vector{Symbol}: A Vector specifying multiple output fields.\nIf spatial_setup is a MultibodySetup, the fields keyword can also be specified   for every body separately:\nfields::Dict{Symbol,T}: A Dictionary containing the fields separately for every   body. T is here every possible type of the fields keyword that can be used for a   single body.\n\nnote: No file export\nIf no keyword is specified when creating a Job, then no files will be exported.\n\nExample\n\njulia> job = Job(multibody_setup, verlet_solver; path=\"my_results/sim1\")\nJob:\n  spatial_setup  25880-point MultibodySetup\n  time_solver    VelocityVerlet(n_steps=2000, safety_factor=0.7)\n  options        export_allowed=true, freq=10\n\n\n\n\n\n","category":"type"},{"location":"public_api_reference/#Peridynamics.Study","page":"Public API","title":"Peridynamics.Study","text":"Study(jobcreator::Function, setups::Vector{<:NamedTuple}; kwargs...)\n\nA structure for managing parameter studies with multiple peridynamic simulations. The Study type coordinates the execution of multiple simulation jobs with different parameter configurations, tracks their status, and logs all results to a central logfile.\n\nIf a logfile already exists at the study root (from a previous interrupted run), the constructor automatically reads it and initializes the sim_success field based on the recorded completion status. This enables seamless resumption of interrupted studies.\n\nArguments\n\njobcreator::Function: A function with signature   jobcreator(setup::NamedTuple, root::String)   that creates and returns a Job object. The function receives:\nsetup: A NamedTuple containing the parameters for one simulation\nroot: The root directory path for the study (to construct individual job paths)\nsetups::Vector{<:NamedTuple}: A vector of parameter configurations. Each element must be   a NamedTuple with the same field names.\n\nKeywords\n\nroot::String: Root directory path where all simulation results and the study logfile   will be stored. This directory and all job subdirectories will be created during   submit!.\nlogfile_name::String: Name of the study logfile. The file will be created in the root   directory.\n  (default: \"study_log.log\")\n\nFields\n\njobcreator::Function: The job creation function\nsetups: Vector of parameter configurations\njobs: Vector of created Job objects\njobpaths::Vector{String}: Paths to individual job directories (must be unique)\nroot::String: Root directory for the study\nlogfile::String: Path to the central study logfile\nsim_success::Vector{Bool}: Status flags indicating successful completion of each job\n\nThrows\n\nArgumentError: If setups is empty\nArgumentError: If setups don't have consistent field names\nArgumentError: If job paths are not unique\nArgumentError: If jobcreator fails to create a valid job\n\nExample\n\n# some function that creates a Job from a parameter setup\nfunction create_job(setup::NamedTuple, root::String)\n    body = Body(BBMaterial(), uniform_box(1.0, 1.0, 1.0, 0.1))\n    material!(body, horizon=0.3, E=setup.E, rho=1000, Gc=100)\n    velocity_ic!(body, :all_points, :x, setup.velocity)\n    solver = VelocityVerlet(steps=1000)\n    # create a unique path for this job based on parameters\n    path = joinpath(root, \"sim_E$(setup.E)_v$(setup.velocity)\")\n    return Job(body, solver; path=path, freq=10)\nend\n\nsetups = [\n    (; E=1e9, velocity=1.0),\n    (; E=2e9, velocity=1.0),\n    (; E=1e9, velocity=2.0),\n]\n\nstudy = Study(create_job, setups; root=\"my_parameter_study\")\n\nSee also: submit!, Job\n\n\n\n\n\n","category":"type"},{"location":"public_api_reference/#Peridynamics.submit","page":"Public API","title":"Peridynamics.submit","text":"submit(job::Job; quiet=false)\n\nRun the simulation by submitting the job.\n\nArguments\n\njob::Job: Job that contains all defined parameters and conditions.\n\nKeywords\n\nquiet::Bool: If true, no outputs are printed in the terminal. (default: false)\n\n\n\n\n\n","category":"function"},{"location":"public_api_reference/#Peridynamics.submit!","page":"Public API","title":"Peridynamics.submit!","text":"submit!(study::Study; kwargs...)\n\nSubmit and execute all simulation jobs in a parameter study. Jobs are run sequentially, and each job can utilize MPI or multithreading as configured. If a job fails, the error is logged and execution continues with the remaining jobs.\n\nThis function creates the study root directory and logfile, then submits each job using submit. All simulation results and individual job logs are stored in their respective job directories, while a central study logfile tracks the overall progress and status of all simulations.\n\nResuming Interrupted Runs\n\nIf the study logfile already exists (from a previous run), submit! will:\n\nRead the logfile and refresh study.sim_success to detect previously completed jobs\nSkip jobs that already completed successfully (marked with \"skipped\" in the logfile)\nOnly execute jobs that failed or were not yet started\nAppend a \"RESUMED\" marker with timestamp to the logfile\n\nThis allows you to safely resume a study after an interruption (crash, timeout, manual stop) without re-running successful simulations. Simply call submit!(study) again with the same study configuration.\n\nArguments\n\nstudy::Study: The study containing all jobs to execute\n\nKeywords\n\nquiet::Bool: If true, suppress terminal output for individual jobs (default: false)\nAdditional keywords are passed to submit for each job\n\nBehavior\n\nJobs execute sequentially (one after another)\nEach job inherits MPI/threading configuration from the Julia session\nFailed jobs don't stop execution of remaining jobs\nstudy.sim_success is updated with the status of each job\nA study logfile is created at study.logfile with:\nStudy header with timestamp\nParameters and status for each simulation\nExecution time for successful jobs\nIndividual job logs are written to their respective directories\n\nExample\n\nstudy = Study(create_job, setups; root=\"my_study\")\nsubmit!(study; quiet=true)\n\n# If the process was interrupted, simply call submit! again to resume:\n# It will skip completed jobs and only run remaining ones\nstudy = Study(create_job, setups; root=\"my_study\")  # Reads existing logfile\nsubmit!(study; quiet=true)  # Resumes from where it left off\n\n# Check which simulations succeeded\nsuccessful_indices = findall(study.sim_success)\nprintln(\"Successful simulations: \", successful_indices)\n\n# Read the study logfile\nlogcontent = read(study.logfile, String)\n\nSee also: Study, submit\n\n\n\n\n\n","category":"function"},{"location":"public_api_reference/#Peridynamics.VtkReader.read_vtk","page":"Public API","title":"Peridynamics.VtkReader.read_vtk","text":"read_vtk(file::AbstractString)\n\nRead vtu or pvtu file containing simulation results of a time step.\n\nArguments\n\nfile::String: Path to VTK file in vtu or pvtu format.\n\nReturns\n\nDict{String, VecOrMat{Float64}}: Simulation results as a dictionary.\n\nExamples\n\njulia> read_vtk(\"results/fragmenting_cylinder/vtk/timestep_000520.pvtu\")\nDict{Symbol, VecOrMat{Float64}} with 4 entries:\n  :position     => [0.0263309 0.027315 … 0.0293543 0.030339; 0.000292969 0.000294475…\n  :displacement => [0.00583334 0.00581883 … 0.00585909 0.00584271; -0.000162852 -0.0…\n  :damage       => [0.616071, 0.569343, 0.528571, 0.463415, 0.438776, 0.553571, 0.56…\n  :time         => [9.69363e-5]\n\n\n\n\n\n","category":"function"},{"location":"public_api_reference/#Peridynamics.process_each_export","page":"Public API","title":"Peridynamics.process_each_export","text":"process_each_export(f, vtk_path, default_value=nothing; kwargs...)\nprocess_each_export(f, job, default_value=nothing; kwargs...)\n\nA function for postprocessing every exported file. This function works with multithreading and MPI and determines the backend exactly like the submit function.\n\nArguments\n\nf::Function: The processing function with signature f(r0, r, id) that returns a result   to be collected (when default_value !== nothing) or returns nothing (legacy mode).\nr0: The results of read_vtk for the exported file of the reference   results.\nr: The results of read_vtk for a time step.\nid::Int: An ID indicating the number of the exported file (counted from 1, starting   with the reference file).\nvtk_path::AbstractString: A path that should contain the export results of a simulation.\njob::Job: A job object. The path of the VTK files will then be processed from the   job options.\ndefault_value: Optional default value for result collection. When provided (not nothing),   the function returns a vector of results from processing each export file. The type of   default_value determines the element type of the returned vector. For MPI compatibility,   the returned result type must satisfy isbitstype(result) == true.   When default_value === nothing (default), the function returns nothing and behaves   like the original version without result collection.\n\nKeywords\n\nserial::Bool: If true, all results will be processed in the correct order of the time   steps and on a single thread, cf. the MPI root rank. (default: false)\nbarrier::Bool: If true and serial=true, adds an MPI barrier after processing   completes, ensuring all ranks wait for the root rank to finish. This is ignored when   serial=false (parallel processing has automatic coordination) or when only_root=true.   Use this when you need all ranks to synchronize after root-only file processing.   (default: false)\nonly_root::Bool: If true, processing runs only on the root rank and results are NOT   broadcast to other ranks. This prevents MPI deadlocks when calling process_each_export   inside process_each_job with only_root=true. Non-root ranks return nothing.   When false, results are broadcast to all ranks (if result collection is enabled).   (default: false)\n\nReturns\n\nnothing when default_value === nothing (legacy mode)\nVector{T} where T = typeof(default_value) when result collection is enabled. Each   element corresponds to the result from processing one export file. With MPI, all ranks   receive the complete vector with results from all files.\n\nMPI Behavior\n\nWhen running with MPI:\n\nserial=true, barrier=false, only_root=false: Processing runs only on root rank. Results   are broadcast to all ranks. Non-root ranks wait for broadcast but don't process files.\nserial=true, barrier=true, only_root=false: Processing runs on root rank, results are   broadcast to all ranks, then all ranks wait at a barrier.\nonly_root=true: Processing runs only on root rank. Results are NOT broadcast - non-root   ranks return nothing immediately. Use this to avoid MPI deadlocks when calling   process_each_export inside process_each_job(...; only_root=true). The barrier   parameter is ignored.\nserial=false: Processing is distributed across all MPI ranks with automatic coordination.   Each rank processes a subset of files. The barrier and only_root parameters are   ignored.\nWith result collection enabled and only_root=false, results are gathered/broadcast so   all ranks receive the complete results vector. With only_root=true, only the root rank   gets results.\n\nwarning: MPI result type requirements\nWhen using result collection with MPI (default_value !== nothing), the returned result type must be a bits type (isbitstype(result) == true). This typically means primitive types or NamedTuples of primitive types. Non-bits types like strings or arrays will cause an error.\n\nExamples\n\n# Legacy mode - no result collection\nprocess_each_export(job; serial=true, barrier=true) do r0, r, id\n    # File operations on root\n    open(\"result_$id.txt\", \"w\") do io\n        write(io, string(maximum(r[:displacement])))\n    end\nend\n\n# Result collection mode\ndefault_value = (; max_disp=NaN, avg_ux=NaN)\nresults = process_each_export(job, default_value) do r0, r, id\n    max_disp = maximum(r[:displacement])\n    ux = @view r[:displacement][1, :]\n    avg_ux = sum(ux) / length(ux)\n    return (; max_disp, avg_ux)\nend\n# results is a Vector{NamedTuple{(:max_disp, :avg_ux), Tuple{Float64, Float64}}}\n\n# With MPI, all ranks get the complete results\n@mpiroot println(\"Results from all files: \", results)\n\n# Using inside process_each_job to avoid deadlocks\nprocess_each_job(jobs; only_root=true) do job, job_id\n    submit(job)\n    # Use only_root=true here to prevent MPI deadlock\n    results = process_each_export(job, default_value; only_root=true) do r0, r, id\n        # Process export files...\n        return (; max_disp=maximum(r[:displacement]))\n    end\n    # Only root rank has results here, non-root ranks get nothing\n    return results\nend\n\nSee also: process_each_job, mpi_isroot, mpi_barrier\n\n\n\n\n\n","category":"function"},{"location":"public_api_reference/#Peridynamics.process_each_job","page":"Public API","title":"Peridynamics.process_each_job","text":"process_each_job(f::Function, study::Study, default_result::NamedTuple)\n\nApply a processing function to each successfully completed job in a parameter study. This function iterates through all jobs in the study and applies the user-defined processing function f to jobs that completed successfully. Failed jobs or jobs where the processing function errors will use the default_result instead.\n\nBefore processing, this function automatically refreshes study.sim_success from the logfile if it exists. This ensures that jobs completed in a previous interrupted run are properly detected and processed, even if the current Julia session doesn't reflect their completion status yet.\n\nArguments\n\nf::Function: A processing function with signature f(job::Job, setup::NamedTuple)   that returns a NamedTuple containing the processed results. The function receives:\njob: The Job object for the simulation\nsetup: The parameter configuration NamedTuple for this job\nstudy::Study: The study containing the jobs to process\ndefault_result::NamedTuple: The default result to use when a job failed or when   the processing function throws an error\n\nKeywords\n\nonly_root::Bool: If true, the processing function f runs only on the MPI root rank.   Non-root ranks will use default_result for all jobs. This is useful when processing   involves file I/O or expensive computations that should not be duplicated across ranks.   Note that the returned results vector will contain meaningful data only on the root rank   unless you manually broadcast results afterward. (default: false)\n\nReturns\n\nVector{<:NamedTuple}: A vector of results with the same length as the number of   jobs in the study. Each element is either the result from applying f or the   default_result for failed/errored cases.\n\nBehavior\n\nRefreshes job completion status from logfile (if exists) before processing\nOnly processes jobs where study.sim_success[i] == true\nFailed jobs automatically receive default_result (warning logged)\nIf processing function f throws an error, that job receives default_result (error   logged with MPI barrier synchronization)\nProcessing is sequential (one job at a time)\nAll jobs in the study will have a corresponding entry in the results vector\n\nMPI Behavior\n\nBy default (only_root=false), the processing function f is called on all MPI ranks\nWith only_root=true, f runs only on root rank; non-root ranks use default_result\nError handling includes automatic MPI barrier synchronization across all ranks\n\ndanger: Using `process_each_job` inside `@mpiroot` calls\nWhen calling process_each_job inside an @mpiroot block or any context where only the root process executes the code, you must use only_root=true. Otherwise, if an error occurs during processing, a deadlock will happen because the error handling attempts an MPI barrier, but non-root ranks are not participating in the process_each_job call at all.# Correct: Use only_root=true when inside @mpiroot\n@mpiroot :wait begin\n    results = process_each_job(study, default; only_root=true) do job, setup\n        # ... processing code\n    end\nend\n\n# Incorrect: This will deadlock on errors\n@mpiroot :wait begin\n    results = process_each_job(study, default) do job, setup  # Missing only_root=true\n        # ... processing code\n    end\nend\n\ndanger: Using `only_root=true` with nested `process_each_export` calls\nWhen using only_root=true in process_each_job, you have two safe options for nested process_each_export calls:Option 1 (Recommended): Always use only_root=true in nested process_each_export calls. This is the safest and most straightforward approach.results = process_each_job(study, default; only_root=true) do job, setup\n    # Safe: use only_root=true in nested calls\n    res = process_each_export(job, default_value; only_root=true) do r0, r, id\n        # ... process files and return results\n    end\nendOption 2 (Advanced): Use process_each_export without result collection (default_value=nothing, the default) AND without barrier=true. This works because non-root ranks skip immediately without waiting for broadcasts or barriers.results = process_each_job(study, default; only_root=true) do job, setup\n    # Safe: no result collection, no barrier\n    process_each_export(job) do r0, r, id  # returns nothing\n        # ... do file I/O only\n    end\nendWhat causes deadlocks:Using result collection in process_each_export without only_root=true → non-root ranks wait for broadcasts that never happen\nUsing barrier=true → root rank waits at a barrier that non-root ranks never reachAdditionally, ensure that the processing function f does not contain any other MPI calls or operations that require synchronization across ranks, as only the root process will execute it.\n\nExamples\n\n# After running a parameter study (possibly interrupted and resumed)\nstudy = Study(create_job, setups; root=\"my_study\")\n# Status is automatically refreshed from logfile in constructor\n\n# Define a function to extract maximum displacement from results\ndefault = (; E=0.0, velocity=0.0, max_displacement=NaN)\n\n# IMPORTANT: Must use only_root=true in both process_each_job AND process_each_export!\nresults = process_each_job(study, default; only_root=true) do job, setup\n    # CRITICAL: only_root=true is required here to avoid MPI deadlock\n    max_disps = process_each_export(job, 0.0; only_root=true) do r0, r, id\n        return maximum(r[:displacement])\n    end\n    max_u = maximum(max_disps)\n    return (; E=setup.E, velocity=setup.velocity, max_displacement=max_u)\nend\n\n# Filter successful results (only root rank will have meaningful data)\nif mpi_isroot()\n    successful_results = [r for r in results if !isnan(r.max_displacement)]\nend\n\nSee also: Study, submit!, process_each_export, mpi_isroot\n\n\n\n\n\n","category":"function"},{"location":"generated/tutorial_brazilian_test/#tutorial_brazilian_test","page":"Brazilian Test","title":"Brazilian Test","text":"This tutorial sets up the Brazilian Test experiment, commonly used to investigate fracture of brittle materials like ultra-high performance concrete. Therefore a cylindrical specimen is loaded by two opposing forces applying pressure on the cross section of the specimen.\n\nTo start, we import the package.\n\nusing Peridynamics\n\nThen we define the geometrical parameters of the specimen which are the diameter Ø and the length l as well as the point spacing Δx of the model. The parameter b is used later defining point sets for the boundary conditions.\n\nØ = 0.05 # [m]\nl = 0.015 # [m]\nΔx = Ø/61 # [m]\nb = 0.017 # [m]\n\nWith the diameter, length and point spacing, we create the cylindrical body. The peridynamics model we employ is a bond-based model applying the energy based surface correction method of Le and Bobaru [LB18].\n\npos, vol = uniform_cylinder(Ø, l, Δx)\ncyl = Body(BBMaterial{EnergySurfaceCorrection}(), pos, vol)\n\nThe horizon is specified in relation to the point spacing.\n\nδ = 3.015Δx\n\nThen the material parameters are set.\n\nmaterial!(cyl; horizon=δ, E=50e9, rho=2400, Gc=140)\n\nTo apply the opposing forces, two point sets are generated.\n\npoint_set!(p -> p[1] ≥ Ø/2-3Δx && abs(p[2]) ≤ 1.1*b/2, cyl, :set_1)\npoint_set!(p -> p[1] ≤ -Ø/2+3Δx && abs(p[2]) ≤ 1.1*b/2, cyl, :set_2)\n\nThe functions for the velocity boundary conditions, that have the same value but act in different directions, are defined next.\n\nv_set1(p, t) = - 2 * exp(-t/0.00002) * (-1/0.02^2 * p[2]^2 + 1)\nv_set2(p, t) =  2 * exp(-t/0.00002) * (-1/0.02^2 * p[2]^2 + 1)\n\nThen these functions are set as the boundary conditions in x-direction, while the velocites of the points in y- and z-direction are 0.\n\nvelocity_bc!(v_set1, cyl, :set_1, :x)\nvelocity_bc!(t -> 0, cyl, :set_1, :y)\nvelocity_bc!(t -> 0, cyl, :set_1, :z)\nvelocity_bc!(v_set2, cyl, :set_2, :x)\nvelocity_bc!(t -> 0, cyl, :set_2, :y)\nvelocity_bc!(t -> 0, cyl, :set_2, :z)\n\nThe Velocity Verlet algotihm is employed as time integration method where 6000 time steps are calculated.\n\nvv = VelocityVerlet(steps=6000)\n\nFinally the job is defined and submitted.\n\njob = Job(cyl, vv; path=\"results/brazilian_bb_uniform\")\nsubmit(job)\n\n    <video controls loop=\"true\">\n        <source src=\"https://github.com/user-attachments/assets/dea25e90-34e1-4faf-9241-a5161a741c68\" />\n    </video>","category":"section"},{"location":"expl_continuumbased/#expl_cki","page":"Continuum-kinematics-inspired peridynamics","title":"Continuum-kinematics-inspired peridynamics","text":"Continuum-kinematics-inspired peridynamics (CPD) is a formulation that is supposed to deliver more freedom in specifying material parameters. The internal force density is calculated as the sum of three types of point interactions which are one-, two- and three-neighbor interactions [JMS19]:\n\nboldsymbolb^mathrminti = boldsymbolb_1^mathrminti + boldsymbolb_2^mathrminti + boldsymbolb_3^mathrminti  \n\nSize Symbol Unit\nInternal force density boldsymbolb^mathrminti leftfracmathrmkgmathrmm^2mathrms^2right\nForce density shares due to one-, two- & three-neighbor interactions boldsymbolb_1^mathrminti , boldsymbolb_2^mathrminti , boldsymbolb_3^mathrminti leftfracmathrmkgmathrmm^2mathrms^2right","category":"section"},{"location":"expl_continuumbased/#One-neighbor-interactions","page":"Continuum-kinematics-inspired peridynamics","title":"One-neighbor interactions","text":"<img src=\"https://github.com/kaipartmann/Peridynamics.jl/assets/68582683/0380b1b8-4527-4f38-a20e-435a6f1c8ba1\" width=\"250\"/>\n\nOne-neighbor interactions in CPD correspond to the bonds in bond-based peridynamics, but there is a slightly different way to calculate the internal forces.\n\nFirst, the neighborhood volume is determined:\n\nV_mathcalH^i = beta^i  frac 4 3  pi  delta^3  \n\nHere beta^iin 01 is a factor for the completeness of the neighborhood that takes incomplete point families at the surface into account (see figure 1).\n\n<img src=\"https://github.com/kaipartmann/Peridynamics.jl/assets/68582683/b899c8d3-e358-4d4d-b52f-13b6c0af747b\" width=\"350\"/>\n\nNow, the effective one-neighbor volume can be calculated\n\nV_1^i = fracV_mathcalH^iN_1^i\n\nwith the number of interactions N_1^i.\n\nThe internal force density is determined by\n\n    boldsymbolb_1^mathrminti = int_mathcalH_1^i C_1 left( fracl^ijL^ij - 1 right) fracboldsymbolDelta x^ijl^ij  mathrmd V_1^i\n\nwith the parameters:\n\nSize Symbol Unit\nNeighborhood volume V_mathcalH^i mathrmm^3\nNeighborhood completeness beta^iin 01 -\nEffective one-neighbor volume V_1^i mathrmm^3\nNumber of one-neighbor interactions N_1^i -\nMaterial constant C_1 fracmathrmkgmathrmm^5mathrms^2\nRelative length measures L^ij, l^ij mathrmm","category":"section"},{"location":"expl_continuumbased/#Two-neighbor-interactions","page":"Continuum-kinematics-inspired peridynamics","title":"Two-neighbor interactions","text":"<img src=\"https://github.com/kaipartmann/Peridynamics.jl/assets/68582683/5b340634-7c3f-4ddf-a056-06c31564077c\" width=\"250\"/>\n\nFor two-neighbor interactions, the deformation of the area spanned by point i and two of its neighbors j and k is analyzed to calculate the internal force density. For this, relative area measures are defined:\n\n    A^ijk=left boldsymbolDelta X^ij times boldsymbolDelta X^ik right   qquad a^ijk=left boldsymbolDelta x^ij times boldsymbolDelta x^ik right   qquad boldsymbola^ijk= boldsymbolDelta x^ij times boldsymbolDelta x^ik  \n\nOther sizes needed to identify the force density are the material constant C_2 and the effective two-neighbor volume\n\n    V_2^i = fracleft(V_mathcalH^iright)^2N_2^i\n\nwith the number of interactions N_2. \n\nThe internal force density induced by two-neighbor interactions is \n\n    boldsymbolb_2^mathrmint  i = \n2  C_2 int_mathcalH_2^i left( fraca^ijkA^ijk - 1 right)\nfracboldsymbolDelta x^ik times boldsymbola^ijka^ijk  mathrmd V_2^i  \n\nSize Symbol Unit\nRelative area measures A^ijk, a^ijk, boldsymbola^ijk mathrmm^2\nEffective two-neighbor volume V_2^i mathrmm^6\nNumber of two-neighbor interactions N_2^i -\nMaterial constant C_2 fracmathrmkgmathrmm^9mathrms^2","category":"section"},{"location":"expl_continuumbased/#Three-neighbor-interactions","page":"Continuum-kinematics-inspired peridynamics","title":"Three-neighbor interactions","text":"<img src=\"https://github.com/kaipartmann/Peridynamics.jl/assets/68582683/e908c804-a6d4-4bf6-b75a-988f33989213\" width=\"250\"/>\n\nThree-neighbor interactions regard the volume defined by the bond vectors between point i and its three neighbors j, k and l:\n\nV^ijkl = left(boldsymbolDelta X^ij times boldsymbolDelta X^ikright) cdot boldsymbolDelta X^il  qquad\n    v^ijkl = left(boldsymbolDelta x^ij times boldsymbolDelta x^ikright) cdot boldsymbolDelta x^il  \n\nAdditionally, the effective three-neighbor volume\n\n    V_3^i = frac left(V_mathcalH^iright)^3N_3^i  \n\nis defined. For the internal force density of three-neighbor interactions, the equation\n\nboldsymbolb_3^mathrmint  i = \n3  C_3 int_mathcalH_3^i left( fracleftv^ijklrightleftV^ijklright - 1 right)\nfracleft(boldsymbolDelta x^ik times boldsymbolDelta x^ilright) v^ijklleftv^ijklright  mathrmd V_3^i\n\nwith the material constant C_3 is used.\n\nSize Symbol Unit\nRelative volume measures V^ijkl, v^ijkl mathrmm^3\nEffective three-neighbor volume V_3^i mathrmm^9\nNumber of three-neighbor interactions N_3^i -\nMaterial constant C_3 fracmathrmkgmathrmm^13mathrms^2","category":"section"},{"location":"generated/tutorial_tension_dynfrac/#tutorial_tension_dynfrac","page":"Tensile test dynamic","title":"Tensile test dynamic","text":"Import the package:\n\nusing Peridynamics\n\nRead and convert the Abaqus FEM mesh of a tensile test into a point cloud for the peridynamic model:\n\n# insert your correct path to the downloaded mesh file!\ninp_file = joinpath(@__DIR__, \"..\", \"assets\", \"TensileTestMesh.inp\");\nnothing #hide\n\n(Image: )\n\nCreate a body with the points from the mesh: (The bond-based material model with energy based surface correction is used here.)\n\nbody = Body(BBMaterial(), inp_file)\n\nThe element sets defined in Abaqus were converted into point sets of the Body:\n\npoint_sets(body)\n\nSpecify the material parameters as:\n\nmaterial parameter value\nHorizon $ δ $ 001  mathrmm\nDensity ρ $ 2700 \\,\\mathrm{kg}\\,\\mathrm{m}^{-3}$\nYoung's modulus E $ 70 \\cdot 10^{9} \\, \\mathrm{Pa}$\nGriffith's parameter G_c 100  mathrmN  mathrmm^-1\n\nmaterial!(body; horizon=0.01, rho=2700, E=70e9, Gc=100)\n\nAs loading condition for the specimen, a constant velocity of 06  mathrmmmathrms^-1 in x-direction is set for the bottom and top.\n\nvelocity_bc!(t -> -0.6, body, :bottom, 1)\nvelocity_bc!(t -> 0.6, body, :top, 1)\n\nSet the number of time steps for the Velocity Verlet algorithm to 500 time steps:\n\nvv = VelocityVerlet(steps=500)\n\nCreate the job:\n\njob = Job(body, vv; path=\"results/tension_dynamic_fracture\")\n\nSubmit the job to start simulations:\n\nsubmit(job)\n\n    <video controls loop=\"true\">\n        <source src=\"https://github.com/user-attachments/assets/332babb0-5c6f-4ae0-89e8-3ae1a7a80177\" />\n    </video>","category":"section"},{"location":"dev_systems/#Systems","page":"Systems","title":"Systems","text":"warning: Draft & Work in Progress\nThis documentation is a draft and work in progress. It will be extended and improved in the future.\n\nSystems are the backbone of the simulations. They contain all the required pre-defined data structures (e.g. bonds, point-families, interactions, ...).","category":"section"},{"location":"dev_systems/#BondSystem","page":"Systems","title":"BondSystem","text":"The standard system for bond-based (BBMaterial), ordinary state-based (OSBMaterial) and non-ordinary state-based correspondence formulation (CMaterial) material models. Used material models have to be subtypes of AbstractBondSystemMaterial or AbstractCorrespondenceMaterial.","category":"section"},{"location":"dev_systems/#InteractionSystem","page":"Systems","title":"InteractionSystem","text":"The system utilizing one-, two- and three-neighbor-interactions for the continuum-kinematics-inspired material model (CKIMaterial). Used material models have to be subtypes of  AbstractInteractionSystemMaterial.","category":"section"},{"location":"dev_systems/#BondAssociatedSystem","page":"Systems","title":"BondAssociatedSystem","text":"A system for the bond-associated correspondence model by Chen and Spencer (BACMaterial). Used material models have to be subtypes of  AbstractBondAssociatedSystemMaterial.","category":"section"},{"location":"dev_systems/#Custom-systems","page":"Systems","title":"Custom systems","text":"Custom systems are relatively free in how they are defined, only these things are required:\n\ndefine an abstract type Abstract<SystemName>Material that all materials using this system have to be a subtype of.\ndefine the get_system(body::AbstractBody{Material}, pd::PointDecomposition, chunk_id::Int) where {Material<:Abstract<SystemName>Material} function.\ndefine the system_type(mat::Abstract<SystemName>Material) function that returns the system type.\ndefine the calc_timestep_point(system::<SystemType>, params::AbstractPointParameters, point_id::Int) function.\ndefine the calc_force_density!(chunk::AbstractBodyChunk{<:<SystemType>}, t, Δt) function.","category":"section"},{"location":"expl_damage/#expl_dmg","page":"Damage in peridynamics formulations","title":"Damage in peridynamics formulations","text":"For damage simulations with peridynamics, some slight extensions to the material formulations need to be made.","category":"section"},{"location":"expl_damage/#Bond-based-formulation","page":"Damage in peridynamics formulations","title":"Bond-based formulation","text":"In bond-based peridynamics, the pairwise force function is expanded by the factor d^ij, which states whether the bond between points i and j is intact (d^ij=1) or damaged (d^ij=0). Therefore the pairwise force function reads\n\n boldsymbolf = d^ij  c  varepsilon^ij  boldsymboln \n\nwith the bond failure quantity d^ij in 01.","category":"section"},{"location":"expl_damage/#State-based-formulation","page":"Damage in peridynamics formulations","title":"State-based formulation","text":"In all state-based peridynamic formulations, damage is introduced by using a failure considering influence function:\n\n omega_d = d^ij  omega\n\nwith the bond failure quantity d^ij in 01.","category":"section"},{"location":"expl_damage/#Continuum-kinematics-inspired-formulation","page":"Damage in peridynamics formulations","title":"Continuum-kinematics-inspired formulation","text":"For continuum-kinematics-inspired peridynamics there are three different bond failure factors, one for each kind of interaction. For one-neighbor interactions it is similar to the failure in the bond-based formulation. Here the internal force density due to one-neighbor interactions is\n\n    boldsymbolb_1^mathrminti = int_mathcalH_1^i d^ij C_1 left( fracl^ijL^ij - 1 right) fracboldsymbolDelta x^ijl^ij  mathrmd V_1^i\n\nwith the bond failure quantity d^ij in 01.\n\nIn two-neighbor interactions a factor describing the failure of the considered area element is included:\n\n    boldsymbolb_2^mathrmint  i = \n2  C_2 int_mathcalH_2^i d^ijk left( fraca^ijkA^ijk - 1 right)\nfracboldsymbolDelta x^ik times boldsymbola^ijka^ijk  mathrmd V_2^i \n\nwith the two-neighbor interaction failure quantity d^ijk in 01.\n\nFor three-neighbor interactions the internal force density eventually reads\n\nboldsymbolb_3^mathrmint  i = \n3  C_3 int_mathcalH_3^i d^ijkl left( fracleftv^ijklrightleftV^ijklright - 1 right)\nfracleft(boldsymbolDelta x^ik times boldsymbolDelta x^ilright) v^ijklleftv^ijklright  mathrmd V_3^i\n\nwith the three-neighbor interaction failure quantity d^ijkl in 01.\n\nSize Symbol Unit\nBond failure quantity d^ij in 01 -\nTwo-neighbor interaction failure quantity d^ijk in 01 -\nThree-neighbor interaction failure quantity d^ijkl in 01 -","category":"section"},{"location":"generated/tutorial_tension_precrack/#tutorial_tension_precrack","page":"Tension with predefined crack","title":"Tension with predefined crack","text":"Import the package:\n\nusing Peridynamics\n\nFirst some geometrical parameters are defined. These are edge length l, point spacing Δx and crack length a. Now a cuboid body with the specified edge lengths and a thickness of one tenth thereof is created using the bond-based material model.\n\nl, Δx, a = 1.0, 1/50, 0.5\npos, vol = uniform_box(l, l, 0.1l, Δx)\nbody = Body(BBMaterial(), pos, vol)\n\n(Image: )\n\nThe following material parameters are set:\n\nmaterial parameter value\nHorizon $ δ $ 3015 cdot Δx\nYoung's modulus E $ 210000 \\, \\mathrm{MPa}$\nDensity ρ $ 8 \\cdot 10^{-6}\\,\\mathrm{kg}\\,\\mathrm{mm}^{-3}$\nGriffith's parameter G_c 27  mathrmN  mathrmmm^-1\n\nδ = 3.015Δx\nmaterial!(body; horizon=δ, E=2.1e5, rho=8e-6, Gc=2.7)\n\nTwo point sets are defined to insert a crack between them:\n\npoint_set!(p -> p[1] ≤ -l/2+a && 0 ≤ p[2] ≤ 2δ, body, :set_a)\npoint_set!(p -> p[1] ≤ -l/2+a && -2δ ≤ p[2] < 0, body, :set_b)\nprecrack!(body, :set_a, :set_b)\n\n(Image: )\n\nTwo more point sets at the top and at the bottom are created, which are used for the velocity boundary condition.\n\npoint_set!(p -> p[2] > l/2-Δx, body, :set_top)\npoint_set!(p -> p[2] < -l/2+Δx, body, :set_bottom)\n\n(Image: )\n\nThe tension is applied by moving the ends of the body apart at a constant speed of pm 50  mathrmmm  mathrms^-1:\n\nvelocity_bc!(t -> -30, body, :set_bottom, :y)\nvelocity_bc!(t -> 30, body, :set_top, :y)\n\nThe Velocity Verlet algorithm is used as time integration method and 2000 time steps are calculated:\n\nvv = VelocityVerlet(steps=2000)\n\nNow the job is defined\n\njob = Job(body, vv; path=\"results/mode_i_tension_precrack\")\n\nFinally the job is submitted to start simulations\n\nsubmit(job)","category":"section"},{"location":"generated/tutorial_tension_precrack/#Damage-results:","page":"Tension with predefined crack","title":"Damage results:","text":"    <video controls loop=\"true\">\n        <source src=\"https://github.com/user-attachments/assets/918aed7b-735d-418f-900c-e0a996db2bab\" />\n    </video>","category":"section"},{"location":"generated/tutorial_kalthoff-winkler_dynfrac/#tutorial_kalthoff-winkler","page":"Kalthoff-Winkler experiment","title":"Kalthoff-Winkler experiment","text":"This tutorial demonstrates how to set up and run the Kalthoff-Winkler experiment using the Peridynamics.jl package. The Kalthoff-Winkler experiment is a classic dynamic fracture experiment involving a pre-notched sample subjected to impact loading.","category":"section"},{"location":"generated/tutorial_kalthoff-winkler_dynfrac/#Introduction","page":"Kalthoff-Winkler experiment","title":"Introduction","text":"The Kalthoff-Winkler experiment is widely used to study fracture mechanics under high strain rates. This setup provides valuable insights into the behavior of materials under dynamic loading conditions, making it an interesting experiment in the field of fracture mechanics.\n\nIn this tutorial, we will simulate the Kalthoff-Winkler experiment using peridynamics without the impactor. To do so, first we would import the package.\n\nusing Peridynamics","category":"section"},{"location":"generated/tutorial_kalthoff-winkler_dynfrac/#Geometrical-Parameters","page":"Kalthoff-Winkler experiment","title":"Geometrical Parameters","text":"Define the sample length l, width w, and thickness t, with point spacing Δx, horizon size $ δ $ and crack length a.\n\nl  = 200.0E-3  # Length of the sample (meters)\nw  = 100.0E-3  # Width of the sample (meters)\nt  =   9.0E-3  # Thickness of the sample (meters)\nΔx =   1.0E-3  # Discretization size (meters)\nδ  =  4.015Δx  # Horizon (meters)\na  =  50.0E-3  # Crack length (meters)\nnothing #hide","category":"section"},{"location":"generated/tutorial_kalthoff-winkler_dynfrac/#Create-the-Body","page":"Kalthoff-Winkler experiment","title":"Create the Body","text":"Create a body with the specified dimensions using the bond-based material model with surface corrections:\n\npos, vol = uniform_box(l, w, t, Δx)\nbody = Body(BBMaterial{EnergySurfaceCorrection}(), pos, vol)","category":"section"},{"location":"generated/tutorial_kalthoff-winkler_dynfrac/#Material-Parameters","page":"Kalthoff-Winkler experiment","title":"Material Parameters","text":"The following material parameters are set:\n\nmaterial parameter value\nHorizon $ δ $ 4015 cdot Δx\nYoung's modulus E $ 191\\cdot 10^{9} \\, \\mathrm{Pa}$\nDensity ρ $ 8000 ,\\mathrm{kg}\\,\\mathrm{m}^{-3}$\nCritical stretch varepsilon_c 001\n\nmaterial!(body; horizon=δ, E=191.0e9, rho=8000.0, epsilon_c=0.015)","category":"section"},{"location":"generated/tutorial_kalthoff-winkler_dynfrac/#Define-Pre-cracks","page":"Kalthoff-Winkler experiment","title":"Define Pre-cracks","text":"Define the point sets to insert a crack at the left side of the domain (-x):\n\npoint_set!(p -> -a / 2 - δ ≤ p[1] ≤ -a / 2 && 0 ≤ p[2] < w / 2, body, :set_crack1_a)\npoint_set!(p -> -a / 2 ≤ p[1] ≤ -a / 2 + δ && 0 ≤ p[2] < w / 2, body, :set_crack1_b)\nprecrack!(body, :set_crack1_a, :set_crack1_b)\n\nDefine the point sets to insert a crack at the right side of the domain (+x):\n\npoint_set!(p -> a / 2 - δ ≤ p[1] ≤ a / 2 && 0 ≤ p[2] < w / 2, body, :set_crack2_a)\npoint_set!(p -> a / 2 ≤ p[1] ≤ a / 2 + δ && 0 ≤ p[2] < w / 2, body, :set_crack2_b)\nprecrack!(body, :set_crack2_a, :set_crack2_b)","category":"section"},{"location":"generated/tutorial_kalthoff-winkler_dynfrac/#Velocity-Boundary-Condition","page":"Kalthoff-Winkler experiment","title":"Velocity Boundary Condition","text":"Apply a velocity boundary condition that is active for 01  mathrmms on the top edge:\n\npoint_set!(p -> -a / 2 < p[1] < a / 2 && p[2] ≥ w / 2 - 4Δx, body, :set_top)\nvelocity_bc!(t -> t < 0.0001 ? -32.0 : NaN, body, :set_top, :y)\n\nA layer of 3 points at the uncracked boundary is not allowed to obtain failure.\n\npoint_set!(y -> y < -w / 2 + 3Δx, body, :no_fail_zone)\nno_failure!(body, :no_fail_zone)","category":"section"},{"location":"generated/tutorial_kalthoff-winkler_dynfrac/#Simulation","page":"Kalthoff-Winkler experiment","title":"Simulation","text":"Use the Velocity Verlet algorithm as the time integration method and calculate 2000 time steps:\n\nvv = VelocityVerlet(time=0.0003, safety_factor=0.8)\n\nDefine the storage path:\n\npath = joinpath(\"results\", \"KW\")\nispath(path) && rm(path; recursive=true)  # Delete existing results if they exist\n\nCreate and submit the job:\n\njob = Job(body, vv; path=path)\n\n@mpitime submit(job)\n\n    <video controls loop=\"true\">\n        <source src=\"https://github.com/user-attachments/assets/49aca8fe-cbe8-4e5a-8a78-02ce4aeb3cae\" />\n    </video>","category":"section"},{"location":"generated/tutorial_kalthoff-winkler_dynfrac/#Conclusion","page":"Kalthoff-Winkler experiment","title":"Conclusion","text":"This tutorial demonstrated how to set up and run the Kalthoff-Winkler experiment using Peridynamics.jl. By simulating this experiment, we can gain insights into the dynamic fracture behavior of materials under high strain rates.","category":"section"},{"location":"expl_osbased/#expl_osb","page":"Ordinary state-based peridynamics","title":"Ordinary state-based peridynamics","text":"The state-based peridynamics formulation considers not only the deformation of the bonds of one material point, but also the states of all neighbors to calculate the internal force density boldsymbolb^mathrminti as\n\nboldsymbolb^mathrminti = boldsymbolb^mathrmint (boldsymbolX^it) = int_mathcalH_i boldsymbolt^i - boldsymbolt^j  mathrmdV^j  \n\nwith the force vector states boldsymbolt^i=boldsymbolt(boldsymbolDelta X^ij t) and boldsymbolt^j=boldsymbolt(-boldsymbolDelta X^ij t), which characterize the state of each bond at time t [SEW+07]. To determine the force vector states, the weighted volume m_i is calculated first as\n\nm_i = m left( boldsymbolX^i right) = int_mathcalH_i omega   boldsymbolDelta X^ij ^2  mathrmd V^j  \n\nHere, omega is the influence function that gives a greater influence to neighbors near the root point. [SEW+07] Then the dilatation theta_i is needed, which is defined with the weighted volume m_i as\n\ntheta_i = theta left( boldsymbolX^i right) = frac3m_i int_mathcalH_i omega   boldsymbolDelta X^ij   left( boldsymbolDelta x^ij-boldsymbolDelta X^ij right) mathrmd V^j  \n\nWith the previously determined variables, the force vector state boldsymbolt^i is defined as \n\nboldsymbolt^i left( boldsymbolDelta X^ij right) = fracK  theta_im_i  omega   boldsymbolDelta X^ij  + frac15  Gm_i  omega  left( boldsymbolDelta x^ij-boldsymbolDelta X^ij - fractheta_i  boldsymbolDelta X^ij3 right)  \n\nwith shear modulus G and bulk modulus K [SEW+07].\n\nSize Symbol Unit\nInternal force density boldsymbolb^mathrminti leftfracmathrmkgmathrmm^2mathrms^2right\nForce vector state $ \\boldsymbol{t}^i $ leftfracmathrmkgmathrmm^5mathrms^2right\nVolume of point j V^j leftmathrmm^3right\nBond in mathcalB_0 boldsymbolDelta X^ij mathrmm\nBond in mathcalB_t boldsymbolDelta x^ij mathrmm\nBond length in mathcalB_0 leftboldsymbolDelta X^ijright mathrmm\nBond length in mathcalB_t leftboldsymbolDelta x^ijright mathrmm\nInfluence function omega -\nWeighted volume $ m_i $ leftmathrmm^5right\nDilatation theta_i -\nShear modulus G leftfracmathrmkgmathrmmmathrms^2right\nBulk modulus K leftfracmathrmkgmathrmmmathrms^2right","category":"section"},{"location":"dev_multithreading_mpi/#Multithreading-and-MPI","page":"Multithreading & MPI","title":"Multithreading & MPI","text":"warning: Draft & Work in Progress\nThis documentation is a draft and work in progress. It will be extended and improved in the future.\n\nMultithreading and MPI are implemented based on a similar approach. The body is split into several chunks, that each have their own process.\n\n<img src=\"https://github.com/user-attachments/assets/86caad93-8a56-495b-822a-ffccc5c43c9e\" width=\"650\"/>\n\nThere are two types of points. Each chunk consists of the local points, which lay inside the specific body chunk, as well as halo points, which lay on the surface of neighboring chunks and interact with local points of the considered chunk, because they lay inside their horizons. \n\nThis means that every point of a body exists locally in the body chunk that it originally lies in. Additionally one or more copies of the point can exist as halo points in other chunks.\n\n<img src=\"https://github.com/user-attachments/assets/79340f51-cb62-42b2-8f1b-fd474f7fe8fb\" width=\"350\"/>\n\nSince there are points that exist in multiple chunks (in one chunk as local points and possibly in one or more chunks as halo points) information has to be exchanged between these copies of specific points.   Two types of exchanges are of importance for both methods:\n\nlocal-to-halo exchange: Data from calculations in the chunk where the point is local is transferred to the halo versions of this point which exist in other chunks.\n\n<img src=\"https://github.com/user-attachments/assets/34434920-a758-438a-a463-a259397f1bba\" width=\"350\"/>\n\nhalo-to-local exchange: Data from calculations of the one or multiple halo versions of a point is transferred to the local version of the point.\n\n<img src=\"https://github.com/user-attachments/assets/6265e5b8-bff5-4aa3-83b7-62a385578f37\" width=\"350\"/>\n\nA body chunk contains all information that is necessary for the simulation:\n\n<img src=\"https://github.com/user-attachments/assets/c2cd75de-065e-4568-abde-e753216f3e85\" width=\"650\"/>","category":"section"},{"location":"dev_multithreading_mpi/#Multithreading","page":"Multithreading & MPI","title":"Multithreading","text":"To manage the body chunks that compose a body in multithreading a ThreadsDataHandler is employed. It combines information about all the body chunks of the system and all halo exchanges between them.\n\n<img src=\"https://github.com/user-attachments/assets/48e61d30-cfd5-424c-bc36-c52485a00dc2\" width=\"250\"/>","category":"section"},{"location":"dev_multithreading_mpi/#MPI","page":"Multithreading & MPI","title":"MPI","text":"For MPI simulations an MPIDataHandler is used for each body chunk, processing its halo exchanges and further MPI-related information.\n\n<img src=\"https://github.com/user-attachments/assets/ab389e50-05f7-4d6e-8b0d-992fb6c79a75\" width=\"250\"/>","category":"section"},{"location":"generated/tutorial_tension_static/#tutorial_tension_static","page":"Tensile test quasi-static","title":"Tensile test quasi-static","text":"Import the package:\n\nusing Peridynamics\n\nRead and convert the Abaqus FEM mesh of a tensile test into a point cloud for the peridynamic model:\n\n# insert your correct path to the downloaded mesh file!\ninp_file = joinpath(@__DIR__, \"..\", \"assets\", \"TensileTestMesh.inp\");\nnothing #hide\n\n(Image: )\n\nCreate a body with the points from the mesh: (The bond-based material model is used here.)\n\nbody = Body(BBMaterial(), inp_file)\n\nThe element sets defined in Abaqus were converted into point sets of the Body:\n\npoint_sets(body)\n\nSpecify the material parameters as:\n\nmaterial parameter value\nHorizon $ δ $ 001  mathrmm\nDensity ρ $ 2700 \\,\\mathrm{kg}\\,\\mathrm{m}^{-3}$\nYoung's modulus E $ 70 \\cdot 10^{9} \\, \\mathrm{Pa}$\nGriffith's parameter G_c 100  mathrmN  mathrmm^-1\n\nmaterial!(body; horizon=0.01, rho=2700, E=70e9, Gc=100)\n\nAs loading condition for the specimen, a constant force density of 1 times 10^9  mathrmNmathrmm^-3 in x-direction is set for the bottom and top.\n\nforcedensity_bc!(t -> -3e11, body, :bottom, 1)\nforcedensity_bc!(t -> 3e11, body, :top, 1)\n\nDo not allow failure in the entire body:\n\nno_failure!(body)\n\nWe set the number of time steps for the dynamic relaxation algorithm to 500 time steps.\n\ndr = DynamicRelaxation(steps=500, damping_factor=0.2)\n\nCreate the job:\n\njob = Job(body, dr; path=\"results/tension_static\")\n\nsubmit(job)\n\n    <video controls loop=\"true\">\n        <source src=\"https://github.com/user-attachments/assets/b6b2ba41-1ed3-497f-b496-44655d4be696\" />\n    </video>","category":"section"},{"location":"generated/tutorial_wave_interface/#Wave-propagation-across-material-interface","page":"Wave propagation across material interface","title":"Wave propagation across material interface","text":"Based on the wave propagation tutorial, this tutorial features a displacement wave crossing a material interface, as investigated in [PDW24]. This means that a bar containing two sections with different material properties is regarded.\n\nFirst import the Peridynamics.jl package:\n\nusing Peridynamics\n\nThen the geometric parameters are set, which are the same as in the wave propagation tutorial. These are the length lx, width and height lyz of the cuboid as well as the number of points in the width npyz, which determines the point spacing Δx.\n\nlx = 0.2\nlyz = 0.002\nnpyz = 4\nΔx = lyz / npyz\n\nWith these parameters we now create a body, here using the non-ordinary state-based correspondence formulation.\n\npos, vol = uniform_box(lx, lyz, lyz, Δx)\nbody = Body(CMaterial(), pos, vol)\n\nThen the material parameters for one half of the body are assigned to the whole body first.\n\nmaterial!(body, horizon=3.015Δx, rho=7850.0, E=210e9, nu=0.25)\n\nNow a point set containing the other half of all points is created.\n\npoint_set!(x -> x < 0, body, :set1)\n\n(Image: ) The parameters for this point set are then overwritten with their new parameters.\n\nmaterial!(body, :set1, horizon=3.015Δx, rho=7850.0, E=105e9, nu=0.25)\n\nExcept for the Young's modulus, these are the same in both sections:\n\nmaterial parameter value\nHorizon $ δ $ 3015 cdot Δx\nDensity ρ $ 7850\\,\\mathrm{kg}\\,\\mathrm{m}^{-3}$\nYoung's modulus E_I $ 105 \\, \\mathrm{GPa}$\nYoung's modulus E_II $ 210 \\, \\mathrm{GPa}$\nPoisson's ratio ν 025\n\nAgain, failure is not allowed in the whole body since no fracture parameters are specified.\n\nTo employ the boundary conditions creating a displacement wave, the point set :left is created:\n\npoint_set!(x -> x < -lx / 2 + 1.2Δx, body, :left)\n\nAs in the wave propagation tutorial, the applied velocity boundary condition is\n\n    v_x (t) =\n    begincases\n        v_mathrmmax cdot sin(2pi cdot fractT) qquad\n         forall  0 leq t leq T \n        0 textelse\n    endcases\n\n(Image: )\n\nT, vmax = 1.0e-5, 2.0\nvelocity_bc!(t -> t < T ? vmax * sin(2π / T * t) : 0.0, body, :left, :x)\n\nThe Velocity Verlet algorithm is used as time integration method and 2000 time steps are calculated:\n\nvv = VelocityVerlet(steps=2000)\n\nFinally the job is defined and submitted.\n\njob = Job(body, vv; path=\"results/xwave_interface\")\nsubmit(job)\n\n    <video controls loop=\"true\">\n        <source src=\"https://github.com/user-attachments/assets/45513e03-fde0-44ad-ac90-ca181d59933c\" />\n    </video>","category":"section"},{"location":"generated/tutorial_logo/#tutorial_logo","page":"The old Peridynamics.jl logo","title":"The old Peridynamics.jl logo","text":"    <video controls loop=\"true\">\n        <source src=\"https://github.com/user-attachments/assets/0761ba02-f69a-4f3a-b5c5-0f219548070f\" />\n    </video>\n\n(Visualization made with ParaView)\n\nThe Julia logo crashing into a plate and braking it into many pieces.\n\nFirst, we have to load the Peridynamics.jl package.\n\nusing Peridynamics","category":"section"},{"location":"generated/tutorial_logo/#Plate","page":"The old Peridynamics.jl logo","title":"Plate","text":"Now we create the plate in the background by specifying the dimensions and the point spacing.\n\nlxy = 0.1\nlz = 0.01\nΔX₀ₚ = lxy / 50\nposₚ, volₚ = uniform_box(lxy, lxy, lz, ΔX₀ₚ)\nplate = Body(BBMaterial{EnergySurfaceCorrection}(), posₚ, volₚ)\n\nThen we define the material properties for the plate.\n\nHorizon delta = 3015 Delta x_p\nDensity rho = 2000mathrmkgmathrmm^-3\nYoungs modulus E = 30 times 10^9  mathrmPa\nGriffith's parameter G_c = 10  mathrmN  mathrmm^-1\n\nmaterial!(plate; horizon=3.015ΔX₀ₚ, E=30e9, rho=2000, Gc=10)","category":"section"},{"location":"generated/tutorial_logo/#Julia-logo-spheres","page":"The old Peridynamics.jl logo","title":"Julia-logo spheres","text":"A spherical body is created, where only the points inside a specified radius are preserved to create the spheres of the logo. These points are then copied three times and moved to the correct position to represent the logo.\n\nØ = 0.03\nΔX₀ₛ = Ø / 20\ncz = Ø / 2 + lz / 2 + 1.1 * ΔX₀ₛ\nr_logo = Ø / 2 + 0.2 * Ø\nsxy, cxy = r_logo * sin(30π / 180), r_logo * cos(30π / 180)\nposₛ₁, volₛ₁ = uniform_sphere(Ø, ΔX₀ₛ; center=(0, r_logo, cz))\nposₛ₂, volₛ₂ = uniform_sphere(Ø, ΔX₀ₛ; center=(cxy, -sxy, cz))\nposₛ₃, volₛ₃ = uniform_sphere(Ø, ΔX₀ₛ; center=(-cxy, -sxy, cz))\nsphere₁ = Body(BBMaterial(), posₛ₁, volₛ₁)\nsphere₂ = Body(BBMaterial(), posₛ₂, volₛ₂)\nsphere₃ = Body(BBMaterial(), posₛ₃, volₛ₃)\n\nMaterial properties for the spheres are specified.\n\nHorizon delta = 3015 Delta x_s\nDensity rho = 7850mathrmkgmathrmm^-3\nYoungs modulus E = 210 times 10^9  mathrmPa\nGriffith's parameter G_c = 1000  mathrmN  mathrmm^-1\n\nAll material points of the spheres have a initial velocity of -20 mathrmm  mathrms^-1 in z-direction.\n\nfor sphere in (sphere₁, sphere₂, sphere₃)\n    material!(sphere; horizon=3.015ΔX₀ₛ, E=210e9, rho=7850, Gc=1000)\n    velocity_ic!(sphere, :all_points, :z, -20)\nend\n\nMultibody Setup? For the contact analysis, all bodies need to be specified in a MultibodySetup.\n\nms = MultibodySetup(:plate => plate, :sphere1 => sphere₁, :sphere2 => sphere₂,\n                    :sphere3 => sphere₃)\n\nContact between the plate and the three spheres needs to be specified.\n\ncontact!(ms, :plate, :sphere1; radius=ΔX₀ₚ)\ncontact!(ms, :plate, :sphere2; radius=ΔX₀ₚ)\ncontact!(ms, :plate, :sphere3; radius=ΔX₀ₚ)\n\nFor this simulation, 3000 time steps with explicit time integration and the Velocity Verlet algorithm are used.\n\nvv = VelocityVerlet(steps=3000)\n\nNow we create a directory for the results and create a Job.\n\njob = Job(ms, vv; path=\"results/logo\")\n\nTo complete everything, the Job is submitted for simulation.\n\nsubmit(job)","category":"section"},{"location":"dev_solvers/#Time-solvers","page":"Time solvers","title":"Time solvers","text":"warning: Draft & Work in Progress\nThis documentation is a draft and work in progress. It will be extended and improved in the future.","category":"section"},{"location":"dev_solvers/#VelocityVerlet","page":"Time solvers","title":"VelocityVerlet","text":"A time integration solver for the Velocity Verlet algorithm used for dynamic simulations.","category":"section"},{"location":"dev_solvers/#DynamicRelaxation","page":"Time solvers","title":"DynamicRelaxation","text":"A time integration solver for the adaptive dynamic relaxation algorithm used for quasi-static simulations.","category":"section"},{"location":"dev_solvers/#Custom-solvers","page":"Time solvers","title":"Custom solvers","text":"To create a custom time solver, the following steps are required:\n\ndefine a type MySolver<:AbstractTimeSolver. It has to be a subtype of the type AbstractTimeSolver.\ndefine the function init_time_solver!(vv::MySolver, dh::AbstractDataHandler).\ndefine the function solve!(dh::AbstractDataHandler, vv::VelocityVerlet, options::AbstractJobOptions).","category":"section"},{"location":"expl_general_pd/#expl_pd_basics","page":"Basics of peridynamics theory","title":"Basics of peridynamics theory","text":"Peridynamics is a nonlocal continuum mechanics formulation, which was introduced by Silling [Sil00]. It has gained increased popularity as an approach for modeling fracture. The deformation of the solid is described by integro-differential equations that are also fulfilled for discontinuities, making it very capable of modeling crack propagation and fragmentation with large displacements. Much peridynamics research has been done in recent years, summarized in various review papers and books [DPL19, JMOO19, MO14].\n\n<img src=\"https://github.com/kaipartmann/Peridynamics.jl/assets/68582683/728da1f0-4750-4ab6-a430-9b206e475577\" width=\"300\"/>\n\nTypically, in peridynamics the continuum is discretized by material points. Points interact only with other points inside of their specified neighborhood or point family mathcalH, which is defined as the set of points inside a sphere with the radius delta, also named the horizon. The interaction of the point boldsymbolX with its neighbor boldsymbolX is called bond and defined as\n\nboldsymbolDelta X = boldsymbolX - boldsymbolX  \n\nThe equation of motion reads\n\nvarrho  boldsymbolddotu(boldsymbolXt) = boldsymbolb^mathrmint(boldsymbolXt) + boldsymbolb^mathrmext(boldsymbolXt)  \n\nwith the mass density varrho, the point acceleration vector boldsymbolddotu, and the point force density vectors boldsymbolb^mathrmint and boldsymbolb^mathrmext. Various material formulations of peridynamics exist for the calculation of the internal force density boldsymbolb^mathrmint, and all of them are based on the nonlocal interactions between material points.\n\nThe general internal force density for state-based peridynamics is defined as\n\nboldsymbolb^mathrmint (boldsymbolXt) = int_mathcalH boldsymbolt - boldsymbolt  mathrmdV  \n\nwith the force vector states boldsymbolt=boldsymbolt(boldsymbolDelta X t) and boldsymbolt=boldsymbolt(-boldsymbolDelta X t). In the first original bond-based formulation of peridynamics, the force vector states boldsymbolt and  boldsymbolt have the same value and opposite direction. This implies intrinsic limitation to only one material parameter and in consequence to restrictions on the Poisson's ratio [SEW+07, TS20]. To overcome these restrictions, state-based peridynamics was established. In the ordinary state-based peridynamics, the deformation states of neighboring points also influence the internal force density [SEW+07]. This leads to force vector states which are still collinear but not of same value anymore.\n\nFurther developments are summarized as non-ordinary state-based peridynamics. A recent development in this regard is continuum-kinematics-inspired peridynamics [JMS19]. Another peridynamic formulation is the local continuum consistent correspondence formulation of non-ordinary state-based peridynamics, where an elastic model from the classical local material theory can be used to calculate the internal force density.","category":"section"},{"location":"expl_bondbased/#expl_bb","page":"Bond-based peridynamics","title":"Bond-based peridynamics","text":"The initial version of peridynamics is the bond-based (BB) formulation. [Sil00]\n\nHere, a pairwise force function boldsymbolf is defined and calculated for each bond of two material points, which depends on the strain of the bond and is aligned in its direction: \n\n boldsymbolf = c  varepsilon^ij  boldsymboln  \n\nHere the micro-modulus constant [SA05]\n\nc = frac18  kappapi  delta^4 \n\nand the strain of the bond [SB05]\n\nvarepsilon^ij = fracl^ij-L^ijL^ij\n\nwith bond lengths L^ij =leftboldsymbolDelta X^ijright and l^ij =leftboldsymbolDelta x^ijright are used.\n\nThe direction vector\n\nboldsymboln = fracboldsymbolDelta x^ijl^ij\n\nis oriented in the direction of the bond. \n\nTo get the resulting body forces, now the force function is integrated over the whole body:\n\nboldsymbolb^mathrminti = boldsymbolb^mathrmint (boldsymbolX ^ i  t) = int_mathcalH_i boldsymbolf  mathrmdV^j  \n\nSize Symbol Unit\nPairwise force function boldsymbolf leftfracmathrmkgmathrmm^5mathrms^2right\nMicro-modulus constant [SA05] c leftfracmathrmkgmathrmm^5mathrms^2right\nBond strain varepsilon^ij -\nBond in mathcalB_0 boldsymbolDelta X^ij mathrmm\nBond in mathcalB_t boldsymbolDelta x^ij mathrmm\nBond length in mathcalB_0 L^ij mathrmm\nBond length in mathcalB_t l^ij mathrmm\nDirection vector boldsymboln -\nVolume of point j V^j leftmathrmm^3right\nInternal force density boldsymbolb^mathrminti leftfracmathrmkgmathrmm^2mathrms^2right","category":"section"},{"location":"howto_mpi/#Simulations-with-MPI","page":"Simulations with MPI","title":"Simulations with MPI","text":"The package is designed so that the same core functions are used and only a small backend handles the differences between MPI or multithreading. This means, the development goal was:\n\nCode that runs with multithreading should also work with MPI without changes!\n\nHowever, currently not all features are supported with MPI. A table with an overview is shown below.","category":"section"},{"location":"howto_mpi/#Currently-supported-features:","page":"Simulations with MPI","title":"Currently supported features:","text":"Job type MPI\nJob(::Body, ::VelocityVerlet) ✅\nJob(::Body, ::DynamicRelaxation) ✅\nJob(::MultibodySetup, ::VelocityVerlet) ❌","category":"section"},{"location":"howto_mpi/#Setting-up-simulations-for-MPI","page":"Simulations with MPI","title":"Setting up simulations for MPI","text":"If a script containing a simulation runs with multithreading and the features are supported with MPI, then this same script can be run with:\n\nmpiexecjl -n <number of ranks> julia --project path/to/script.jl\n\nPlease refer to the MPI.jl documentation of mpiexecjl for installation and setup instructions.\n\nFurthermore, there are helper functions that improve the setup of MPI simulations, such as enable_mpi_timers!, @mpiroot, @mpitime, mpi_isroot, and mpi_barrier.","category":"section"},{"location":"generated/tutorial_cylinder/#tutorial_cylinder","page":"Fragmenting Cylinder","title":"Fragmenting Cylinder","text":"A cylinder fragmenting into many pieces, inspired by the  peridigm example.\n\nWe use the point cloud created by peridigm for their corresponding example. You can download the file containing the data from this page on their repository.\n\nTo start, import the package:\n\nusing Peridynamics\n\nFirst a function is written that can read our .txt-file containing the data of the point cloud and convert it into the position and volume, which we need to define our Body. For this we need the package DelimitedFiles.jl.\n\nusing DelimitedFiles\nfunction fragmenting_cylinder_geometry(input_mesh_file::AbstractString)\n    input_raw = readdlm(input_mesh_file)\n    position = copy(input_raw[:, 1:3]')\n    volume = copy(input_raw[:, 5])\n    return position, volume\nend\n\nNow we specify the storage path of the file.\n\ninput_mesh_file = joinpath(@__DIR__, \"..\", \"assets\", \"fragmenting_cylinder.txt\")\n\nTo get the information we need, we use our function defined above.\n\nposition, volume = fragmenting_cylinder_geometry(input_mesh_file)\n\nUsing this data, we can create a Body which represents the cylinder.\n\nbody = Body(BBMaterial(), position, volume)\n\nWe specify the material parameters of the cylinder.\n\nmaterial!(body, horizon=0.00417462, rho=7800, E=195e9, epsilon_c=0.02)\n\nThen some initial velocity conditions in x-, y- and z-direction are employed to provoke the fracture of the cylinder.\n\nvelocity_ic!(p -> (200-50*((p[3]/0.05)-1)^2)*cos(atan(p[2],p[1])), body, :all_points, :x)\nvelocity_ic!(p -> (200-50*((p[3]/0.05)-1)^2)*sin(atan(p[2],p[1])), body, :all_points, :y)\nvelocity_ic!(p -> 100*((p[3]/0.05)-1), body, :all_points, :z)\n\nWe employ the Velocity Verlet algorithm for a total time span of 2.5e-4 seconds.\n\nvv = VelocityVerlet(time=2.5e-4)\n\nFinally the job is created\n\njob = Job(body, vv; path=\"results/fragmenting_cylinder\", freq=10)\n\nand subsequently submitted.\n\nsubmit(job)\n\n    <video controls loop=\"true\">\n        <source src=\"https://github.com/user-attachments/assets/91a274dc-7e45-4a21-9283-414b86199e48\" />\n    </video>","category":"section"},{"location":"","page":"Home","title":"Home","text":"<p align=\"center\">\n  <img src=\"assets/logo.png\" width=\"300\" />\n  <br>\n  <picture>\n    <source media=\"(prefers-color-scheme: dark)\" srcset=\"https://github.com/kaipartmann/Peridynamics.jl/assets/68582683/817c7bd4-9c02-4cc4-ac66-998c0f5e95e2\">\n    <source media=\"(prefers-color-scheme: light)\" srcset=\"https://github.com/kaipartmann/Peridynamics.jl/assets/68582683/70c24007-5aa9-460f-9a97-c67b1df32750\">\n    <img alt=\"The Peridynamics.jl logo\" src=\"https://github.com/kaipartmann/Peridynamics.jl/assets/68582683/70c24007-5aa9-460f-9a97-c67b1df32750\" width=\"400\">\n  </picture>\n</p>\n\nA high-level Julia package for parallel peridynamics simulations","category":"section"},{"location":"#Installation","page":"Home","title":"Installation","text":"To install Peridynamics.jl, follow these steps:\n\nInstall Julia from the official Julia website if you haven't already.\nLaunch Julia and open the Julia REPL.\nEnter the package manager by pressing ] in the REPL.\nIn the package manager, type:\nadd Peridynamics\nPress Backspace or Ctrl + C to exit the package manager.","category":"section"},{"location":"#How-to-guides","page":"Home","title":"How-to guides","text":"Simulations with MPI\nVisualize results with ParaView","category":"section"},{"location":"#Tutorials","page":"Home","title":"Tutorials","text":"<div class=\"tutorial-grid\">\n\n<div class=\"tutorial-element\">\n   <a href=\"https://kaipartmann.github.io/Peridynamics.jl/stable/generated/tutorial_tension_static/\">\n      <figcaption>Tensile test quasi-static</figcaption><br><img src=\"https://github.com/kaipartmann/Peridynamics.jl/assets/68582683/ac69d8aa-526d-436a-aa0c-820a1f42bcca\" style=\"width: 90% !important;\"/>\n   </a>\n</div>\n\n<div class=\"tutorial-element\">\n   <a href=\"https://kaipartmann.github.io/Peridynamics.jl/stable/generated/tutorial_tension_dynfrac/\">\n      <figcaption>Tensile test dynamic</figcaption><br><img src=\"https://github.com/kaipartmann/Peridynamics.jl/assets/68582683/dda2b7b3-d44b-41a9-b133-6d1b548df1c1\" style=\"width: 90% !important;\"/>\n   </a>\n</div>\n\n<div class=\"tutorial-element\">\n   <a href=\"https://kaipartmann.github.io/Peridynamics.jl/stable/generated/tutorial_tension_precrack/\">\n      <figcaption>Tension with predefined crack</figcaption><br><img src=\"https://github.com/kaipartmann/Peridynamics.jl/assets/68582683/9f627d2d-44b5-43a3-94cd-9d34894fd142\" style=\"width: 90% !important;\"/>\n   </a>\n</div>\n\n<div class=\"tutorial-element\">\n   <a href=\"https://kaipartmann.github.io/Peridynamics.jl/stable/generated/tutorial_logo/\">\n      <figcaption>The old logo</figcaption><br><img src=\"https://github.com/kaipartmann/Peridynamics.jl/assets/68582683/5439e112-9088-49a3-bb01-aff541adc0f8\" style=\"width: 90% !important;\"/>\n   </a>\n</div>\n\n<div class=\"tutorial-element\">\n   <a href=\"https://kaipartmann.github.io/Peridynamics.jl/stable/generated/tutorial_kalthoff-winkler_dynfrac/\">\n      <figcaption>Kalthoff Winkler</figcaption><br><img src=\"https://github.com/kaipartmann/Peridynamics.jl/assets/68582683/6dc362ef-4997-4327-9bc1-41350fac2dc1\" style=\"width: 90% !important;\"/>\n   </a>\n</div>\n\n<div class=\"tutorial-element\">\n   <a href=\"https://kaipartmann.github.io/Peridynamics.jl/stable/generated/tutorial_cylinder/\">\n      <figcaption>Fragmenting cylinder</figcaption><br><img src=\"https://github.com/user-attachments/assets/58e11123-6143-4e13-8642-7e30c9e6c86d\" style=\"width: 90% !important;\"/>\n   </a>\n</div>\n\n<div class=\"tutorial-element\">\n   <a href=\"https://kaipartmann.github.io/Peridynamics.jl/stable/generated/tutorial_wave_in_bar/\">\n      <figcaption>Wave propagation</figcaption><br><img src=\"https://github.com/user-attachments/assets/7fa65fd4-38d8-46cb-833f-990417211d17\" style=\"width: 90% !important;\"/>\n   </a>\n</div>\n\n<div class=\"tutorial-element\">\n   <a href=\"https://kaipartmann.github.io/Peridynamics.jl/stable/generated/tutorial_wave_interface/\">\n      <figcaption>Wave propagation across interface</figcaption><br><img src=\"https://github.com/user-attachments/assets/082f635f-caf2-40db-938e-e4a98e2f3915\" style=\"width: 90% !important;\"/>\n   </a>\n</div>\n\n<div class=\"tutorial-element\">\n   <a href=\"https://kaipartmann.github.io/Peridynamics.jl/stable/generated/tutorial_brazilian_test/\">\n      <figcaption>Brazilian test</figcaption><br><img src=\"https://github.com/user-attachments/assets/2f78a983-98d5-42eb-bc32-4fb270238ceb\" style=\"width: 90% !important;\"/>\n   </a>\n</div>\n\n</div>","category":"section"},{"location":"#Authors","page":"Home","title":"Authors","text":"<ul>\n<li><a href=\"https://orcid.org/0000-0002-5238-4355\">Kai Partmann (University of Siegen) <img alt=\"ORCID logo\" src=\"https://info.orcid.org/wp-content/uploads/2019/11/orcid_16x16.png\" width=\"16\" height=\"16\" /></a></li>\n<li><a href=\"https://orcid.org/0009-0004-9195-0112\">Manuel Dienst (University of Siegen) <img alt=\"ORCID logo\" src=\"https://info.orcid.org/wp-content/uploads/2019/11/orcid_16x16.png\" width=\"16\" height=\"16\" /></a></li>\n<li><a href=\"https://orcid.org/0000-0002-2213-8401\">Kerstin Weinberg (University of Siegen) <img alt=\"ORCID logo\" src=\"https://info.orcid.org/wp-content/uploads/2019/11/orcid_16x16.png\" width=\"16\" height=\"16\" /></a></li>\n</ul>","category":"section"},{"location":"#Acknowledgements","page":"Home","title":"Acknowledgements","text":"<img src=https://github.com/kaipartmann/Peridynamics.jl/assets/68582683/0d14a65b-4e05-4408-8107-59ac9c1477d2 width=500>\n\nThe authors gratefully acknowledge the support of the Deutsche Forschungsgemeinschaft (DFG) under the project WE2525-14/1.\n\nThe support of Carsten Bauer and Xin Wu from PC2 with the design of the internal structure regarding parallel performance is gratefully acknowledged.\n\nThe authors gratefully acknowledge the computing time provided to them on the high-performance computer Noctua 2 at the NHR Center PC2. These are funded by the Federal Ministry of Education and Research and the state governments participating on the basis of the resolutions of the GWK for the national highperformance computing at universities (www.nhr-verein.de/unsere-partner).","category":"section"},{"location":"generated/tutorial_wave_in_bar/#tut_wave","page":"Wave propagation in a thin bar","title":"Wave propagation in a thin bar","text":"In this tutorial, a cuboid bar is created. A velocity pulse in the form of one period of a sine wave is applied to create a displacement wave that propagates through the bar. The behaviour of this wave was investigated in [PDW24].\n\nFirst import the Peridynamics.jl package:\n\nusing Peridynamics\n\nTo get started, some parameters used for this simulation are defined. These are the length of the bar lx, the width and height lyz and the number of points in the width npyz.\n\nlx = 0.2\nlyz = 0.002\nnpyz = 4\n\nWith these parameters the point spacing Δx can be calculated:\n\nΔx = lyz / npyz\n\nA cuboid body according to the ordinary state-based model with the specified dimensions and point spacing is then created:\n\npos, vol = uniform_box(lx, lyz, lyz, Δx)\nbody = Body(OSBMaterial(), pos, vol)\n\nFollowing material parameters are specified:\n\nmaterial parameter value\nHorizon $ δ $ 3015 cdot Δx\nDensity ρ $ 7850\\,\\mathrm{kg}\\,\\mathrm{m}^{-3}$\nYoung's modulus E $ 210 \\, \\mathrm{GPa}$\nPoisson's ratio ν 025\n\nmaterial!(body, horizon=3.015Δx, rho=7850.0, E=210e9, nu=0.25)\n\nFailure is prohibited throughout the body since no fracture parameters are defined. Point set :left including the first row of points in x-direction is created:\n\npoint_set!(x -> x < -lx / 2 + 1.2Δx, body, :left)\n\nThe velocity boundary condition of the form\n\n    v_x (t) =\n    begincases\n        v_mathrmmax cdot sin(2pi cdot fractT) qquad\n         forall  0 leq t leq T \n        0 textelse\n    endcases\n\n(Image: ) is applied to point set :left. The parameters used for this excitation are period length T and amplitude vmax.\n\nT, vmax = 1.0e-5, 2.0\nvelocity_bc!(t -> t < T ? vmax * sin(2π / T * t) : 0.0, body, :left, :x)\n\nThe Velocity Verlet algorithm is used as time integration method and 2000 time steps are calculated:\n\nvv = VelocityVerlet(steps=2000)\n\nThe job is now defined with the specified settings and parameters.\n\njob = Job(body, vv; path=\"results/xwave\")\n\nThe last step is submitting the job to start the simulation.\n\nsubmit(job)\n\n    <video controls loop=\"true\">\n        <source src=\"https://github.com/user-attachments/assets/b9839787-f265-43f4-9d57-a33375ad9610\" />\n    </video>","category":"section"}]
}
